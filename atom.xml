<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://blog.baoshuo.ren</id>
    <title>宝硕博客</title>
    <updated>2022-10-29T23:55:52.815Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <author>
        <name>宝硕</name>
        <uri>https://baoshuo.ren</uri>
    </author>
    <link rel="alternate" href="https://blog.baoshuo.ren"/>
    <entry>
        <title type="html"><![CDATA[USTC Hackergame 2022 Write Up]]></title>
        <id>/post/ustc-hackergame-2022-write-up/</id>
        <link href="/post/ustc-hackergame-2022-write-up/"/>
        <updated>2022-10-29T23:54:00.000Z</updated>
        <content type="html"><![CDATA[<h2 id="签到-2">签到</h2><p>日常改参数。</p><p><img src="https://arina.loli.net/2022/10/22/g6qoWrfzeBpnYOE.png" alt="" loading="lazy"></p><h2 id="猫咪问答喵">猫咪问答喵</h2><ol><li><p>中国科学技术大学 NEBULA 战队（USTC NEBULA）是于何时成立的喵？</p><p><a href="https://cybersec.ustc.edu.cn/2022/0826/c23847a565848/page.htm" rel="external nofollow noreferrer"></a></p><p>在这个页面中有这样一段介绍：</p><blockquote><p><strong>星云战队（Nebula）</strong></p><p>中国科学技术大学“星云战队（Nebula）”成立于 <strong>2017 年 3 月</strong>，“星云”一词来自中国科学技术大学 BBS“瀚海星云”，代表同学们对科学技术的无限向往和追求。战队现领队为网络空间安全学院吴文涛老师，现任队长为网络空间安全学院李蔚林、童蒙和武汉。战队核心成员包括了来自网络空间安全学院、少年班学院、物理学院、计算机学院等各个院系的同学，充分体现了我校多学院共建网络空间安全一级学科的特点。战队以赛代练，以赛促学，在诸多赛事中获得佳绩。</p></blockquote><p>可知答案为 <code>2017-03</code>。</p></li></ol><ol start="3"><li><p>22 年坚持，小 C 仍然使用着一台他从小用到大的 Windows 2000 计算机。那么，在不变更系统配置和程序代码的前提下，Firefox 浏览器能在 Windows 2000 下运行的最后一个大版本号是多少？</p><p>Google 搜索 <code>windows 2000 firefox</code> 可以搜索到一个帖子：<a href="https://www.betaarchive.com/forum/viewtopic.php?t=34790" rel="external nofollow noreferrer">Last version of fireFox to work on Windows 2000?</a>，可知答案为 12。</p></li><li><p>你知道 PwnKit（CVE-2021-4034）喵？据可靠谣传，出题组的某位同学本来想出这样一道类似的题，但是发现 Linux 内核更新之后居然不再允许 argc 为 0 了喵！那么，请找出在 Linux 内核 master 分支（torvalds/linux.git）下，首个变动此行为的 commit 的 hash 吧喵！</p><p>关于这部分的限制在 <code>fs/exec.c</code> 文件下，那么 <code>git blame</code> 可知这部分是在 <a href="https://github.com/torvalds/linux/commit/dcd46d897adb70d63e025f175a00a89797d31a43" rel="external nofollow noreferrer"><code>dcd46d8</code></a> 中被修改的。</p></li></ol><h2 id="家目录里的秘密">家目录里的秘密</h2><h3 id="vs-code-里的-flag">VS Code 里的 flag</h3><p>全局搜索 <code>flag&#123;</code> 可得：</p><p><img src="https://arina.loli.net/2022/10/23/Wa7JPK3rlwYLN9b.png" alt="" loading="lazy"></p><h3 id="rclone-里的-flag">rclone 里的 flag</h3><p><img src="https://arina.loli.net/2022/10/23/Fj2cKvUZOIrdiSY.png" alt="" loading="lazy"></p><p>在 <code>rclone.conf</code> 里可以找到一个密码，通过在 Google 上搜索可以找到 <a href="https://forum.rclone.org/t/how-to-retrieve-a-crypt-password-from-a-config-file/20051/3" rel="external nofollow noreferrer">一份现成的解密代码</a>：</p><pre><code class="hljs go"><span class="hljs-keyword">package</span> main

<span class="hljs-keyword">import</span> (
    <span class="hljs-string">&quot;crypto/aes&quot;</span>
    <span class="hljs-string">&quot;crypto/cipher&quot;</span>
    <span class="hljs-string">&quot;crypto/rand&quot;</span>
    <span class="hljs-string">&quot;encoding/base64&quot;</span>
    <span class="hljs-string">&quot;errors&quot;</span>
    <span class="hljs-string">&quot;fmt&quot;</span>
    <span class="hljs-string">&quot;log&quot;</span>
)

<span class="hljs-comment">// crypt internals</span>
<span class="hljs-keyword">var</span> (
    cryptKey = []<span class="hljs-type">byte</span>&#123;
        <span class="hljs-number">0x9c</span>, <span class="hljs-number">0x93</span>, <span class="hljs-number">0x5b</span>, <span class="hljs-number">0x48</span>, <span class="hljs-number">0x73</span>, <span class="hljs-number">0x0a</span>, <span class="hljs-number">0x55</span>, <span class="hljs-number">0x4d</span>,
        <span class="hljs-number">0x6b</span>, <span class="hljs-number">0xfd</span>, <span class="hljs-number">0x7c</span>, <span class="hljs-number">0x63</span>, <span class="hljs-number">0xc8</span>, <span class="hljs-number">0x86</span>, <span class="hljs-number">0xa9</span>, <span class="hljs-number">0x2b</span>,
        <span class="hljs-number">0xd3</span>, <span class="hljs-number">0x90</span>, <span class="hljs-number">0x19</span>, <span class="hljs-number">0x8e</span>, <span class="hljs-number">0xb8</span>, <span class="hljs-number">0x12</span>, <span class="hljs-number">0x8a</span>, <span class="hljs-number">0xfb</span>,
        <span class="hljs-number">0xf4</span>, <span class="hljs-number">0xde</span>, <span class="hljs-number">0x16</span>, <span class="hljs-number">0x2b</span>, <span class="hljs-number">0x8b</span>, <span class="hljs-number">0x95</span>, <span class="hljs-number">0xf6</span>, <span class="hljs-number">0x38</span>,
    &#125;
    cryptBlock cipher.Block
    cryptRand  = rand.Reader
)

<span class="hljs-comment">// crypt transforms in to out using iv under AES-CTR.</span>
<span class="hljs-comment">//</span>
<span class="hljs-comment">// in and out may be the same buffer.</span>
<span class="hljs-comment">//</span>
<span class="hljs-comment">// Note encryption and decryption are the same operation</span>
<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">crypt</span><span class="hljs-params">(out, in, iv []<span class="hljs-type">byte</span>)</span></span> <span class="hljs-type">error</span> &#123;
    <span class="hljs-keyword">if</span> cryptBlock == <span class="hljs-literal">nil</span> &#123;
        <span class="hljs-keyword">var</span> err <span class="hljs-type">error</span>
        cryptBlock, err = aes.NewCipher(cryptKey)
        <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;
            <span class="hljs-keyword">return</span> err
        &#125;
    &#125;
    stream := cipher.NewCTR(cryptBlock, iv)
    stream.XORKeyStream(out, in)
    <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>
&#125;

<span class="hljs-comment">// Reveal an obscured value</span>
<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Reveal</span><span class="hljs-params">(x <span class="hljs-type">string</span>)</span></span> (<span class="hljs-type">string</span>, <span class="hljs-type">error</span>) &#123;
    ciphertext, err := base64.RawURLEncoding.DecodeString(x)
    <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;
        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;&quot;</span>, fmt.Errorf(<span class="hljs-string">&quot;base64 decode failed when revealing password - is it obscured? %w&quot;</span>, err)
    &#125;
    <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(ciphertext) &lt; aes.BlockSize &#123;
        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;&quot;</span>, errors.New(<span class="hljs-string">&quot;input too short when revealing password - is it obscured?&quot;</span>)
    &#125;
    buf := ciphertext[aes.BlockSize:]
    iv := ciphertext[:aes.BlockSize]
    <span class="hljs-keyword">if</span> err := crypt(buf, buf, iv); err != <span class="hljs-literal">nil</span> &#123;
        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;&quot;</span>, fmt.Errorf(<span class="hljs-string">&quot;decrypt failed when revealing password - is it obscured? %w&quot;</span>, err)
    &#125;
    <span class="hljs-keyword">return</span> <span class="hljs-type">string</span>(buf), <span class="hljs-literal">nil</span>
&#125;

<span class="hljs-comment">// MustReveal reveals an obscured value, exiting with a fatal error if it failed</span>
<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">MustReveal</span><span class="hljs-params">(x <span class="hljs-type">string</span>)</span></span> <span class="hljs-type">string</span> &#123;
    out, err := Reveal(x)
    <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;
        log.Fatalf(<span class="hljs-string">&quot;Reveal failed: %v&quot;</span>, err)
    &#125;
    <span class="hljs-keyword">return</span> out
&#125;

<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;
    fmt.Println(MustReveal(<span class="hljs-string">&quot;tqqTq4tmQRDZ0sT_leJr7-WtCiHVXSMrVN49dWELPH1uce-5DPiuDtjBUN3EI38zvewgN5JaZqAirNnLlsQ&quot;</span>))
&#125;</code></pre><p>跑一遍就出来了：</p><p><img src="https://arina.loli.net/2022/10/23/HdkNQMnDtKPC2pi.png" alt="" loading="lazy"></p><h2 id="heilang">HeiLang</h2><p>打开 VSCode，将 <code>\| ([\d]+)\] = ([\d]+)</code> 递归替换为 <code>] = $2\na[$1] = $2</code>，然后执行脚本即可得到 flag：</p><p><img src="https://arina.loli.net/2022/10/22/MXHg5NSwhCptjnb.png" alt="" loading="lazy"></p><h2 id="xcaptcha">Xcaptcha</h2><p>在打开验证码页面的一瞬间将这段 JS 脚本塞进控制台里即可。</p><pre><code class="hljs javascript"><span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">1</span>; i &lt;= <span class="hljs-number">3</span>; i++) &#123;
  <span class="hljs-keyword">let</span> raw_str = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">querySelector</span>(<span class="hljs-string">`label[for=&quot;captcha<span class="hljs-subst">$&#123;i&#125;</span>&quot;]`</span>).<span class="hljs-property">innerHTML</span>;
  <span class="hljs-keyword">let</span> match = <span class="hljs-regexp">/([\d]+)\+([\d]+)/</span>.<span class="hljs-title function_">exec</span>(raw_str);
  <span class="hljs-keyword">let</span> sum = <span class="hljs-title class_">BigInt</span>(match[<span class="hljs-number">1</span>]) + <span class="hljs-title class_">BigInt</span>(match[<span class="hljs-number">2</span>]);
  <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&#x27;captcha&#x27;</span> + i).<span class="hljs-property">value</span> = sum.<span class="hljs-title function_">toString</span>();
&#125;

<span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&#x27;submit&#x27;</span>).<span class="hljs-title function_">click</span>();</code></pre><p><img src="https://arina.loli.net/2022/10/23/pHf1hyrcMCaO3AF.png" alt="" loading="lazy"></p><h2 id="旅行照片-2-0">旅行照片 2.0</h2><h3 id="照片分析">照片分析</h3><p><img src="https://arina.loli.net/2022/10/22/JKqzcnk2Iv7GYF4.png" alt="" loading="lazy"></p><p>exiftool 一把梭。</p><h2 id="latex-机器人">LaTeX 机器人</h2><h3 id="纯文本">纯文本</h3><p>众所周知，LaTeX 有一个 <code>\input</code> 指令：</p><p><img src="https://arina.loli.net/2022/10/22/oTlw9jqFINLvQZA.png" alt="" loading="lazy"></p><p>Flag 到手：<code>flag&#123;becAr3fu11dUd3c5a1b17ffa&#125;</code>。</p><h2 id="安全的在线测评">安全的在线测评</h2><h3 id="无法-ac-的题目">无法 AC 的题目</h3><p>最开始我打算在程序里读文件，结果不知道为什么写挂了……</p><p>于是就立马想到了用汇编读文件，代码和动态数据差不多。</p><h3 id="动态数据">动态数据</h3><p>查看评测机的源码可以发现 n = 5，那么可以用汇编在编译的时候读文件：</p><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string.h&gt;</span></span>

<span class="hljs-keyword">asm</span>(<span class="hljs-string">&quot;staticInput: .incbin \&quot;data/static.in\&quot;&quot;</span>);
<span class="hljs-keyword">asm</span>(<span class="hljs-string">&quot;staticAnswer: .incbin \&quot;data/static.out\&quot;&quot;</span>);
<span class="hljs-keyword">asm</span>(<span class="hljs-string">&quot;dynamicInput0: .incbin \&quot;data/dynamic0.in\&quot;&quot;</span>);
<span class="hljs-keyword">asm</span>(<span class="hljs-string">&quot;dynamicInput1: .incbin \&quot;data/dynamic1.in\&quot;&quot;</span>);
<span class="hljs-keyword">asm</span>(<span class="hljs-string">&quot;dynamicInput2: .incbin \&quot;data/dynamic2.in\&quot;&quot;</span>);
<span class="hljs-keyword">asm</span>(<span class="hljs-string">&quot;dynamicInput3: .incbin \&quot;data/dynamic3.in\&quot;&quot;</span>);
<span class="hljs-keyword">asm</span>(<span class="hljs-string">&quot;dynamicInput4: .incbin \&quot;data/dynamic4.in\&quot;&quot;</span>);
<span class="hljs-keyword">asm</span>(<span class="hljs-string">&quot;dynamicAnswer0: .incbin \&quot;data/dynamic0.out\&quot;&quot;</span>);
<span class="hljs-keyword">asm</span>(<span class="hljs-string">&quot;dynamicAnswer1: .incbin \&quot;data/dynamic1.out\&quot;&quot;</span>);
<span class="hljs-keyword">asm</span>(<span class="hljs-string">&quot;dynamicAnswer2: .incbin \&quot;data/dynamic2.out\&quot;&quot;</span>);
<span class="hljs-keyword">asm</span>(<span class="hljs-string">&quot;dynamicAnswer3: .incbin \&quot;data/dynamic3.out\&quot;&quot;</span>);
<span class="hljs-keyword">asm</span>(<span class="hljs-string">&quot;dynamicAnswer4: .incbin \&quot;data/dynamic4.out\&quot;&quot;</span>);

<span class="hljs-keyword">extern</span> <span class="hljs-type">char</span> staticInput[];
<span class="hljs-keyword">extern</span> <span class="hljs-type">char</span> staticAnswer[];
<span class="hljs-keyword">extern</span> <span class="hljs-type">char</span> dynamicInput0[];
<span class="hljs-keyword">extern</span> <span class="hljs-type">char</span> dynamicInput1[];
<span class="hljs-keyword">extern</span> <span class="hljs-type">char</span> dynamicInput2[];
<span class="hljs-keyword">extern</span> <span class="hljs-type">char</span> dynamicInput3[];
<span class="hljs-keyword">extern</span> <span class="hljs-type">char</span> dynamicInput4[];
<span class="hljs-keyword">extern</span> <span class="hljs-type">char</span> dynamicAnswer0[];
<span class="hljs-keyword">extern</span> <span class="hljs-type">char</span> dynamicAnswer1[];
<span class="hljs-keyword">extern</span> <span class="hljs-type">char</span> dynamicAnswer2[];
<span class="hljs-keyword">extern</span> <span class="hljs-type">char</span> dynamicAnswer3[];
<span class="hljs-keyword">extern</span> <span class="hljs-type">char</span> dynamicAnswer4[];

<span class="hljs-type">char</span> n[<span class="hljs-number">1000000</span>], a[<span class="hljs-number">6</span>][<span class="hljs-number">1000000</span>], p[<span class="hljs-number">1000000</span>], q[<span class="hljs-number">1000000</span>];

<span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> **argv[])</span> &#123;
    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%s\n&quot;</span>, &amp;n);

    <span class="hljs-built_in">sscanf</span>(staticInput, <span class="hljs-string">&quot;%s&quot;</span>, a[<span class="hljs-number">0</span>]);
    <span class="hljs-built_in">sscanf</span>(dynamicInput0, <span class="hljs-string">&quot;%s&quot;</span>, a[<span class="hljs-number">1</span>]);
    <span class="hljs-built_in">sscanf</span>(dynamicInput1, <span class="hljs-string">&quot;%s&quot;</span>, a[<span class="hljs-number">2</span>]);
    <span class="hljs-built_in">sscanf</span>(dynamicInput2, <span class="hljs-string">&quot;%s&quot;</span>, a[<span class="hljs-number">3</span>]);
    <span class="hljs-built_in">sscanf</span>(dynamicInput3, <span class="hljs-string">&quot;%s&quot;</span>, a[<span class="hljs-number">4</span>]);
    <span class="hljs-built_in">sscanf</span>(dynamicInput4, <span class="hljs-string">&quot;%s&quot;</span>, a[<span class="hljs-number">5</span>]);

    <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">strcmp</span>(n, a[<span class="hljs-number">0</span>])) &#123;
        <span class="hljs-built_in">sscanf</span>(staticAnswer, <span class="hljs-string">&quot;%s\n%s&quot;</span>, p, q);
        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%s\n%s\n&quot;</span>, p, q);
    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">strcmp</span>(n, a[<span class="hljs-number">1</span>])) &#123;
        <span class="hljs-built_in">sscanf</span>(dynamicAnswer0, <span class="hljs-string">&quot;%s\n%s&quot;</span>, p, q);
        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%s\n%s\n&quot;</span>, p, q);
    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">strcmp</span>(n, a[<span class="hljs-number">2</span>])) &#123;
        <span class="hljs-built_in">sscanf</span>(dynamicAnswer1, <span class="hljs-string">&quot;%s\n%s&quot;</span>, p, q);
        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%s\n%s\n&quot;</span>, p, q);
    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">strcmp</span>(n, a[<span class="hljs-number">3</span>])) &#123;
        <span class="hljs-built_in">sscanf</span>(dynamicAnswer2, <span class="hljs-string">&quot;%s\n%s&quot;</span>, p, q);
        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%s\n%s\n&quot;</span>, p, q);
    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">strcmp</span>(n, a[<span class="hljs-number">4</span>])) &#123;
        <span class="hljs-built_in">sscanf</span>(dynamicAnswer3, <span class="hljs-string">&quot;%s\n%s&quot;</span>, p, q);
        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%s\n%s\n&quot;</span>, p, q);
    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">strcmp</span>(n, a[<span class="hljs-number">5</span>])) &#123;
        <span class="hljs-built_in">sscanf</span>(dynamicAnswer4, <span class="hljs-string">&quot;%s\n%s&quot;</span>, p, q);
        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%s\n%s\n&quot;</span>, p, q);
    &#125;

    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
&#125;</code></pre><p><img src="https://arina.loli.net/2022/10/23/f7FIqpXbV61iyRl.png" alt="" loading="lazy"></p><h2 id="企鹅拼盘">企鹅拼盘</h2><h3 id="这么简单我闭眼都可以！">这么简单我闭眼都可以！</h3><p>手动一个一个试就好啦~</p><p><img src="https://arina.loli.net/2022/10/23/ANl2KCbYjL76MtB.png" alt="" loading="lazy"></p><p><img src="https://arina.loli.net/2022/10/23/DeyVZRbJCQ25WPf.png" alt="" loading="lazy"></p><h2 id="后记-10">后记</h2><p><img src="https://arina.loli.net/2022/10/29/afcCSBUqALiImz4.png" alt="" loading="lazy"></p><p>今年是我打 Hackergame 的第三年了，由于近期学业繁忙（甚至我刚从 CSP-S 考场出来就回来写 Write Up），所以并没有能抽出足够的时间来享受这场比赛了，只能用两天的零碎时间水一点签到题了事，binary 还是一如既往地稀烂……</p>]]></content>
        <author>
            <name>宝硕</name>
            <uri>https://baoshuo.ren</uri>
        </author>
    </entry>
    <entry>
        <title type="html"><![CDATA[OIerDb NG —— 新一代的 OIerDb]]></title>
        <id>/post/oierdb-ng/</id>
        <link href="/post/oierdb-ng/"/>
        <updated>2022-08-09T11:54:10.000Z</updated>
        <summary type="html"><![CDATA[笔者有幸能与 OI 巨神虞浩翔等人合作来共同参与 OIerDb NG 的开发，经过数个月的不断改进，目前项目已经初具雏形，特此写下本篇文章对其进行简要介绍。]]></summary>
        <content type="html"><![CDATA[<img src="https://arina.loli.net/2022/08/09/JAfhVcazSdvQRbr.png" width="100%" alt="OIerDb NG —— 新一代的 OIerDb" /><p>笔者有幸能与 OI 巨神虞浩翔等人合作来共同参与 OIerDb NG 的开发，经过数个月的不断改进，目前项目已经初具雏形，特此写下本篇文章对其进行简要介绍。</p><span id="more"></span><p>笔者主要参与了前端用户界面的开发工作，而数据处理部分则主要由虞浩翔完成。</p><h2 id="oierdb-ng-的新特性">OIerDb NG 的新特性</h2><h3 id="纯前端处理-——-效率更高、可离线使用">纯前端处理 —— 效率更高、可离线使用</h3><p>相比于老版 OIerDb，OIerDb NG 摈弃了传统的「客户端发送查询请求 -&gt; 服务器响应查询请求」的模式，而是采用了纯前端的处理方式 —— 将数据库存储在浏览器的 indexedDB 中，这样在用户查询时无需向服务器发送请求，直接在浏览器端即可处理。这样带来的好处是显而易见的 —— 我们拥有了更快的查询响应速度，同时也减轻了对服务器的压力。至于缺点嘛… 在首次访问网页的时候会下载几 MB 的数据，从统计数据来看，这个过程在大部分情况下最多需要消耗 5 秒左右的时间。</p><p>在下载好所有页面的代码、数据加载完成后，即使断开网络连接也能正常使用 OIerDb NG 的基础功能 <s>，可以在断网打模拟赛 AK 之后找点东西看</s> 。</p><h3 id="查询更灵活-——-满足用户的不同需求">查询更灵活 —— 满足用户的不同需求</h3><p><img src="https://arina.loli.net/2022/08/09/Y6qm4beaZB2XMWO.png" alt="" loading="lazy"></p><p>老版的 OIerDb 只能应对两种类型的查询 —— 以选手或者学校为中心的查询。而新版的 OIerDb 在设计之初就希望具备应对更灵活的查询请求的能力，比如「查询『NOIP 2021』中『河北省』的获奖情况」（如上图所示），更进一步的话还可以「查询『NOIP 2021』中位于『河北省』的『石家庄市第二中学』的获奖情况」（不过这种查询目前还没有在用户界面中实现）。</p><h2 id="开发回忆录">开发回忆录</h2><p>在 2021 年 12 月初的一天中午，笔者在 <a href="https://bytew.net/OIer/" rel="external nofollow noreferrer">OIerDb</a> 的页面底部发现了 nocriz 的《<a href="https://bytew.net/?p=807" rel="external nofollow noreferrer">呼吁广大选手积极参与开发下一代 OIerDb</a>》文章，恰巧笔者在课余时间学习了一些在现在看来非常浅薄的前端技术，于是跃跃欲试地在 12 月 12 号的那天创建了一个新的 GitHub 仓库，并使用模板来提交了 <a href="https://github.com/OIerDb-ng/OIerDb/commit/2e4ec6e0d18bc4d312a1f5a647fa196fee17db38" rel="external nofollow noreferrer">第一个 commit</a>。</p><p>接下来的几天，笔者利用自己的空余时间来编写代码，终于在 12 月 19 日完成了第一版的 OIerDb NG，并部署到了 Netlify 上。</p><p><img src="https://arina.loli.net/2022/08/09/S4zFETYOA6blJWC.png" alt="" loading="lazy"></p><p>▲ OIerDb NG 的第一版界面。</p><p>当时笔者初学 React，许多知识仍有待学习，再加之笔者忙于完成学业，因此开发进度异常缓慢，网站的功能也有很多欠缺。</p><p>第一版完成后没多久，笔者找到了精通 React 的好友 <a href="https://men.ci" rel="external nofollow noreferrer">Menci</a> 来帮忙 review 代码。在这个过程中，Menci 提出了许多富有建设性的意见，同时对项目整体进行了一番调整，使其更加现代化、工程化。笔者也从中学到了很多知识。</p><p>之后笔者边实践边学习，还从 <a href="https://loj.ac" rel="external nofollow noreferrer">LibreOJ</a> 的前端中抄来了一些代码，比如手机端的导航栏。</p><p>慢慢地，OIerDb NG 上线了 nocriz 的文章中提到的大部分功能（点击图片可以前往对应页面）：</p><style>.oierdb-ng__2col-img{display:flex;justify-content:space-between;width:100%;gap:.5rem}@media (max-width:768px){.oierdb-ng__2col-img{display:block}}</style><p class="oierdb-ng__2col-img"><a href="https://oier.baoshuo.dev" rel="external nofollow noreferrer" target="_blank"><img src="https://arina.loli.net/2022/08/09/5ZMae91ozyWgSwE.png"></a><a href="https://oier.baoshuo.dev/?advanced=1" rel="external nofollow noreferrer" target="_blank"><img src="https://arina.loli.net/2022/08/09/oWTktpmqh4V2OnX.png"></a></p><p>▲ 基础 / 高级搜索</p><p><a href="https://oier.baoshuo.dev/oier/23851" rel="external nofollow noreferrer"><img src="https://arina.loli.net/2022/08/09/JGBz5gtPh1loI2w.png" alt="" loading="lazy"></a></p><p>▲ 搜索页选手信息卡片</p><p class="oierdb-ng__2col-img"><a href="https://oier.baoshuo.dev/oier" rel="external nofollow noreferrer" target="_blank"><img src="https://arina.loli.net/2022/08/09/dcJLNr3p2VmUusi.png"></a><a href="https://oier.baoshuo.dev/school" rel="external nofollow noreferrer" target="_blank"><img src="https://arina.loli.net/2022/08/09/Dntk8KYyzJXZPea.png"></a></p><p>▲ 地区信息学奥林匹克竞赛选手 / 学校排名</p><p class="oierdb-ng__2col-img"><a href="https://oier.baoshuo.dev/school/36" rel="external nofollow noreferrer" target="_blank"><img src="https://arina.loli.net/2022/08/09/iOgCyW6AtdV1QYT.png"></a><a href="https://oier.baoshuo.dev/contest/90" rel="external nofollow noreferrer" target="_blank"><img src="https://arina.loli.net/2022/08/09/2iDznumIocLMHPv.png"></a></p><p>▲ 学校 / 比赛详情页面</p><h2 id="oierdb-ng-的不足之处">OIerDb NG 的不足之处</h2><p>尽管 OIerDb NG 有了一个还算可以的开始，但仍然存在诸多不足之处。</p><p>例如，对于网络速度较慢的用户，加载数 MB 的数据可能仍需要十几秒甚至数十秒。并且，即使是一些小更新也需要重新从服务器拉取全量数据，对用户与服务器的流量都是一种浪费。</p><p>再比如一些用户可能需要指向性更强的查询条件，目前还没有找到一个比较好的办法来添加到用户界面中。</p><p>除了这些之外，还有一些其他的问题存在。这些问题由于团队内的各位开发者都在现实生活中有着自己的工作、学习任务，无法去逐一解决。笔者希望广大对信息学竞赛感兴趣的朋友们能或多或少地参与进 OIerDb NG 的开发，共同为信息学竞赛社区做出贡献。</p><h2 id="后记-6">后记</h2><p>感谢 nocriz 建立的 OIerDb 网站，为国内的信息学竞赛社区做出了巨大贡献。</p><p>也感谢 <a href="https://github.com/yhx-12243" rel="external nofollow noreferrer">yhx-12243</a>、<a href="https://men.ci" rel="external nofollow noreferrer">Menci</a> 参与 OIerDb NG 的开发，完成了许多工作。</p><p>最后的最后，给 <a href="https://github.com/OIerDb-ng/OIerDb" rel="external nofollow noreferrer">OIerDb-ng/OIerDb</a> 求一波 Star~</p>]]></content>
        <author>
            <name>宝硕</name>
            <uri>https://baoshuo.ren</uri>
        </author>
    </entry>
    <entry>
        <title type="html"><![CDATA[拥抱 Atomic CSS-in-JS]]></title>
        <id>/post/atomic-css-in-js/</id>
        <link href="/post/atomic-css-in-js/"/>
        <updated>2022-07-23T09:30:29.000Z</updated>
        <summary type="html"><![CDATA[当下，Atomic CSS 愈发受到人们的关注。相比于传统 CSS 编写方法中每个组件对应一个 CSS 类，使用了 Atomic CSS 以后，每一个 CSS 类都唯一对应了一条独立的 CSS 规则，随着组件数量逐渐增加、能复用的 CSS 规则越来越多，最终的 CSS 产物体积也会下降许多，使得网页的加载速度能够产生一个质的飞跃。]]></summary>
        <content type="html"><![CDATA[<img src="https://s1.baoshuo.ren/2022/07/23/R2LQrmhBxc3PEFy.webp" width="100%" alt="拥抱 Atomic CSS-in-JS" /><p>当下，Atomic CSS 愈发受到人们的关注。相比于传统 CSS 编写方法中每个组件对应一个 CSS 类，使用了 Atomic CSS 以后，每一个 CSS 类都唯一对应了一条独立的 CSS 规则，随着组件数量逐渐增加、能复用的 CSS 规则越来越多，最终的 CSS 产物体积也会下降许多，使得网页的加载速度能够产生一个质的飞跃。</p><span id="more"></span><h2 id="css-编写方法的发展历程">CSS 编写方法的发展历程</h2><p>在介绍 Atomic CSS 之前，让我们先来回顾一下 CSS 编写方法的发展历程。</p><h3 id="smacss">SMACSS</h3><p><a href="http://smacss.com" rel="external nofollow noreferrer">SMACSS</a>（Scalable &amp; Modular Architecture for CSS），是由 Jonathan Snook 提出的 CSS 理论。其主要原则有 3 条：</p><ul><li>Categorizing CSS Rules（为 CSS 分类）</li><li>Naming Rules（命名规则）</li><li>Minimizing the Depth of Applicability（最小化适配深度）</li></ul><h4 id="规则分类">规则分类</h4><p>SMACSS 将规则分为了五类：Base（基础）、Layout（布局）、Module（模块）、State（状态）、Theme（主题）。</p><p><strong>基础（Base）</strong> 规则里放置默认样式。这些默认样式基本上都是元素选择器，不过也可以包含属性选择器，伪类选择器，孩子选择器，兄弟选择器。本质上来说，一个基础样式定义了元素在页面的任何位置应该是怎么样的。</p><p><strong>布局（Layout）</strong> 规则将页面拆分成几个部分，每个部分都可能有一到多个模块。顾名思义，这个分类主要用来做页面的整体或其中一块区域的布局。</p><p><strong>模块（Modules）</strong> 是我们的设计当中可重用，可模块化的部分。插图，侧边栏，文章列表等等都属于模块。</p><p><strong>状态（State）</strong> 规则定义了我们的模块或者布局在特殊的状态下应该呈现怎样的效果。它可能定义模块、布局在不同显示屏上应该如何显示。也可能定义一个模块在不同页面（例如主页和内页）中可能呈现怎么样的效果。</p><p><strong>主题（Theme）</strong> 规则和状态规则类似，定义模块或者布局的外观。很多网站的「深色模式」「换肤」等等功能就是这样实现的。</p><h4 id="命名规则">命名规则</h4><p>将规则分成五类之后，还需要命名规范。命名规范能够使得我们立刻了解到某个样式属于哪一类，以及它在整个页面中起到的作用。在一个大型项目中，我们可能会将一个样式分割成几个文件，这个时候命名约定能够使得我们更容易知道这个样式属于哪个文件。</p><p>推荐使用前缀来区分布局、模块和状态等等规则。比如对布局规则使用 <code>layout-</code> 前缀，对状态规则使用 <code>is-</code> 前缀就是一个不错的选择。</p><h4 id="最小化适配深度">最小化适配深度</h4><p>尽量不要依赖文档树的结构来编写样式。这样可以让我们的样式更加灵活，并且容易维护。</p><h3 id="bem">BEM</h3><p><a href="http://getbem.com" rel="external nofollow noreferrer">BEM</a>（ Block Element Modifier）是由 Yandex 团队提出的一种前端 CSS 命名方法论。它是一个简单又非常有用的命名约定。让前端代码更容易阅读和理解，更容易协作，更容易控制，更加健壮和明确，而且更加严密。</p><p>BEM 命名约定的模式是：</p><pre><code class="hljs css"><span class="hljs-selector-class">.block</span> &#123;
&#125;

<span class="hljs-selector-class">.block__element</span> &#123;
&#125;

<span class="hljs-selector-class">.block--modifier</span> &#123;
&#125;</code></pre><ul><li><code>block</code> 代表了「块」，用于组件本体。</li><li><code>element</code> 代表了「块」中的某个「元素」（也可以叫做「子组件」），是块构成的主要成员。</li><li><code>modifier</code> 代表了「块」的修饰符，表示不同的状态和版本。使用 <code>--</code> 做区分，适用于「块」和「元素」，分别称之为「块修饰符」和「元素修饰符」。</li></ul><p>命名的不同部分之间之所以使用 <code>__</code> 和 <code>--</code> 分割，是因为如果某部分中如果出现了多个单词需要使用 <code>-</code> 分隔，这样可以避免造成混淆。</p><h3 id="css-modules">CSS Modules</h3><p>随着时代的发展，一个大型前端工程中的 CSS 类名越来越多，此时难免会出现类名冲突的情况，此时 CSS Modules 应运而生 —— 它通过为 CSS 类名添加 Hash 等方式来产生唯一的名称来防止冲突的产生。</p><p><a href="https://github.com/css-modules/css-modules" rel="external nofollow noreferrer">CSS Modules</a> 并不是 CSS 官方的标准，也不是浏览器的特性，而是使用一些构建工具，比如 Webpack，对 CSS 类名和选择器限定作用域的一种方式。</p><h3 id="utility-first-css">Utility-First CSS</h3><p>当传统大型项目使用的 CSS 方法论还都大多是上方提到的 OOCSS、SMACSS、BEM 等等主要聚焦在「关注点分离」的「语义化 CSS」方案的时候，Utility-First 的 CSS 概念脱颖而出、逐渐受到社区的关注。而这之中最为被人熟知的、也最典型的就是 <a href="https://tailwindcss.com" rel="external nofollow noreferrer">Tailwind CSS</a> 了。</p><p>Utility-First CSS 不像 Semantic CSS 那样将组件样式放在一个类中，而是为我们提供一个由不同功能类组成的工具箱，我们可以将它们混合在一起应用在页面元素上。这样有几个好处：</p><ul><li>不用纠结于类名的命名；</li><li>功能越简单的类，复用率越高，可以减小最终的打包大小；</li><li>不存在全局样式污染问题；</li><li>等等。</li></ul><p>但也存在一些不足：</p><ul><li><code>class</code> 属性的内容过长；</li><li>存在 CSS 规则插入顺序相关的问题；</li><li>不能通过语义化类名得知组件的作用；</li><li>不压缩的话构建产物体积过大。</li></ul><h2 id="新时代，来临了-——-atomic-css-in-js">新时代，来临了 —— Atomic CSS-in-JS</h2><p>在前文介绍的 Utility-First CSS 的基础之上更进一步，Atomic CSS 便映入了人们的眼帘。</p><p>Atomic CSS 背后的思想与以往的「关注点分离」的思想可以称得上是背道而驰了。使用 Atomic CSS 时实际上将结构层和样式层耦合在了一起，这样的方式在现代 CSS-in-JS 的代码库中基本上得到了广泛认可，下文将会进行进一步的介绍。</p><p>Atomic CSS 可以看作是 Utility-First CSS 的极致抽象版本，每一个 CSS 类都对应一条单一的 CSS 规则。可面对如此繁复的 CSS 规则，手写 Atomic CSS 的类名并不是一个好的办法。于是 Atomic CSS-in-JS 应运而生，它可以看作是「自动化的 Atomic CSS」：</p><ul><li>无需手动设计 CSS 类名；</li><li>能够提取页面的关键 CSS，并进行代码拆分；</li><li>可以解决经典的 CSS 规则插入顺序的问题。</li></ul><h3 id="传统-css-编写方式的缺点">传统 CSS 编写方式的缺点</h3><p>Christopher Chedeau 一直致力于推广 React 生态系统中 CSS-in-JS 理念。在很多次演讲中，他都解释了 CSS 的几大问题：</p><p><img src="https://s1.baoshuo.ren/2022/07/23/5PTlQWfhkVZObpJ.png" alt="" loading="lazy"></p><ol><li>全局命名空间</li><li>依赖</li><li>无用代码消除</li><li>代码压缩</li><li>共享常量</li><li>非确定性（Non-Deterministic）解析</li><li>隔离</li></ol><p>虽然 Utility-First CSS 和 Atomic CSS 也解决了其中的一些问题，但它们无法解决所有问题（特别是样式的非确定性解析）。</p><p>举个例子：Tailwind CSS 会在生成时生成出来许多无用代码，导致样式文件体积的增长，看看下面这份代码：</p><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;before:bg-white before:p-4&quot;</span>&gt;</span>content<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></code></pre><p>生成出来的样式文件长这个样子：</p><pre><code class="hljs css"><span class="hljs-selector-class">.before</span>\:bg-white::before &#123;
  <span class="hljs-attribute">content</span>: <span class="hljs-built_in">var</span>(--tw-content);
  <span class="hljs-attr">--tw-bg-opacity</span>: <span class="hljs-number">1</span>;
  <span class="hljs-attribute">background-color</span>: <span class="hljs-built_in">rgb</span>(<span class="hljs-number">255</span> <span class="hljs-number">255</span> <span class="hljs-number">255</span> / <span class="hljs-built_in">var</span>(--tw-bg-opacity));
&#125;

<span class="hljs-selector-class">.before</span>\:p-<span class="hljs-number">4</span>::before &#123;
  <span class="hljs-attribute">content</span>: <span class="hljs-built_in">var</span>(--tw-content);
  <span class="hljs-attribute">padding</span>: <span class="hljs-number">1rem</span>;
&#125;</code></pre><p>可以看到这份文件中包括了许多的无用代码，比如重复的 <code>content: var(--tw-content)</code>。</p><h3 id="更小的构建产物">更小的构建产物</h3><p>传统的 CSS 编写方法无法复用组件间重复的 CSS 规则，比如下图中高亮的几条规则各自躺在它们对应的 CSS 类中：</p><p><img src="https://arina.loli.net/2022/07/23/TKvwu6PpgxalrsG.png" alt="" loading="lazy"></p><p>这样会导致 CSS 产物大小与项目的复杂程度和组件数量线性正相关。</p><p>但使用 Atomic CSS 之后，这些规则被提取出来进行复用：</p><p><img src="https://arina.loli.net/2022/07/23/xKRoETDVqQBgFcf.png" alt="" loading="lazy"></p><p>随着后期组件数量逐渐增加、能复用的 CSS 规则越来越多、最终 CSS 产物大小与项目复杂程度呈对数关系：</p><p><img src="https://s1.baoshuo.ren/2022/07/16/Uq6nbJXidShyzH8.png" alt="" loading="lazy"></p><p>Facebook 分享了他们的数据：在旧网站上，仅登录页就需要加载 413 KiB 的样式文件，而在使用 Atomic CSS-in-JS 重写后，整个站点只有 74 KiB 的样式文件，还包括了深色模式。</p><p>虽然在使用 Atomic CSS 之后，HTML 的体积会显著增大，不过由于这些类名的高冗余度，可以利用 gzip 来压缩掉很大一部分体积。</p><h3 id="处理-css-规则的插入顺序">处理 CSS 规则的插入顺序</h3><p>让我们再来回顾一遍这个经典的 CSS 规则插入顺序的问题：</p><p><img src="https://s1.baoshuo.ren/2022/07/23/dfu1NqZ7i3pmOrM.png" alt="" loading="lazy"></p><p>我们都知道，最后生效的样式不是最后一个类名对应的规则，而是样式表中最后插入的规则。</p><p>那么，如何在 CSS-in-JS 中处理这个问题呢？通用的做法是在生成阶段就将冲突的规则过滤掉，以避免产生冲突。比如下面这个组件：</p><pre><code class="hljs js"><span class="hljs-keyword">const</span> styles = style9.<span class="hljs-title function_">create</span>(&#123;
  <span class="hljs-attr">card</span>: &#123;
    <span class="hljs-attr">color</span>: <span class="hljs-string">&#x27;#000000&#x27;</span>,
  &#125;,
  <span class="hljs-attr">profileCard</span>: &#123;
    <span class="hljs-attr">color</span>: <span class="hljs-string">&#x27;#ffffff&#x27;</span>,
  &#125;,
&#125;);

<span class="hljs-keyword">const</span> <span class="hljs-title function_">Component</span> = (<span class="hljs-params"></span>) =&gt; (
  <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">className</span>=<span class="hljs-string">&#123;style9(styles.card,</span> <span class="hljs-attr">styles.profileCard</span>)&#125; /&gt;</span></span>
);</code></pre><p>过滤后组件的实际样式如下：</p><pre><code class="hljs css"><span class="hljs-attribute">color</span>: <span class="hljs-number">#ffffff</span>;</code></pre><p>而如果将组件样式中的 <code>styles.card</code> 和 <code>styles.profileCard</code> 调换一下顺序，过滤之后的样式就变成了这样：</p><pre><code class="hljs css"><span class="hljs-attribute">color</span>: <span class="hljs-number">#000000</span>;</code></pre><p>但 CSS 中有一些简写规则，如果只按照规则名称来处理显然是不行的。有的库强制开发者们不使用简写规则来避免这个问题，而另外的一些库则将这些简写规则展开成多条规则后再进行过滤，比如 <code>margin: 10px</code> 可以被拆成 <code>margin-top: 10px</code>、<code>margin-right: 10px</code>、<code>margin-bottom: 10px</code>、<code>margin-left: 10px</code> 四条独立的规则。</p><h3 id="经典实现">经典实现</h3><p>Atomic CSS-in-JS 实现有运行时（Runtime）和预编译（Pre-Compile）两种。运行时（Runtime）的优点在于可以动态生成样式，相比于下文中采用预编译方法的库来说灵活度高了不止一点半点。其缺点则在于 Vendor Prefix 等操作需要在 Runtime 执行，因此 Bundle 中必须携带相关依赖导致体积增大。预编译（Pre-Compile）的优点则在于无需将相关依赖打包发送给客户端，改善了性能。而缺点则是预编译的过程高度依赖静态代码分析，所以难以实现动态样式生成与组合。</p><h4 id="styletron">Styletron</h4><p><a href="https://styletron.org" rel="external nofollow noreferrer">Styletron</a> 是 Uber 公司开发的一个较为典型的运行时 Atomic CSS-in-JS 库，驱动了 Uber 的官网和 H5 页面。</p><p>Styletron 还提供了一套 Styled Components 的实现，可以通过下面的方式使用：</p><pre><code class="hljs javascript"><span class="hljs-keyword">import</span> &#123; styled &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;styletron-react&#x27;</span>;

<span class="hljs-keyword">const</span> <span class="hljs-title class_">Component</span> = <span class="hljs-title function_">styled</span>(<span class="hljs-string">&#x27;div&#x27;</span>, &#123;
  <span class="hljs-attr">marginTop</span>: <span class="hljs-string">&#x27;10px&#x27;</span>,
  <span class="hljs-attr">marginBottom</span>: <span class="hljs-string">&#x27;10px&#x27;</span>,
&#125;);

<span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">Component</span> /&gt;</span></span>;</code></pre><p>还可以根据 prop 的值来动态生成样式：</p><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> <span class="hljs-title class_">Component</span> = <span class="hljs-title function_">styled</span>(<span class="hljs-string">&#x27;div&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">props</span>) =&gt;</span> &#123;
  <span class="hljs-keyword">return</span> &#123; <span class="hljs-attr">color</span>: props.<span class="hljs-property">$fraction</span> &lt; <span class="hljs-number">0.5</span> ? <span class="hljs-string">&#x27;red&#x27;</span> : <span class="hljs-string">&#x27;green&#x27;</span> &#125;;
&#125;);

<span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">Component</span> $<span class="hljs-attr">fraction</span>=<span class="hljs-string">&#123;Math.random()&#125;</span> /&gt;</span></span>;</code></pre><h4 id="fela">Fela</h4><p>与 Styletron 同为运行时 Atomic CSS-in-JS 库的还有沃尔沃汽车前技术主管开发的 <a href="https://fela.js.org/" rel="external nofollow noreferrer">Fela</a>，驱动了沃尔沃汽车官网，Cloudflare Dashboard 和 Medium 等众多网站。</p><h4 id="vanilla-extract">vanilla-extract</h4><p><a href="https://www.youtube.com/watch?v=9JZHodNR184" rel="external nofollow noreferrer">Stylex</a> 是 Meta（原 Facebook）的一个尚未开源的预编译 Atomic CSS-in-JS 库。不过由于 Meta 迟迟不开源 stylex，社区中已经涌现出了数个基于其思想的开源实现，其中以 <a href="https://github.com/seek-oss/vanilla-extract" rel="external nofollow noreferrer">vanilla-extract</a> 最为知名。</p><h4 id="style9">style9</h4><p>基于 stylex 思想的预编译 Atomic CSS-in-JS 库除了 vanilla-extract 之外还有 <a href="https://github.com/johanholmerin/style9" rel="external nofollow noreferrer">style9</a> 和 <a href="https://github.com/necolas/styleq" rel="external nofollow noreferrer">styleQ</a>。</p><h4 id="compiled">compiled</h4><p>将视线从 stylex 系列中转移开来，Atlassian 还编写了一个名为 <a href="https://compiledcssinjs.com/" rel="external nofollow noreferrer">compiled</a> 的预编译 Atomic CSS-in-JS 库，但在笔者的实际使用过程中坑点较多，可能会导致样式的重复生成，并且其对 TypeScript 的支持也不尽人意，不过其代码实现中的许多技巧还是有借鉴价值的。</p><h5 id="styled-components">Styled Components</h5><p>compiled 依靠一个 babel transformer 来对代码进行转换以插入样式。</p><p>在 <a href="https://github.com/atlassian-labs/compiled/blob/ba66b35b82be513bf206d46c4adbdd7aefa3f7f1/packages/react/src/styled/index.tsx#L59-L83" rel="external nofollow noreferrer"><code>packages/react/src/styled/index.tsx</code></a> 文件中可以看到，<code>@compiled/react</code> 包含了一个导出了一个名为 <code>styled</code> 的对象，这个对象一旦被访问就会立刻抛出错误，提示 transformer 没有正常工作：</p><pre><code class="hljs typescript"><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> <span class="hljs-attr">styled</span>: <span class="hljs-title class_">StyledComponentInstantiator</span> = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Proxy</span>(
  &#123;&#125;,
  &#123;
    <span class="hljs-title function_">get</span>(<span class="hljs-params"></span>) &#123;
      <span class="hljs-keyword">return</span> <span class="hljs-function">() =&gt;</span> &#123;
        <span class="hljs-comment">// Blow up if the transformer isn&#x27;t turned on.</span>
        <span class="hljs-comment">// This code won&#x27;t ever be executed when setup correctly.</span>
        <span class="hljs-keyword">throw</span> <span class="hljs-title function_">createSetupError</span>();
      &#125;;
    &#125;,
  &#125;
) <span class="hljs-keyword">as</span> <span class="hljs-built_in">any</span>;</code></pre><p>那么可以看出，<code>styled</code> 会被 transformer 替换掉，对应的入口逻辑在 <a href="https://github.com/atlassian-labs/compiled/blob/ba66b35b82be513bf206d46c4adbdd7aefa3f7f1/packages/babel-plugin/src/babel-plugin.tsx" rel="external nofollow noreferrer"><code>packages/babel-plugin/src/babel-plugin.tsx</code></a> 文件中：</p><pre><code class="hljs typescript"><span class="hljs-title class_">ImportDeclaration</span>(path, state) &#123;
  <span class="hljs-comment">// 不是从 @compiled/react 导入的包不处理</span>
  <span class="hljs-keyword">if</span> (path.<span class="hljs-property">node</span>.<span class="hljs-property">source</span>.<span class="hljs-property">value</span> !== <span class="hljs-string">&#x27;@compiled/react&#x27;</span>) &#123;
    <span class="hljs-keyword">return</span>;
  &#125;

  <span class="hljs-comment">// 记录导入的模块</span>
  state.<span class="hljs-property">compiledImports</span> = &#123;&#125;;

  <span class="hljs-comment">// 遍历导入数组中的所有元素</span>
  path.<span class="hljs-title function_">get</span>(<span class="hljs-string">&#x27;specifiers&#x27;</span>).<span class="hljs-title function_">forEach</span>(<span class="hljs-function">(<span class="hljs-params">specifier</span>) =&gt;</span> &#123;
    <span class="hljs-keyword">if</span> (!state.<span class="hljs-property">compiledImports</span> || !specifier.<span class="hljs-title function_">isImportSpecifier</span>()) &#123;
      <span class="hljs-keyword">return</span>;
    &#125;

    ([<span class="hljs-string">&#x27;styled&#x27;</span>, <span class="hljs-string">&#x27;ClassNames&#x27;</span>, <span class="hljs-string">&#x27;css&#x27;</span>, <span class="hljs-string">&#x27;keyframes&#x27;</span>] <span class="hljs-keyword">as</span> <span class="hljs-keyword">const</span>).<span class="hljs-title function_">forEach</span>(<span class="hljs-function">(<span class="hljs-params">apiName</span>) =&gt;</span> &#123;
      <span class="hljs-keyword">if</span> (
        state.<span class="hljs-property">compiledImports</span> &amp;&amp;
        t.<span class="hljs-title function_">isIdentifier</span>(specifier.<span class="hljs-property">node</span>?.<span class="hljs-property">imported</span>) &amp;&amp;
        specifier.<span class="hljs-property">node</span>?.<span class="hljs-property">imported</span>.<span class="hljs-property">name</span> === apiName
      ) &#123;
        <span class="hljs-comment">// 记录下导入后 API 的名称</span>
        state.<span class="hljs-property">compiledImports</span>[apiName] = specifier.<span class="hljs-property">node</span>.<span class="hljs-property">local</span>.<span class="hljs-property">name</span>;
      &#125;
    &#125;);
  &#125;);

  <span class="hljs-comment">// 导入 @compiled/react/runtime 中的 API</span>
  <span class="hljs-title function_">appendRuntimeImports</span>(path);

  path.<span class="hljs-title function_">remove</span>();
&#125;,</code></pre><p>这段代码记录了 <code>@compiled/react</code> 的引入情况，为下方的处理提供了便利。</p><pre><code class="hljs typescript"><span class="hljs-title class_">TaggedTemplateExpression</span>(path, state) &#123;
  <span class="hljs-keyword">if</span> (t.<span class="hljs-title function_">isIdentifier</span>(path.<span class="hljs-property">node</span>.<span class="hljs-property">tag</span>) &amp;&amp; path.<span class="hljs-property">node</span>.<span class="hljs-property">tag</span>.<span class="hljs-property">name</span> === state.<span class="hljs-property">compiledImports</span>?.<span class="hljs-property">css</span>) &#123;
    state.<span class="hljs-property">pathsToCleanup</span>.<span class="hljs-title function_">push</span>(&#123; path, <span class="hljs-attr">action</span>: <span class="hljs-string">&#x27;replace&#x27;</span> &#125;);
    <span class="hljs-keyword">return</span>;
  &#125;

  <span class="hljs-keyword">if</span> (
    t.<span class="hljs-title function_">isIdentifier</span>(path.<span class="hljs-property">node</span>.<span class="hljs-property">tag</span>) &amp;&amp;
    path.<span class="hljs-property">node</span>.<span class="hljs-property">tag</span>.<span class="hljs-property">name</span> === state.<span class="hljs-property">compiledImports</span>?.<span class="hljs-property">keyframes</span>
  ) &#123;
    state.<span class="hljs-property">pathsToCleanup</span>.<span class="hljs-title function_">push</span>(&#123; path, <span class="hljs-attr">action</span>: <span class="hljs-string">&#x27;replace&#x27;</span> &#125;);
    <span class="hljs-keyword">return</span>;
  &#125;

  <span class="hljs-keyword">if</span> (!state.<span class="hljs-property">compiledImports</span>?.<span class="hljs-property">styled</span>) &#123;
    <span class="hljs-keyword">return</span>;
  &#125;

  <span class="hljs-comment">// 处理 styled component</span>
  <span class="hljs-title function_">visitStyledPath</span>(path, &#123; <span class="hljs-attr">context</span>: <span class="hljs-string">&#x27;root&#x27;</span>, state, <span class="hljs-attr">parentPath</span>: path &#125;);
&#125;,
<span class="hljs-title class_">CallExpression</span>(path, state) &#123;
  <span class="hljs-keyword">if</span> (!state.<span class="hljs-property">compiledImports</span>) &#123;
    <span class="hljs-keyword">return</span>;
  &#125;

  <span class="hljs-keyword">if</span> (
    t.<span class="hljs-title function_">isIdentifier</span>(path.<span class="hljs-property">node</span>.<span class="hljs-property">callee</span>) &amp;&amp;
    (path.<span class="hljs-property">node</span>.<span class="hljs-property">callee</span>.<span class="hljs-property">name</span> === state.<span class="hljs-property">compiledImports</span>?.<span class="hljs-property">css</span> ||
      path.<span class="hljs-property">node</span>.<span class="hljs-property">callee</span>.<span class="hljs-property">name</span> === state.<span class="hljs-property">compiledImports</span>?.<span class="hljs-property">keyframes</span>)
  ) &#123;
    state.<span class="hljs-property">pathsToCleanup</span>.<span class="hljs-title function_">push</span>(&#123; path, <span class="hljs-attr">action</span>: <span class="hljs-string">&#x27;replace&#x27;</span> &#125;);
    <span class="hljs-keyword">return</span>;
  &#125;

  <span class="hljs-comment">// 处理 styled component</span>
  <span class="hljs-title function_">visitStyledPath</span>(path, &#123; <span class="hljs-attr">context</span>: <span class="hljs-string">&#x27;root&#x27;</span>, state, <span class="hljs-attr">parentPath</span>: path &#125;);
&#125;,</code></pre><p>对 <code>TaggedTemplateExpression</code> 和 <code>CallExpression</code> 的处理，正好对应了文档中的两种不同调用方式：</p><pre><code class="hljs js"><span class="hljs-comment">// 模板字符串</span>
styled.<span class="hljs-property">a</span><span class="hljs-string">`</span>
<span class="hljs-string">  color: blue;</span>
<span class="hljs-string">`</span>;

<span class="hljs-comment">// 函数调用</span>
styled.<span class="hljs-title function_">a</span>(&#123;
  <span class="hljs-attr">color</span>: <span class="hljs-string">&#x27;blue&#x27;</span>,
&#125;);</code></pre><p>跟随着 <code>visitStyledPath</code> 函数的定义，可以找到 <a href="https://github.com/atlassian-labs/compiled/blob/ba66b35b82be513bf206d46c4adbdd7aefa3f7f1/packages/babel-plugin/src/styled/index.tsx" rel="external nofollow noreferrer"><code>packages/babel-plugin/src/styled/index.tsx</code></a> 文件。</p><pre><code class="hljs typescript"><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> visitStyledPath = (
  <span class="hljs-attr">path</span>: <span class="hljs-title class_">NodePath</span>&lt;t.<span class="hljs-property">TaggedTemplateExpression</span>&gt; | <span class="hljs-title class_">NodePath</span>&lt;t.<span class="hljs-property">CallExpression</span>&gt;,
  <span class="hljs-attr">meta</span>: <span class="hljs-title class_">Metadata</span>
): <span class="hljs-function"><span class="hljs-params">void</span> =&gt;</span> &#123;
  <span class="hljs-comment">// 判断是否是支持的操作</span>
  <span class="hljs-keyword">if</span> (
    t.<span class="hljs-title function_">isTaggedTemplateExpression</span>(path.<span class="hljs-property">node</span>) &amp;&amp;
    <span class="hljs-title function_">hasInValidExpression</span>(path.<span class="hljs-property">node</span>)
  ) &#123;
    <span class="hljs-keyword">throw</span> <span class="hljs-title function_">buildCodeFrameError</span>(
      <span class="hljs-string">`A logical expression contains an invalid CSS declaration. </span>
<span class="hljs-string">      Compiled doesn&#x27;t support CSS properties that are defined with a conditional rule that doesn&#x27;t specify a default value.</span>
<span class="hljs-string">      Eg. font-weight: \$&#123;(props) =&gt; (props.isPrimary &amp;&amp; props.isMaybe) &amp;&amp; &#x27;bold&#x27;&#125;; is invalid.</span>
<span class="hljs-string">      Use \$&#123;(props) =&gt; props.isPrimary &amp;&amp; props.isMaybe &amp;&amp; (&#123; &#x27;font-weight&#x27;: &#x27;bold&#x27; &#125;)&#125;; instead`</span>,
      path.<span class="hljs-property">node</span>,
      meta.<span class="hljs-property">parentPath</span>
    );
  &#125;

  <span class="hljs-comment">// 提取样式信息</span>
  <span class="hljs-keyword">const</span> styledData = <span class="hljs-title function_">extractStyledDataFromNode</span>(path.<span class="hljs-property">node</span>, meta);
  <span class="hljs-keyword">if</span> (!styledData) &#123;
    <span class="hljs-comment">// 没有样式信息</span>
    <span class="hljs-keyword">return</span>;
  &#125;

  <span class="hljs-comment">// 生成 CSS</span>
  <span class="hljs-keyword">const</span> cssOutput = <span class="hljs-title function_">buildCss</span>(styledData.<span class="hljs-property">cssNode</span>, meta);

  <span class="hljs-comment">// 构建并替换节点</span>
  path.<span class="hljs-title function_">replaceWith</span>(<span class="hljs-title function_">buildStyledComponent</span>(styledData.<span class="hljs-property">tag</span>, cssOutput, meta));

  <span class="hljs-keyword">const</span> parentVariableDeclaration = path.<span class="hljs-title function_">findParent</span>(<span class="hljs-function">(<span class="hljs-params">x</span>) =&gt;</span>
    x.<span class="hljs-title function_">isVariableDeclaration</span>()
  );
  <span class="hljs-keyword">if</span> (
    parentVariableDeclaration &amp;&amp;
    t.<span class="hljs-title function_">isVariableDeclaration</span>(parentVariableDeclaration.<span class="hljs-property">node</span>)
  ) &#123;
    <span class="hljs-keyword">const</span> variableDeclarator = parentVariableDeclaration.<span class="hljs-property">node</span>.<span class="hljs-property">declarations</span>[<span class="hljs-number">0</span>];
    <span class="hljs-keyword">if</span> (t.<span class="hljs-title function_">isIdentifier</span>(variableDeclarator.<span class="hljs-property">id</span>)) &#123;
      <span class="hljs-keyword">const</span> variableName = variableDeclarator.<span class="hljs-property">id</span>.<span class="hljs-property">name</span>;
      parentVariableDeclaration.<span class="hljs-title function_">insertAfter</span>(<span class="hljs-title function_">buildDisplayName</span>(variableName));
    &#125;
  &#125;
&#125;;</code></pre><p>再来看提取样式信息的函数 <code>extractStyledDataFromNode</code>，这个函数根据不同情况使用不同的方法提取样式信息：</p><pre><code class="hljs typescript"><span class="hljs-keyword">const</span> <span class="hljs-title function_">extractStyledDataFromNode</span> = (<span class="hljs-params"></span>
<span class="hljs-params">  node: t.TaggedTemplateExpression | t.CallExpression,</span>
<span class="hljs-params">  meta: Metadata</span>
<span class="hljs-params"></span>) =&gt; &#123;
  <span class="hljs-comment">// 使用模板字符串</span>
  <span class="hljs-keyword">if</span> (t.<span class="hljs-title function_">isTaggedTemplateExpression</span>(node)) &#123;
    <span class="hljs-keyword">return</span> <span class="hljs-title function_">extractStyledDataFromTemplateLiteral</span>(node, meta);
  &#125;

  <span class="hljs-comment">// 使用函数调用</span>
  <span class="hljs-keyword">if</span> (t.<span class="hljs-title function_">isCallExpression</span>(node)) &#123;
    <span class="hljs-keyword">return</span> <span class="hljs-title function_">extractStyledDataFromObjectLiteral</span>(node, meta);
  &#125;

  <span class="hljs-comment">// 提取不到信息</span>
  <span class="hljs-keyword">return</span> <span class="hljs-literal">undefined</span>;
&#125;;</code></pre><p>构建新节点的函数被定义在 <a href="https://github.com/atlassian-labs/compiled/blob/ba66b35b82be513bf206d46c4adbdd7aefa3f7f1/packages/babel-plugin/src/utils/ast-builders.tsx#L455-L496" rel="external nofollow noreferrer"><code>packages/babel-plugin/src/utils/ast-builders.tsx</code></a> 文件中：</p><pre><code class="hljs typescript"><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> buildStyledComponent = (
  <span class="hljs-attr">tag</span>: <span class="hljs-title class_">Tag</span>,
  <span class="hljs-attr">cssOutput</span>: <span class="hljs-title class_">CSSOutput</span>,
  <span class="hljs-attr">meta</span>: <span class="hljs-title class_">Metadata</span>
): t.<span class="hljs-property">Node</span> =&gt; &#123;
  <span class="hljs-keyword">const</span> <span class="hljs-attr">unconditionalCss</span>: <span class="hljs-built_in">string</span>[] = [];
  <span class="hljs-keyword">const</span> <span class="hljs-attr">logicalCss</span>: <span class="hljs-title class_">CssItem</span>[] = [];

  cssOutput.<span class="hljs-property">css</span>.<span class="hljs-title function_">forEach</span>(<span class="hljs-function">(<span class="hljs-params">item</span>) =&gt;</span> &#123;
    <span class="hljs-keyword">if</span> (item.<span class="hljs-property">type</span> === <span class="hljs-string">&#x27;logical&#x27;</span>) &#123;
      logicalCss.<span class="hljs-title function_">push</span>(item);
    &#125; <span class="hljs-keyword">else</span> &#123;
      unconditionalCss.<span class="hljs-title function_">push</span>(<span class="hljs-title function_">getItemCss</span>(item));
    &#125;
  &#125;);

  <span class="hljs-comment">// 去重，只保留最后一个</span>
  <span class="hljs-keyword">const</span> uniqueUnconditionalCssOutput = <span class="hljs-title function_">transformCss</span>(unconditionalCss.<span class="hljs-title function_">join</span>(<span class="hljs-string">&#x27;&#x27;</span>));

  <span class="hljs-keyword">const</span> logicalCssOutput = <span class="hljs-title function_">transformItemCss</span>(&#123;
    <span class="hljs-attr">css</span>: logicalCss,
    <span class="hljs-attr">variables</span>: cssOutput.<span class="hljs-property">variables</span>,
  &#125;);

  <span class="hljs-keyword">const</span> sheets = [
    ...uniqueUnconditionalCssOutput.<span class="hljs-property">sheets</span>,
    ...logicalCssOutput.<span class="hljs-property">sheets</span>,
  ];

  <span class="hljs-keyword">const</span> classNames = [
    ...[t.<span class="hljs-title function_">stringLiteral</span>(uniqueUnconditionalCssOutput.<span class="hljs-property">classNames</span>.<span class="hljs-title function_">join</span>(<span class="hljs-string">&#x27; &#x27;</span>))],
    ...logicalCssOutput.<span class="hljs-property">classNames</span>,
  ];

  <span class="hljs-comment">// 返回构建好的节点</span>
  <span class="hljs-keyword">return</span> <span class="hljs-title function_">styledTemplate</span>(
    &#123;
      classNames,
      tag,
      sheets,
      <span class="hljs-attr">variables</span>: cssOutput.<span class="hljs-property">variables</span>,
    &#125;,
    meta
  );
&#125;;</code></pre><p>至于构建节点的操作，则是较为简单的字符串拼接：</p><pre><code class="hljs typescript"><span class="hljs-keyword">const</span> styledTemplate = (<span class="hljs-attr">opts</span>: <span class="hljs-title class_">StyledTemplateOpts</span>, <span class="hljs-attr">meta</span>: <span class="hljs-title class_">Metadata</span>): t.<span class="hljs-property">Node</span> =&gt; &#123;
  <span class="hljs-keyword">const</span> nonceAttribute = meta.<span class="hljs-property">state</span>.<span class="hljs-property">opts</span>.<span class="hljs-property">nonce</span>
    ? <span class="hljs-string">`nonce=&#123;<span class="hljs-subst">$&#123;meta.state.opts.nonce&#125;</span>&#125;`</span>
    : <span class="hljs-string">&#x27;&#x27;</span>;
  <span class="hljs-keyword">const</span> <span class="hljs-attr">propsToDestructure</span>: <span class="hljs-built_in">string</span>[] = [];

  <span class="hljs-comment">// 提取样式</span>
  <span class="hljs-keyword">const</span> styleProp = opts.<span class="hljs-property">variables</span>.<span class="hljs-property">length</span>
    ? <span class="hljs-title function_">styledStyleProp</span>(opts.<span class="hljs-property">variables</span>, <span class="hljs-function">(<span class="hljs-params">node</span>) =&gt;</span> &#123;
        <span class="hljs-keyword">const</span> nestedArrowFunctionExpressionVisitor = &#123;
          <span class="hljs-attr">noScope</span>: <span class="hljs-literal">true</span>,
          <span class="hljs-title class_">MemberExpression</span>(<span class="hljs-attr">path</span>: <span class="hljs-title class_">NodePath</span>&lt;t.<span class="hljs-property">MemberExpression</span>&gt;) &#123;
            <span class="hljs-keyword">const</span> propsToDestructureFromMemberExpression =
              <span class="hljs-title function_">handleMemberExpressionInStyledInterpolation</span>(path);

            propsToDestructure.<span class="hljs-title function_">push</span>(...propsToDestructureFromMemberExpression);
          &#125;,
          <span class="hljs-title class_">Identifier</span>(<span class="hljs-attr">path</span>: <span class="hljs-title class_">NodePath</span>&lt;t.<span class="hljs-property">Identifier</span>&gt;) &#123;
            <span class="hljs-keyword">const</span> propsToDestructureFromIdentifier =
              <span class="hljs-title function_">handleDestructuringInStyledInterpolation</span>(path);

            propsToDestructure.<span class="hljs-title function_">push</span>(...propsToDestructureFromIdentifier);
          &#125;,
        &#125;;

        <span class="hljs-keyword">if</span> (t.<span class="hljs-title function_">isArrowFunctionExpression</span>(node)) &#123;
          <span class="hljs-keyword">return</span> <span class="hljs-title function_">traverseStyledArrowFunctionExpression</span>(
            node,
            nestedArrowFunctionExpressionVisitor
          );
        &#125;

        <span class="hljs-keyword">if</span> (t.<span class="hljs-title function_">isBinaryExpression</span>(node)) &#123;
          <span class="hljs-keyword">return</span> <span class="hljs-title function_">traverseStyledBinaryExpression</span>(
            node,
            nestedArrowFunctionExpressionVisitor
          );
        &#125;

        <span class="hljs-keyword">return</span> node;
      &#125;)
    : t.<span class="hljs-title function_">identifier</span>(<span class="hljs-string">&#x27;style&#x27;</span>);

  <span class="hljs-keyword">let</span> unconditionalClassNames = <span class="hljs-string">&#x27;&#x27;</span>,
    logicalClassNames = <span class="hljs-string">&#x27;&#x27;</span>;

  opts.<span class="hljs-property">classNames</span>.<span class="hljs-title function_">forEach</span>(<span class="hljs-function">(<span class="hljs-params">item</span>) =&gt;</span> &#123;
    <span class="hljs-keyword">if</span> (t.<span class="hljs-title function_">isStringLiteral</span>(item)) &#123;
      unconditionalClassNames += <span class="hljs-string">`<span class="hljs-subst">$&#123;item.value&#125;</span> `</span>;
    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (t.<span class="hljs-title function_">isLogicalExpression</span>(item)) &#123;
      logicalClassNames += <span class="hljs-string">`<span class="hljs-subst">$&#123;generate(item).code&#125;</span>, `</span>;
    &#125;
  &#125;);

  <span class="hljs-comment">// classNames 为生成好的类名</span>
  <span class="hljs-keyword">const</span> classNames = <span class="hljs-string">`&quot;<span class="hljs-subst">$&#123;unconditionalClassNames.trim()&#125;</span>&quot;, <span class="hljs-subst">$&#123;logicalClassNames&#125;</span>`</span>;

  <span class="hljs-comment">// 此处的 &lt;CC /&gt;, &lt;CS /&gt; 是上文中处理 import 时从 @compiled/react/runtime 中导入的组件</span>
  <span class="hljs-keyword">return</span> <span class="hljs-title function_">template</span>(
    <span class="hljs-string">`</span>
<span class="hljs-string">  forwardRef((&#123;</span>
<span class="hljs-string">    as: C = <span class="hljs-subst">$&#123;buildComponentTag(opts.tag)&#125;</span>,</span>
<span class="hljs-string">    style,</span>
<span class="hljs-string">    <span class="hljs-subst">$&#123;unique(propsToDestructure)</span></span>
<span class="hljs-subst"><span class="hljs-string">      .map((prop) =&gt; prop + <span class="hljs-string">&#x27;,&#x27;</span>)</span></span>
<span class="hljs-subst"><span class="hljs-string">      .join(<span class="hljs-string">&#x27;&#x27;</span>)&#125;</span></span>
<span class="hljs-string">    ...<span class="hljs-subst">$&#123;PROPS_IDENTIFIER_NAME&#125;</span></span>
<span class="hljs-string">  &#125;, ref) =&gt; (</span>
<span class="hljs-string">    &lt;CC&gt;</span>
<span class="hljs-string">      &lt;CS <span class="hljs-subst">$&#123;nonceAttribute&#125;</span>&gt;&#123;%%cssNode%%&#125;&lt;/CS&gt;</span>
<span class="hljs-string">      &lt;C</span>
<span class="hljs-string">        &#123;...<span class="hljs-subst">$&#123;PROPS_IDENTIFIER_NAME&#125;</span>&#125;</span>
<span class="hljs-string">        style=&#123;%%styleProp%%&#125;</span>
<span class="hljs-string">        ref=&#123;ref&#125;</span>
<span class="hljs-string">        className=&#123;ax([<span class="hljs-subst">$&#123;classNames&#125;</span> <span class="hljs-subst">$&#123;PROPS_IDENTIFIER_NAME&#125;</span>.className])&#125;</span>
<span class="hljs-string">      /&gt;</span>
<span class="hljs-string">    &lt;/CC&gt;</span>
<span class="hljs-string">  ));</span>
<span class="hljs-string">`</span>,
    &#123;
      <span class="hljs-attr">plugins</span>: [<span class="hljs-string">&#x27;jsx&#x27;</span>],
    &#125;
  )(&#123;
    styleProp,
    <span class="hljs-attr">cssNode</span>: t.<span class="hljs-title function_">arrayExpression</span>(
      <span class="hljs-title function_">unique</span>(opts.<span class="hljs-property">sheets</span>).<span class="hljs-title function_">map</span>(<span class="hljs-function">(<span class="hljs-params">sheet</span>) =&gt;</span> <span class="hljs-title function_">hoistSheet</span>(sheet, meta))
    ),
  &#125;) <span class="hljs-keyword">as</span> t.<span class="hljs-property">Node</span>;
&#125;;</code></pre><p>这样兜兜转转一圈下来，就将使用了 <code>styled</code> 方法生成的组件的样式抽离出来，变成了一个 compiled 的 Atomic CSS-in-JS 组件。</p><h5 id="css-prop"><code>css</code> Prop</h5><p>compiled 首先 <a href="https://github.com/atlassian-labs/compiled/blob/8470616bde0cd47b2b41d63dedb0efa7bf6f299f/packages/react/src/jsx/jsx-local-namespace.ts" rel="external nofollow noreferrer">增加了 <code>css</code> prop 的 TypeScript 定义</a>，然后和 styled component 一样在 babel transform 的时候对这个 prop 进行特殊处理：</p><pre><code class="hljs typescript"><span class="hljs-title class_">JSXOpeningElement</span>(path, state) &#123;
  <span class="hljs-keyword">if</span> (!state.<span class="hljs-property">compiledImports</span>) &#123;
    <span class="hljs-keyword">return</span>;
  &#125;

  <span class="hljs-comment">// 处理 css prop</span>
  <span class="hljs-title function_">visitCssPropPath</span>(path, &#123; <span class="hljs-attr">context</span>: <span class="hljs-string">&#x27;root&#x27;</span>, state, <span class="hljs-attr">parentPath</span>: path &#125;);
&#125;,</code></pre><p>相比于 styled component 繁复的处理方式，<code>css</code> prop 的处理看起来简洁了许多：</p><pre><code class="hljs typescript"><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> visitCssPropPath = (
  <span class="hljs-attr">path</span>: <span class="hljs-title class_">NodePath</span>&lt;t.<span class="hljs-property">JSXOpeningElement</span>&gt;,
  <span class="hljs-attr">meta</span>: <span class="hljs-title class_">Metadata</span>
): <span class="hljs-function"><span class="hljs-params">void</span> =&gt;</span> &#123;
  <span class="hljs-keyword">let</span> cssPropIndex = -<span class="hljs-number">1</span>;
  <span class="hljs-keyword">const</span> cssProp = path.<span class="hljs-property">node</span>.<span class="hljs-property">attributes</span>.<span class="hljs-title function_">find</span>(
    (attr, index): attr is t.<span class="hljs-property">JSXAttribute</span> =&gt; &#123;
      <span class="hljs-keyword">if</span> (t.<span class="hljs-title function_">isJSXAttribute</span>(attr) &amp;&amp; attr.<span class="hljs-property">name</span>.<span class="hljs-property">name</span> === <span class="hljs-string">&#x27;css&#x27;</span>) &#123;
        cssPropIndex = index;
        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
      &#125;

      <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
    &#125;
  );

  <span class="hljs-comment">// 不存在 css prop 就不进行处理了</span>
  <span class="hljs-keyword">if</span> (!cssProp || !cssProp.<span class="hljs-property">value</span>) &#123;
    <span class="hljs-keyword">return</span>;
  &#125;

  <span class="hljs-comment">// 从 css props 中提取样式信息</span>
  <span class="hljs-keyword">const</span> cssOutput = <span class="hljs-title function_">buildCss</span>(<span class="hljs-title function_">getJsxAttributeExpression</span>(cssProp), meta);

  <span class="hljs-comment">// 删除 css prop</span>
  path.<span class="hljs-property">node</span>.<span class="hljs-property">attributes</span>.<span class="hljs-title function_">splice</span>(cssPropIndex, <span class="hljs-number">1</span>);

  <span class="hljs-comment">// 没有样式信息</span>
  <span class="hljs-keyword">if</span> (!cssOutput.<span class="hljs-property">css</span>.<span class="hljs-property">length</span>) &#123;
    <span class="hljs-keyword">return</span>;
  &#125;

  <span class="hljs-comment">// 构建并替换节点</span>
  path.<span class="hljs-property">parentPath</span>.<span class="hljs-title function_">replaceWith</span>(
    <span class="hljs-title function_">buildCompiledComponent</span>(
      path.<span class="hljs-property">parentPath</span>.<span class="hljs-property">node</span> <span class="hljs-keyword">as</span> t.<span class="hljs-property">JSXElement</span>,
      cssOutput,
      meta
    )
  );
&#125;;</code></pre><p>构建新节点的 <code>buildCompiledComponent</code> 函数被定义在 <a href="https://github.com/atlassian-labs/compiled/blob/ba66b35b82be513bf206d46c4adbdd7aefa3f7f1/packages/babel-plugin/src/utils/ast-builders.tsx#L567-L651" rel="external nofollow noreferrer"><code>packages/babel-plugin/src/utils/ast-builders.tsx</code></a> 文件中，这个函数主要完成了以下操作：</p><ol><li>合并现有的 <code>className</code>；</li><li>处理 <code>css</code> prop 中的样式；</li><li>生成 compiled 的 Atomic CSS-in-JS 组件。</li></ol><p>这样就将组件的 <code>css</code> 参数拆成了两部分 —— 静态的样式和附加到原组件的 <code>className</code> 参数值。</p><h4 id="其他">其他</h4><p>微软最近开源的 <a href="https://github.com/microsoft/griffel" rel="external nofollow noreferrer">Griffel</a> 既支持运行时模式，又支持预编译模式，同时拥有着更佳的 TypeScript 支持，不失为一个好的选择。这个库目前驱动了微软官方的 <a href="https://developer.microsoft.com/en-us/fluentui" rel="external nofollow noreferrer">Fluent UI</a>。</p><h2 id="后记">后记</h2><p>以上就是本文要介绍关于 Atomic CSS 的全部内容了。</p><p>虽然 Atomic CSS-in-JS 是 React 生态系统中新涌起的一股潮流，但在使用前一定要三思 —— 这个方案到底符不符合项目的需求，而不是盲目地「为了使用而使用」，给将来的维护工作埋雷，但如果使用它能带来显而易见的好处，那么何乐而不为呢？</p><p>笔者才疏学浅，只是在前人的基础之上做了一些微小的工作而已，文章中如有错误欢迎在评论区指正。感谢 <a href="https://skk.moe" rel="external nofollow noreferrer">Sukka</a> 大佬在本文编写过程中的指导。感谢 <a href="https://github.com/liby" rel="external nofollow noreferrer">Byran Lee</a> 指出本文中的错误。</p><h2 id="参考资料-2">参考资料</h2><ol><li><a href="https://sebastienlorber.com/atomic-css-in-js" rel="external nofollow noreferrer">Atomic CSS-in-JS</a>，Sébastien Lorber，2020 年 4 月 27 日。</li><li><a href="https://mongkii.com/blog/2021-07-26-talk-about-atomic-css" rel="external nofollow noreferrer">聊聊原子类（Atomic CSS）</a>，Mongkii，2021 年 7 月 26 日。</li><li><a href="http://acgtofe.com/posts/2014/09/valuable-theories-of-css" rel="external nofollow noreferrer">值得参考的 CSS 理论：OOCSS、SMACSS 与 BEM</a>，ACGTOFE，2014 年 9 月 30 日。</li><li><a href="https://tailwindcss.com/docs/utility-first" rel="external nofollow noreferrer">Utility-First Fundamentals</a>，Tailwind CSS。</li></ol>]]></content>
        <author>
            <name>宝硕</name>
            <uri>https://baoshuo.ren</uri>
        </author>
    </entry>
    <entry>
        <title type="html"><![CDATA[使用 GitHub Actions 自动申请与部署 SSL 证书]]></title>
        <id>/post/actions-ssl-cert/</id>
        <link href="/post/actions-ssl-cert/"/>
        <updated>2022-05-15T08:47:00.000Z</updated>
        <summary type="html"><![CDATA[对于一个有很多服务器的人来说，在不同服务器上同步 SSL 证书是一件麻烦事。笔者尝试过很多种方式，最后在 Menci 的推荐下选定了使用 GitHub Actions 来自动申请、续期 SSL 证书，并自动推送到各个服务器上。]]></summary>
        <content type="html"><![CDATA[<img src="https://s1.baoshuo.ren/2022/05/13/lj2cs5QNP3rWkeq.png" width="100%" alt="使用 GitHub Actions 自动申请与部署 SSL 证书" /><p>对于一个有很多服务器的人来说，在不同服务器上同步 SSL 证书是一件麻烦事。笔者尝试过很多种方式，最后在 <a href="https://men.ci" rel="external nofollow noreferrer">Menci</a> 的推荐下选定了使用 GitHub Actions 来自动申请、续期 SSL 证书，并自动推送到各个服务器上。</p><span id="more"></span><p>本博客的证书也是使用这种方式进行签发、部署的，可以点击浏览器地址栏上的按钮查看证书。</p><h2 id="申请证书">申请证书</h2><h3 id="前期准备">前期准备</h3><p>首先请在本地（或自己的服务器上）成功使用 <a href="https://acme.sh" rel="external nofollow noreferrer">acme.sh</a> 的 <a href="https://letsencrypt.org/docs/challenge-types/#dns-01-challenge" rel="external nofollow noreferrer">DNS-01</a> 验证方式成功申请一次证书，如果不会操作的话可以参考 <a href="https://u.sb/acme-sh-ssl/?utm_source=blog.baoshuo.ren&amp;utm_medium=actions-ssl-cert+tutorial" rel="external nofollow noreferrer">烧饼博客的教程</a> 来进行。这个过程包括：</p><ol><li>向 CA 注册 ACME 账户（如果使用 Let’s Encrypt 则会自动进行，详细步骤请参阅 <a href="https://github.com/acmesh-official/acme.sh/wiki/ZeroSSL.com-CA" rel="external nofollow noreferrer">acme.sh 的 Wiki</a>）。</li><li>通过环境变量指定 DNS 提供商的凭据，用于添加/删除 ACME DNS-01 认证所需的 TXT 记录。</li><li>确认证书申请可以成功，为后续调试排除可能的问题。</li></ol><p>第一次申请证书后，CA 的 ACME 账户凭据将被存储到 <code>~/.acme.sh/ca</code> 中，DNS 提供商的凭据将被存储到 <code>~/.acme.sh/account.conf</code> 中。将它们打包并使用 Base64 编码存储，以备在 GitHub Actions 中使用：</p><pre><code class="hljs sh"><span class="hljs-built_in">cd</span> ~/.acme.sh
tar cz ca account.conf | <span class="hljs-built_in">base64</span> -w0</code></pre><p>将输出内容添加到 GitHub 仓库的 Secrets 中。注意不要复制输出中的多余信息。</p><h3 id="自动化">自动化</h3><p>如果没有特殊需求，可以使用 <a href="https://github.com/Menci/acme" rel="external nofollow noreferrer">Menci/acme</a> 来简单地申请证书：</p><pre><code class="hljs yaml"><span class="hljs-comment"># 全局环境变量</span>
<span class="hljs-attr">env:</span>
  <span class="hljs-comment"># Checkout 到的目录</span>
  <span class="hljs-attr">CERTS_OUTPUT_BASE:</span> <span class="hljs-string">certs</span>
  <span class="hljs-comment"># 证书输出目录</span>
  <span class="hljs-attr">CERTS_OUTPUT_DIRECTORY:</span> <span class="hljs-string">example.com</span>
  <span class="hljs-comment"># 证书文件名</span>
  <span class="hljs-attr">FILE_FULLCHAIN:</span> <span class="hljs-string">fullchain.pem</span>
  <span class="hljs-comment"># 私钥文件名</span>
  <span class="hljs-attr">FILE_KEY:</span> <span class="hljs-string">privatekey.key</span>

<span class="hljs-attr">jobs:</span>
  <span class="hljs-attr">issue-ssl-certificate:</span>
    <span class="hljs-attr">name:</span> <span class="hljs-string">Issue</span> <span class="hljs-string">SSL</span> <span class="hljs-string">certificate</span>
    <span class="hljs-attr">runs-on:</span> <span class="hljs-string">ubuntu-latest</span>
    <span class="hljs-attr">steps:</span>
      <span class="hljs-bullet">-</span> <span class="hljs-attr">uses:</span> <span class="hljs-string">Menci/acme@v1</span>
        <span class="hljs-attr">with:</span>
          <span class="hljs-comment"># 指定 acme.sh 的版本</span>
          <span class="hljs-attr">version:</span> <span class="hljs-number">3.0</span><span class="hljs-number">.2</span>

          <span class="hljs-comment"># 上方保存的以 Base64 编码存储的凭据</span>
          <span class="hljs-attr">account-tar:</span> <span class="hljs-string">$&#123;&#123;</span> <span class="hljs-string">secrets.ACME_SH_ACCOUNT_TAR</span> <span class="hljs-string">&#125;&#125;</span>

          <span class="hljs-comment"># 域名列表，以空格分隔</span>
          <span class="hljs-attr">domains:</span> <span class="hljs-string">example.com</span> <span class="hljs-string">example.net</span> <span class="hljs-string">example.org</span> <span class="hljs-string">example.edu</span>
          <span class="hljs-comment"># 是否申请通配符</span>
          <span class="hljs-attr">append-wildcard:</span> <span class="hljs-literal">true</span>

          <span class="hljs-comment"># 传递给 acme.sh 的额外参数</span>
          <span class="hljs-attr">arguments:</span> <span class="hljs-string">--dns</span> <span class="hljs-string">dns_cf</span> <span class="hljs-string">--challenge-alias</span> <span class="hljs-string">example.com</span>

          <span class="hljs-comment"># 导出的证书路径</span>
          <span class="hljs-attr">output-fullchain:</span> <span class="hljs-string">$&#123;&#123;</span> <span class="hljs-string">env.CERTS_OUTPUT_BASE</span> <span class="hljs-string">&#125;&#125;/$&#123;&#123;</span> <span class="hljs-string">env.CERTS_OUTPUT_DIRECTORY</span> <span class="hljs-string">&#125;&#125;/$&#123;&#123;</span> <span class="hljs-string">env.FILE_FULLCHAIN</span> <span class="hljs-string">&#125;&#125;</span>
          <span class="hljs-attr">output-key:</span> <span class="hljs-string">$&#123;&#123;</span> <span class="hljs-string">env.CERTS_OUTPUT_BASE</span> <span class="hljs-string">&#125;&#125;/$&#123;&#123;</span> <span class="hljs-string">env.CERTS_OUTPUT_DIRECTORY</span> <span class="hljs-string">&#125;&#125;/$&#123;&#123;</span> <span class="hljs-string">env.FILE_KEY</span> <span class="hljs-string">&#125;&#125;</span></code></pre><p>如果需要高度自定义 <a href="http://acme.sh" rel="external nofollow noreferrer">acme.sh</a> 的参数，比如为不同的域名设置不同的 DNS 提供商，可以使用下面的方式手动编写命令来执行：</p><pre><code class="hljs yaml"><span class="hljs-comment"># 全局环境变量</span>
<span class="hljs-attr">env:</span>
  <span class="hljs-comment"># Checkout 到的目录</span>
  <span class="hljs-attr">CERTS_OUTPUT_BASE:</span> <span class="hljs-string">certs</span>
  <span class="hljs-comment"># 证书输出目录</span>
  <span class="hljs-attr">CERTS_OUTPUT_DIRECTORY:</span> <span class="hljs-string">example.com</span>
  <span class="hljs-comment"># 证书文件名</span>
  <span class="hljs-attr">FILE_FULLCHAIN:</span> <span class="hljs-string">fullchain.pem</span>
  <span class="hljs-comment"># 私钥文件名</span>
  <span class="hljs-attr">FILE_KEY:</span> <span class="hljs-string">privatekey.key</span>

<span class="hljs-attr">jobs:</span>
  <span class="hljs-attr">issue-ssl-certificate:</span>
    <span class="hljs-attr">name:</span> <span class="hljs-string">Issue</span> <span class="hljs-string">SSL</span> <span class="hljs-string">certificate</span>
    <span class="hljs-attr">runs-on:</span> <span class="hljs-string">ubuntu-latest</span>
    <span class="hljs-attr">steps:</span>
      <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">Checkout</span>
        <span class="hljs-attr">uses:</span> <span class="hljs-string">actions/checkout@v2</span>
        <span class="hljs-attr">with:</span>
          <span class="hljs-attr">ref:</span> <span class="hljs-string">master</span>

      <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">Checkout</span> <span class="hljs-string">output</span> <span class="hljs-string">branch</span>
        <span class="hljs-attr">uses:</span> <span class="hljs-string">actions/checkout@v2</span>
        <span class="hljs-attr">with:</span>
          <span class="hljs-attr">ref:</span> <span class="hljs-string">certs</span>
          <span class="hljs-attr">path:</span> <span class="hljs-string">$&#123;&#123;</span> <span class="hljs-string">env.CERTS_OUTPUT_BASE</span> <span class="hljs-string">&#125;&#125;</span>

      <span class="hljs-comment"># 安装 acme.sh</span>
      <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">Install</span> <span class="hljs-string">acme.sh</span>
        <span class="hljs-attr">shell:</span> <span class="hljs-string">bash</span>
        <span class="hljs-attr">run:</span> <span class="hljs-string">curl</span> <span class="hljs-string">-s</span> <span class="hljs-string">https://get.acme.sh</span> <span class="hljs-string">|</span> <span class="hljs-string">sh</span>

      <span class="hljs-comment"># 解压 acme.sh 配置信息</span>
      <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">Extract</span> <span class="hljs-string">account</span> <span class="hljs-string">files</span> <span class="hljs-string">for</span> <span class="hljs-string">acme.sh</span>
        <span class="hljs-attr">shell:</span> <span class="hljs-string">bash</span>
        <span class="hljs-attr">run:</span> <span class="hljs-string">|</span>
<span class="hljs-string">          echo &quot;$ACME_SH_ACCOUNT_TAR&quot; | base64 -d | tar -C ~/.acme.sh -xz</span>
<span class="hljs-string"></span>        <span class="hljs-attr">env:</span>
          <span class="hljs-comment"># Base64 编码的 acme.sh 配置信息</span>
          <span class="hljs-attr">ACME_SH_ACCOUNT_TAR:</span> <span class="hljs-string">$&#123;&#123;</span> <span class="hljs-string">secrets.ACME_SH_ACCOUNT_TAR</span> <span class="hljs-string">&#125;&#125;</span>

      <span class="hljs-comment"># 申请证书</span>
      <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">Issue</span> <span class="hljs-string">SSL</span> <span class="hljs-string">certificates</span>
        <span class="hljs-attr">shell:</span> <span class="hljs-string">bash</span>
        <span class="hljs-attr">run:</span> <span class="hljs-string">|</span>
<span class="hljs-string">          ~/.acme.sh/acme.sh --issue        \</span>
<span class="hljs-string">            -d &quot;example.com&quot;   --dns dns_cf \</span>
<span class="hljs-string">            -d &quot;*.example.com&quot; --dns dns_cf \</span>
<span class="hljs-string">            -d &quot;example.net&quot;   --dns dns_dp \</span>
<span class="hljs-string">            -d &quot;*.example.net&quot; --dns dns_dp \</span>
<span class="hljs-string">            --server letsencrypt</span>
<span class="hljs-string"></span>
      <span class="hljs-comment"># 导出证书</span>
      <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">Copy</span> <span class="hljs-string">certificate</span> <span class="hljs-string">to</span> <span class="hljs-string">output</span> <span class="hljs-string">paths</span>
        <span class="hljs-attr">shell:</span> <span class="hljs-string">bash</span>
        <span class="hljs-attr">run:</span> <span class="hljs-string">|</span>
<span class="hljs-string">          ACME_SH_TEMP_DIR=&quot;$(mktemp -d)&quot;</span>
<span class="hljs-string">          ACME_SH_TEMP_FILE_FULLCHAIN=&quot;$ACME_SH_TEMP_DIR/fullchain.pem&quot;</span>
<span class="hljs-string">          ACME_SH_TEMP_FILE_KEY=&quot;$ACME_SH_TEMP_DIR/key.pem&quot;</span>
<span class="hljs-string"></span>
          <span class="hljs-string">~/.acme.sh/acme.sh</span> <span class="hljs-string">--install-cert</span> <span class="hljs-string">-d</span> <span class="hljs-string">&quot;$ACME_SH_FIRST_DOMAIN&quot;</span> <span class="hljs-string">--fullchain-file</span> <span class="hljs-string">&quot;$ACME_SH_TEMP_FILE_FULLCHAIN&quot;</span> <span class="hljs-string">--key-file</span> <span class="hljs-string">&quot;$ACME_SH_TEMP_FILE_KEY&quot;</span>

          [[ <span class="hljs-string">-z</span> <span class="hljs-string">&quot;$ACME_SH_OUTPUT_FULLCHAIN&quot;</span> ]] <span class="hljs-string">||</span> <span class="hljs-string">(mkdir</span> <span class="hljs-string">-p</span> <span class="hljs-string">&quot;$(dirname &quot;</span><span class="hljs-string">$ACME_SH_OUTPUT_FULLCHAIN&quot;)&quot;</span> <span class="hljs-string">&amp;&amp;</span> <span class="hljs-string">cp</span> <span class="hljs-string">&quot;$ACME_SH_TEMP_FILE_FULLCHAIN&quot;</span> <span class="hljs-string">&quot;$ACME_SH_OUTPUT_FULLCHAIN&quot;</span><span class="hljs-string">)</span>
          [[ <span class="hljs-string">-z</span> <span class="hljs-string">&quot;$ACME_SH_OUTPUT_KEY&quot;</span> ]] <span class="hljs-string">||</span> <span class="hljs-string">(mkdir</span> <span class="hljs-string">-p</span> <span class="hljs-string">&quot;$(dirname &quot;</span><span class="hljs-string">$ACME_SH_OUTPUT_KEY&quot;)&quot;</span> <span class="hljs-string">&amp;&amp;</span> <span class="hljs-string">cp</span> <span class="hljs-string">&quot;$ACME_SH_TEMP_FILE_KEY&quot;</span> <span class="hljs-string">&quot;$ACME_SH_OUTPUT_KEY&quot;</span><span class="hljs-string">)</span>

          <span class="hljs-string">rm</span> <span class="hljs-string">-rf</span> <span class="hljs-string">&quot;$ACME_SH_TEMP_DIR&quot;</span>
        <span class="hljs-attr">env:</span>
          <span class="hljs-comment"># 修改此处的 example.com 为申请时填写的第一个域名</span>
          <span class="hljs-attr">ACME_SH_FIRST_DOMAIN:</span> <span class="hljs-string">example.com</span>
          <span class="hljs-attr">ACME_SH_OUTPUT_FULLCHAIN:</span> <span class="hljs-string">$&#123;&#123;</span> <span class="hljs-string">env.CERTS_OUTPUT_BASE</span> <span class="hljs-string">&#125;&#125;/$&#123;&#123;</span> <span class="hljs-string">env.CERTS_OUTPUT_DIRECTORY</span> <span class="hljs-string">&#125;&#125;/$&#123;&#123;</span> <span class="hljs-string">env.FILE_FULLCHAIN</span> <span class="hljs-string">&#125;&#125;</span>
          <span class="hljs-attr">ACME_SH_OUTPUT_KEY:</span> <span class="hljs-string">$&#123;&#123;</span> <span class="hljs-string">env.CERTS_OUTPUT_BASE</span> <span class="hljs-string">&#125;&#125;/$&#123;&#123;</span> <span class="hljs-string">env.CERTS_OUTPUT_DIRECTORY</span> <span class="hljs-string">&#125;&#125;/$&#123;&#123;</span> <span class="hljs-string">env.FILE_KEY</span> <span class="hljs-string">&#125;&#125;</span></code></pre><h3 id="上传证书至仓库">上传证书至仓库</h3><pre><code class="hljs yaml"><span class="hljs-comment"># 上传证书</span>
<span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">Push</span> <span class="hljs-string">to</span> <span class="hljs-string">GitHub</span>
  <span class="hljs-attr">run:</span> <span class="hljs-string">|</span>
<span class="hljs-string">    git config --global user.name &quot;BaoshuoBot&quot;</span>
<span class="hljs-string">    git config --global user.email &quot;79077260+BaoshuoBot@users.noreply.github.com&quot;</span>
<span class="hljs-string"></span>
    <span class="hljs-string">cd</span> <span class="hljs-string">&quot;$CERTS_DIRECTORY&quot;</span>

    <span class="hljs-string">git</span> <span class="hljs-string">add</span> <span class="hljs-string">&quot;$FILE_FULLCHAIN&quot;</span> <span class="hljs-string">&quot;$FILE_KEY&quot;</span>
    <span class="hljs-string">git</span> <span class="hljs-string">commit</span> <span class="hljs-string">-m</span> <span class="hljs-string">&quot;Upload certificates on $(date &#x27;+%Y-%m-%d %H:%M:%S&#x27;)&quot;</span>
    <span class="hljs-string">git</span> <span class="hljs-string">push</span>
  <span class="hljs-attr">env:</span>
    <span class="hljs-attr">TZ:</span> <span class="hljs-string">Asia/Shanghai</span>
    <span class="hljs-attr">CERTS_DIRECTORY:</span> <span class="hljs-string">$&#123;&#123;</span> <span class="hljs-string">env.CERTS_OUTPUT_BASE</span> <span class="hljs-string">&#125;&#125;/$&#123;&#123;</span> <span class="hljs-string">env.CERTS_OUTPUT_DIRECTORY</span> <span class="hljs-string">&#125;&#125;</span></code></pre><h2 id="部署证书">部署证书</h2><p>在申请证书的 Job 执行完成后，可以执行一系列其他的 Job 来将证书部署到各个服务器或云服务。</p><h3 id="服务器">服务器</h3><p>可以使用 <a href="https://github.com/easingthemes/ssh-deploy" rel="external nofollow noreferrer"><code>easingthemes/ssh-deploy</code></a> 来使用 rsync 将证书同步到服务器上。同步完成后再使用 <a href="https://github.com/appleboy/ssh-action" rel="external nofollow noreferrer"><code>appleboy/ssh-action</code></a> 远程执行命令重载 Nginx / Apache。</p><pre><code class="hljs yaml"><span class="hljs-comment"># 部署到服务器</span>
<span class="hljs-attr">deploy-to-server:</span>
  <span class="hljs-attr">name:</span> <span class="hljs-string">Deploy</span> <span class="hljs-string">Certificate</span> <span class="hljs-string">to</span> <span class="hljs-string">Server</span>
  <span class="hljs-attr">runs-on:</span> <span class="hljs-string">ubuntu-latest</span>
  <span class="hljs-attr">needs:</span> <span class="hljs-string">issue-ssl-certificate</span>

  <span class="hljs-attr">strategy:</span>
    <span class="hljs-attr">matrix:</span>
      <span class="hljs-attr">host:</span>
        <span class="hljs-bullet">-</span> <span class="hljs-number">174.136</span><span class="hljs-number">.239</span><span class="hljs-number">.1</span> <span class="hljs-comment"># Server 1</span>
        <span class="hljs-bullet">-</span> <span class="hljs-number">174.136</span><span class="hljs-number">.239</span><span class="hljs-number">.2</span> <span class="hljs-comment"># Server 2</span>
        <span class="hljs-comment"># ...</span>
        <span class="hljs-bullet">-</span> <span class="hljs-number">174.136</span><span class="hljs-number">.239</span><span class="hljs-number">.254</span> <span class="hljs-comment"># Server N</span>

  <span class="hljs-attr">steps:</span>
    <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">Checkout</span>
      <span class="hljs-attr">uses:</span> <span class="hljs-string">actions/checkout@v2</span>
      <span class="hljs-attr">with:</span>
        <span class="hljs-attr">ref:</span> <span class="hljs-string">certs</span>

    <span class="hljs-comment"># 上传证书</span>
    <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">Upload</span> <span class="hljs-string">certificate</span> <span class="hljs-string">to</span> <span class="hljs-string">server</span>
      <span class="hljs-attr">uses:</span> <span class="hljs-string">easingthemes/ssh-deploy@v2.1.5</span>
      <span class="hljs-attr">env:</span>
        <span class="hljs-attr">SSH_PRIVATE_KEY:</span> <span class="hljs-string">$&#123;&#123;</span> <span class="hljs-string">secrets.SSH_PRIVATE_KEY</span> <span class="hljs-string">&#125;&#125;</span>
        <span class="hljs-attr">ARGS:</span> <span class="hljs-string">&#x27;-avz --delete&#x27;</span>
        <span class="hljs-attr">REMOTE_HOST:</span> <span class="hljs-string">$&#123;&#123;</span> <span class="hljs-string">matrix.host</span> <span class="hljs-string">&#125;&#125;</span>
        <span class="hljs-attr">REMOTE_USER:</span> <span class="hljs-string">$&#123;&#123;</span> <span class="hljs-string">secrets.REMOTE_USER</span> <span class="hljs-string">&#125;&#125;</span>
        <span class="hljs-attr">SOURCE:</span> <span class="hljs-string">$&#123;&#123;</span> <span class="hljs-string">env.CERTS_OUTPUT_DIRECTORY</span> <span class="hljs-string">&#125;&#125;/</span>
        <span class="hljs-attr">TARGET:</span> <span class="hljs-string">/path/to/ssl/certs/$&#123;&#123;</span> <span class="hljs-string">env.CERTS_OUTPUT_DIRECTORY</span> <span class="hljs-string">&#125;&#125;/</span>

    <span class="hljs-comment"># 重载 Nginx</span>
    <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">Force-reload</span> <span class="hljs-string">nginx</span>
      <span class="hljs-attr">uses:</span> <span class="hljs-string">appleboy/ssh-action@v0.1.4</span>
      <span class="hljs-attr">with:</span>
        <span class="hljs-attr">host:</span> <span class="hljs-string">$&#123;&#123;</span> <span class="hljs-string">matrix.host</span> <span class="hljs-string">&#125;&#125;</span>
        <span class="hljs-attr">username:</span> <span class="hljs-string">$&#123;&#123;</span> <span class="hljs-string">secrets.REMOTE_USER</span> <span class="hljs-string">&#125;&#125;</span>
        <span class="hljs-attr">key:</span> <span class="hljs-string">$&#123;&#123;</span> <span class="hljs-string">secrets.SSH_PRIVATE_KEY</span> <span class="hljs-string">&#125;&#125;</span>
        <span class="hljs-attr">script:</span> <span class="hljs-string">|</span>
          <span class="hljs-string">sudo</span> <span class="hljs-string">/opt/hooks/reload-nginx.sh</span></code></pre><p>需要注意的是，重载 Nginx / Apache 的命令需要 root 权限才能执行，可以采用只允许部署用户以 root 权限执行重载脚本的方式来避免出现安全问题。</p><p>在 <code>/opt/hooks</code> 目录下新建一个文件 <code>reload-nginx.sh</code>，内容如下：</p><pre><code class="hljs bash"><span class="hljs-meta">#!/bin/bash</span>
sudo systemctl force-reload nginx</code></pre><p>然后新建一个名为 <code>actions-cert</code> 的用户，然后在 <code>/etc/sudoers</code> 文件中添加以下内容：</p><pre><code class="hljs arcade">actions-cert <span class="hljs-built_in">ALL</span>=(<span class="hljs-built_in">ALL</span>) NOPASSWD: <span class="hljs-regexp">/opt/</span>hooks/reload-nginx.sh</code></pre><p>这个配置可以使 <code>actions-cert</code> 用户免密码以 root 用户的权限执行 <code>/opt/hooks/reload-nginx.sh</code>。</p><p>最后使用 <code>chmod 755 /opt/hooks/reload-nginx.sh</code> 命令将 <code>reload-nginx.sh</code> 文件设置为可执行，同时禁止非所有者对其进行写入操作。</p><p>如果服务器位于 NAT 后，或者禁止了 SSH 连接，还有两个方法可以将证书部署到内网服务器上：</p><ol><li>将证书先部署到有部署条件的服务器上，然后再在内网服务器上使用 rsync 从部署好的服务器上拉取证书。</li><li>将证书上传到 <a href="https://azure.microsoft.com/en-us/services/key-vault/" rel="external nofollow noreferrer">Azure Key Vault</a> 等托管服务中，再在服务器上按照 <a href="https://blog.men.ci/ssl-with-github-actions/#%E6%9C%8D%E5%8A%A1%E5%99%A8" rel="external nofollow noreferrer">Menci 的文章</a> 中的教程拉取即可。</li></ol><h3 id="阿里云">阿里云</h3><p>阿里云的 <a href="https://www.aliyun.com/product/cas" rel="external nofollow noreferrer">SSL 证书服务</a> 支持上传自定义证书，该证书可以用于 <a href="https://www.aliyun.com/product/cdn" rel="external nofollow noreferrer">阿里云 CDN</a>。阿里云暂未提供将证书部署至 OSS 的 API，建议 OSS 用户使用 CDN 回源 OSS 来代替。</p><p>使用 <a href="https://github.com/Menci/deploy-certificate-to-aliyun" rel="external nofollow noreferrer">Menci/deploy-certificate-to-aliyun</a> 将证书部署到阿里云：</p><pre><code class="hljs yaml"><span class="hljs-comment"># 部署到阿里云</span>
<span class="hljs-attr">deploy-to-aliyun:</span>
  <span class="hljs-attr">name:</span> <span class="hljs-string">Deploy</span> <span class="hljs-string">Certificate</span> <span class="hljs-string">to</span> <span class="hljs-string">Aliyun</span>
  <span class="hljs-attr">runs-on:</span> <span class="hljs-string">ubuntu-latest</span>
  <span class="hljs-attr">needs:</span> <span class="hljs-string">issue-ssl-certificate</span>

  <span class="hljs-attr">steps:</span>
    <span class="hljs-comment"># 拉取证书存储分支</span>
    <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">Checkout</span>
      <span class="hljs-attr">uses:</span> <span class="hljs-string">actions/checkout@v2</span>
      <span class="hljs-attr">with:</span>
        <span class="hljs-attr">ref:</span> <span class="hljs-string">certs</span>

    <span class="hljs-comment"># 上传证书</span>
    <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">Deploy</span> <span class="hljs-string">certificate</span> <span class="hljs-string">to</span> <span class="hljs-string">aliyun</span>
      <span class="hljs-attr">uses:</span> <span class="hljs-string">Menci/deploy-certificate-to-aliyun@beta-v1</span>
      <span class="hljs-attr">with:</span>
        <span class="hljs-attr">access-key-id:</span> <span class="hljs-string">$&#123;&#123;</span> <span class="hljs-string">secrets.ALIYUN_ACCESS_KEY_ID</span> <span class="hljs-string">&#125;&#125;</span>
        <span class="hljs-attr">access-key-secret:</span> <span class="hljs-string">$&#123;&#123;</span> <span class="hljs-string">secrets.ALIYUN_ACCESS_KEY_SECRET</span> <span class="hljs-string">&#125;&#125;</span>
        <span class="hljs-attr">fullchain-file:</span> <span class="hljs-string">$&#123;&#123;</span> <span class="hljs-string">env.CERTS_OUTPUT_DIRECTORY</span> <span class="hljs-string">&#125;&#125;/$&#123;&#123;</span> <span class="hljs-string">env.FILE_FULLCHAIN</span> <span class="hljs-string">&#125;&#125;</span>
        <span class="hljs-attr">key-file:</span> <span class="hljs-string">$&#123;&#123;</span> <span class="hljs-string">env.CERTS_OUTPUT_DIRECTORY</span> <span class="hljs-string">&#125;&#125;/$&#123;&#123;</span> <span class="hljs-string">env.FILE_KEY</span> <span class="hljs-string">&#125;&#125;</span>
        <span class="hljs-attr">certificate-name:</span> <span class="hljs-string">example.com</span>
        <span class="hljs-attr">cdn-domains:</span> <span class="hljs-string">|</span>
<span class="hljs-string">          example.com</span>
<span class="hljs-string">          example.net</span></code></pre><p>其中 <code>certificate-name</code> 指定上传的证书在证书服务中的名称（将自动替换旧版本），<code>cdn-domains</code> 指定需要将该证书部署到的 CDN 域名列表（用空白字符隔开）。</p><p>建议使用子账户 Access Key，为其赋予以下权限（并按需使用资源组隔离）：</p><ul><li>AliyunYundunCertFullAccess</li><li>AliyunCDNFullAccess</li><li>AliyunPCDNFullAccess</li><li>AliyunSCDNFullAccess</li><li>AliyunDCDNFullAccess</li></ul><h3 id="腾讯云">腾讯云</h3><p>使用 <a href="https://github.com/renbaoshuo/deploy-certificate-to-tencentcloud" rel="external nofollow noreferrer">renbaoshuo/deploy-certificate-to-tencentcloud</a> 将证书部署至腾讯云 CDN：</p><pre><code class="hljs yaml"><span class="hljs-attr">deploy-to-qcloud-cdn:</span>
  <span class="hljs-attr">name:</span> <span class="hljs-string">Deploy</span> <span class="hljs-string">certificate</span> <span class="hljs-string">to</span> <span class="hljs-string">Tencent</span> <span class="hljs-string">Cloud</span> <span class="hljs-string">CDN</span>
  <span class="hljs-attr">runs-on:</span> <span class="hljs-string">ubuntu-latest</span>
  <span class="hljs-attr">needs:</span> <span class="hljs-string">issue-ssl-certificate</span>

  <span class="hljs-attr">steps:</span>
    <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">Check</span> <span class="hljs-string">out</span>
      <span class="hljs-attr">uses:</span> <span class="hljs-string">actions/checkout@v2</span>
      <span class="hljs-attr">with:</span>
        <span class="hljs-comment"># If you just commited and pushed your newly issued certificate to this repo in a previous job,</span>
        <span class="hljs-comment"># use `ref` to make sure checking out the newest commit in this job</span>
        <span class="hljs-attr">ref:</span> <span class="hljs-string">$&#123;&#123;</span> <span class="hljs-string">github.ref</span> <span class="hljs-string">&#125;&#125;</span>

    <span class="hljs-bullet">-</span> <span class="hljs-attr">uses:</span> <span class="hljs-string">renbaoshuo/deploy-certificate-to-tencentcloud@beta-v1</span>
      <span class="hljs-attr">with:</span>
        <span class="hljs-comment"># Use Access Key</span>
        <span class="hljs-attr">secret-id:</span> <span class="hljs-string">$&#123;&#123;</span> <span class="hljs-string">secrets.QCLOUD_SECRET_ID</span> <span class="hljs-string">&#125;&#125;</span>
        <span class="hljs-attr">secret-key:</span> <span class="hljs-string">$&#123;&#123;</span> <span class="hljs-string">secrets.QCLOUD_SECRET_KEY</span> <span class="hljs-string">&#125;&#125;</span>

        <span class="hljs-comment"># Specify PEM fullchain file</span>
        <span class="hljs-attr">fullchain-file:</span> <span class="hljs-string">$&#123;&#123;</span> <span class="hljs-string">env.CERTS_OUTPUT_DIRECTORY</span> <span class="hljs-string">&#125;&#125;/$&#123;&#123;</span> <span class="hljs-string">env.FILE_FULLCHAIN</span> <span class="hljs-string">&#125;&#125;</span>
        <span class="hljs-comment"># Specify PEM private key file</span>
        <span class="hljs-attr">key-file:</span> <span class="hljs-string">$&#123;&#123;</span> <span class="hljs-string">env.CERTS_OUTPUT_DIRECTORY</span> <span class="hljs-string">&#125;&#125;/$&#123;&#123;</span> <span class="hljs-string">env.FILE_KEY</span> <span class="hljs-string">&#125;&#125;</span>

        <span class="hljs-comment"># Deploy to CDN</span>
        <span class="hljs-attr">cdn-domains:</span> <span class="hljs-string">|</span>
<span class="hljs-string">          cdn1.example.com</span>
<span class="hljs-string">          cdn2.example.com</span></code></pre><p>其中 <code>cdn-domains</code> 指定需要将该证书部署到的 CDN 域名列表（用空白字符隔开）。</p><p>建议使用子账户 API 密钥，为其赋予以下权限（并按需使用资源组隔离）：</p><ul><li>QcloudCDNFullAccess</li></ul><h2 id="完整例子">完整例子</h2><p>这个 Action 完成了以下操作：</p><ol><li>申请证书，并上传到仓库的 <code>certs</code> 分支。</li><li>在申请证书后将 <code>certs</code> 分支中的证书部署到服务器上。</li></ol><pre><code class="hljs yaml"><span class="hljs-comment"># 名称</span>
<span class="hljs-attr">name:</span> <span class="hljs-string">Issue</span> <span class="hljs-string">SSL</span> <span class="hljs-string">Certificates</span>

<span class="hljs-comment"># 触发条件</span>
<span class="hljs-attr">on:</span>
  <span class="hljs-comment"># 手动运行</span>
  <span class="hljs-attr">workflow_dispatch:</span>
  <span class="hljs-comment"># 定时运行</span>
  <span class="hljs-attr">schedule:</span>
    <span class="hljs-comment"># 每两个月运行一次</span>
    <span class="hljs-bullet">-</span> <span class="hljs-attr">cron:</span> <span class="hljs-string">&#x27;0 0 1 */2 *&#x27;</span>

<span class="hljs-comment"># 全局环境变量</span>
<span class="hljs-attr">env:</span>
  <span class="hljs-comment"># Checkout 到的目录</span>
  <span class="hljs-attr">CERTS_OUTPUT_BASE:</span> <span class="hljs-string">certs</span>
  <span class="hljs-comment"># 证书输出目录</span>
  <span class="hljs-attr">CERTS_OUTPUT_DIRECTORY:</span> <span class="hljs-string">example.com</span>
  <span class="hljs-comment"># 证书文件名</span>
  <span class="hljs-attr">FILE_FULLCHAIN:</span> <span class="hljs-string">fullchain.pem</span>
  <span class="hljs-comment"># 私钥文件名</span>
  <span class="hljs-attr">FILE_KEY:</span> <span class="hljs-string">privatekey.key</span>

<span class="hljs-attr">jobs:</span>
  <span class="hljs-attr">issue-ssl-certificate:</span>
    <span class="hljs-comment"># 申请证书并 push 到 certs 分支</span>
    <span class="hljs-attr">name:</span> <span class="hljs-string">Issue</span> <span class="hljs-string">SSL</span> <span class="hljs-string">certificate</span>
    <span class="hljs-attr">runs-on:</span> <span class="hljs-string">ubuntu-latest</span>
    <span class="hljs-attr">steps:</span>
      <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">Checkout</span>
        <span class="hljs-attr">uses:</span> <span class="hljs-string">actions/checkout@v2</span>
        <span class="hljs-attr">with:</span>
          <span class="hljs-attr">ref:</span> <span class="hljs-string">master</span>

      <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">Checkout</span> <span class="hljs-string">output</span> <span class="hljs-string">branch</span>
        <span class="hljs-attr">uses:</span> <span class="hljs-string">actions/checkout@v2</span>
        <span class="hljs-attr">with:</span>
          <span class="hljs-attr">ref:</span> <span class="hljs-string">certs</span>
          <span class="hljs-attr">path:</span> <span class="hljs-string">$&#123;&#123;</span> <span class="hljs-string">env.CERTS_OUTPUT_BASE</span> <span class="hljs-string">&#125;&#125;</span>

      <span class="hljs-comment"># 安装 acme.sh</span>
      <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">Install</span> <span class="hljs-string">acme.sh</span>
        <span class="hljs-attr">shell:</span> <span class="hljs-string">bash</span>
        <span class="hljs-attr">run:</span> <span class="hljs-string">curl</span> <span class="hljs-string">-s</span> <span class="hljs-string">https://get.acme.sh</span> <span class="hljs-string">|</span> <span class="hljs-string">sh</span>

      <span class="hljs-comment"># 解压 acme.sh 配置信息</span>
      <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">Extract</span> <span class="hljs-string">account</span> <span class="hljs-string">files</span> <span class="hljs-string">for</span> <span class="hljs-string">acme.sh</span>
        <span class="hljs-attr">shell:</span> <span class="hljs-string">bash</span>
        <span class="hljs-attr">run:</span> <span class="hljs-string">|</span>
<span class="hljs-string">          echo &quot;$ACME_SH_ACCOUNT_TAR&quot; | base64 -d | tar -C ~/.acme.sh -xz</span>
<span class="hljs-string"></span>        <span class="hljs-attr">env:</span>
          <span class="hljs-comment"># Base64 编码的 acme.sh 配置信息</span>
          <span class="hljs-attr">ACME_SH_ACCOUNT_TAR:</span> <span class="hljs-string">$&#123;&#123;</span> <span class="hljs-string">secrets.ACME_SH_ACCOUNT_TAR</span> <span class="hljs-string">&#125;&#125;</span>

      <span class="hljs-comment"># 申请证书</span>
      <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">Issue</span> <span class="hljs-string">SSL</span> <span class="hljs-string">certificates</span>
        <span class="hljs-attr">shell:</span> <span class="hljs-string">bash</span>
        <span class="hljs-attr">run:</span> <span class="hljs-string">|</span>
<span class="hljs-string">          ~/.acme.sh/acme.sh --issue            \</span>
<span class="hljs-string">            -d &quot;example.com&quot; -d &quot;*.example.com&quot; \</span>
<span class="hljs-string">            --dns dns_cf --server letsencrypt</span>
<span class="hljs-string"></span>
      <span class="hljs-comment"># 导出证书</span>
      <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">Copy</span> <span class="hljs-string">certificate</span> <span class="hljs-string">to</span> <span class="hljs-string">output</span> <span class="hljs-string">paths</span>
        <span class="hljs-attr">shell:</span> <span class="hljs-string">bash</span>
        <span class="hljs-attr">run:</span> <span class="hljs-string">|</span>
<span class="hljs-string">          ACME_SH_TEMP_DIR=&quot;$(mktemp -d)&quot;</span>
<span class="hljs-string">          ACME_SH_TEMP_FILE_FULLCHAIN=&quot;$ACME_SH_TEMP_DIR/fullchain.pem&quot;</span>
<span class="hljs-string">          ACME_SH_TEMP_FILE_KEY=&quot;$ACME_SH_TEMP_DIR/key.pem&quot;</span>
<span class="hljs-string"></span>
          <span class="hljs-comment"># 不要忘记修改这里的 -d 参数值为上方的第一个域名</span>
          <span class="hljs-string">~/.acme.sh/acme.sh</span> <span class="hljs-string">--install-cert</span> <span class="hljs-string">-d</span> <span class="hljs-string">&quot;example.com&quot;</span> <span class="hljs-string">--fullchain-file</span> <span class="hljs-string">&quot;$ACME_SH_TEMP_FILE_FULLCHAIN&quot;</span> <span class="hljs-string">--key-file</span> <span class="hljs-string">&quot;$ACME_SH_TEMP_FILE_KEY&quot;</span>

          [[ <span class="hljs-string">-z</span> <span class="hljs-string">&quot;$ACME_SH_OUTPUT_FULLCHAIN&quot;</span> ]] <span class="hljs-string">||</span> <span class="hljs-string">(mkdir</span> <span class="hljs-string">-p</span> <span class="hljs-string">&quot;$(dirname &quot;</span><span class="hljs-string">$ACME_SH_OUTPUT_FULLCHAIN&quot;)&quot;</span> <span class="hljs-string">&amp;&amp;</span> <span class="hljs-string">cp</span> <span class="hljs-string">&quot;$ACME_SH_TEMP_FILE_FULLCHAIN&quot;</span> <span class="hljs-string">&quot;$ACME_SH_OUTPUT_FULLCHAIN&quot;</span><span class="hljs-string">)</span>
          [[ <span class="hljs-string">-z</span> <span class="hljs-string">&quot;$ACME_SH_OUTPUT_KEY&quot;</span> ]] <span class="hljs-string">||</span> <span class="hljs-string">(mkdir</span> <span class="hljs-string">-p</span> <span class="hljs-string">&quot;$(dirname &quot;</span><span class="hljs-string">$ACME_SH_OUTPUT_KEY&quot;)&quot;</span> <span class="hljs-string">&amp;&amp;</span> <span class="hljs-string">cp</span> <span class="hljs-string">&quot;$ACME_SH_TEMP_FILE_KEY&quot;</span> <span class="hljs-string">&quot;$ACME_SH_OUTPUT_KEY&quot;</span><span class="hljs-string">)</span>

          <span class="hljs-string">rm</span> <span class="hljs-string">-rf</span> <span class="hljs-string">&quot;$ACME_SH_TEMP_DIR&quot;</span>
        <span class="hljs-attr">env:</span>
          <span class="hljs-attr">ACME_SH_OUTPUT_FULLCHAIN:</span> <span class="hljs-string">$&#123;&#123;</span> <span class="hljs-string">env.CERTS_OUTPUT_BASE</span> <span class="hljs-string">&#125;&#125;/$&#123;&#123;</span> <span class="hljs-string">env.CERTS_OUTPUT_DIRECTORY</span> <span class="hljs-string">&#125;&#125;/$&#123;&#123;</span> <span class="hljs-string">env.FILE_FULLCHAIN</span> <span class="hljs-string">&#125;&#125;</span>
          <span class="hljs-attr">ACME_SH_OUTPUT_KEY:</span> <span class="hljs-string">$&#123;&#123;</span> <span class="hljs-string">env.CERTS_OUTPUT_BASE</span> <span class="hljs-string">&#125;&#125;/$&#123;&#123;</span> <span class="hljs-string">env.CERTS_OUTPUT_DIRECTORY</span> <span class="hljs-string">&#125;&#125;/$&#123;&#123;</span> <span class="hljs-string">env.FILE_KEY</span> <span class="hljs-string">&#125;&#125;</span>

      <span class="hljs-comment"># 上传证书</span>
      <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">Push</span> <span class="hljs-string">to</span> <span class="hljs-string">GitHub</span>
        <span class="hljs-attr">run:</span> <span class="hljs-string">|</span>
<span class="hljs-string">          git config --global user.name &quot;BaoshuoBot&quot;</span>
<span class="hljs-string">          git config --global user.email &quot;79077260+BaoshuoBot@users.noreply.github.com&quot;</span>
<span class="hljs-string"></span>
          <span class="hljs-string">cd</span> <span class="hljs-string">&quot;$CERTS_DIRECTORY&quot;</span>

          <span class="hljs-string">git</span> <span class="hljs-string">add</span> <span class="hljs-string">&quot;$FILE_FULLCHAIN&quot;</span> <span class="hljs-string">&quot;$FILE_KEY&quot;</span>
          <span class="hljs-string">git</span> <span class="hljs-string">commit</span> <span class="hljs-string">-m</span> <span class="hljs-string">&quot;Upload certificates on $(date &#x27;+%Y-%m-%d %H:%M:%S&#x27;)&quot;</span>
          <span class="hljs-string">git</span> <span class="hljs-string">push</span>
        <span class="hljs-attr">env:</span>
          <span class="hljs-attr">TZ:</span> <span class="hljs-string">Asia/Shanghai</span>
          <span class="hljs-attr">CERTS_DIRECTORY:</span> <span class="hljs-string">$&#123;&#123;</span> <span class="hljs-string">env.CERTS_OUTPUT_BASE</span> <span class="hljs-string">&#125;&#125;/$&#123;&#123;</span> <span class="hljs-string">env.CERTS_OUTPUT_DIRECTORY</span> <span class="hljs-string">&#125;&#125;</span>

  <span class="hljs-comment"># 部署证书到服务器</span>
  <span class="hljs-attr">deploy-to-server:</span>
    <span class="hljs-attr">name:</span> <span class="hljs-string">Deploy</span> <span class="hljs-string">Certificate</span> <span class="hljs-string">to</span> <span class="hljs-string">Server</span>
    <span class="hljs-attr">runs-on:</span> <span class="hljs-string">ubuntu-latest</span>
    <span class="hljs-attr">needs:</span> <span class="hljs-string">issue-ssl-certificate</span>

    <span class="hljs-attr">strategy:</span>
      <span class="hljs-attr">matrix:</span>
        <span class="hljs-attr">host:</span>
          <span class="hljs-bullet">-</span> <span class="hljs-number">174.136</span><span class="hljs-number">.239</span><span class="hljs-number">.1</span> <span class="hljs-comment"># Server 1</span>
          <span class="hljs-bullet">-</span> <span class="hljs-number">174.136</span><span class="hljs-number">.239</span><span class="hljs-number">.2</span> <span class="hljs-comment"># Server 2</span>
          <span class="hljs-comment"># ...</span>
          <span class="hljs-bullet">-</span> <span class="hljs-number">174.136</span><span class="hljs-number">.239</span><span class="hljs-number">.254</span> <span class="hljs-comment"># Server N</span>

    <span class="hljs-attr">steps:</span>
      <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">Checkout</span>
        <span class="hljs-attr">uses:</span> <span class="hljs-string">actions/checkout@v2</span>
        <span class="hljs-attr">with:</span>
          <span class="hljs-attr">ref:</span> <span class="hljs-string">certs</span>

      <span class="hljs-comment"># 上传证书</span>
      <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">Upload</span> <span class="hljs-string">certificate</span> <span class="hljs-string">to</span> <span class="hljs-string">server</span>
        <span class="hljs-attr">uses:</span> <span class="hljs-string">easingthemes/ssh-deploy@v2.1.5</span>
        <span class="hljs-attr">env:</span>
          <span class="hljs-attr">SSH_PRIVATE_KEY:</span> <span class="hljs-string">$&#123;&#123;</span> <span class="hljs-string">secrets.SSH_PRIVATE_KEY</span> <span class="hljs-string">&#125;&#125;</span>
          <span class="hljs-attr">ARGS:</span> <span class="hljs-string">&#x27;-avz --delete&#x27;</span>
          <span class="hljs-attr">REMOTE_HOST:</span> <span class="hljs-string">$&#123;&#123;</span> <span class="hljs-string">matrix.host</span> <span class="hljs-string">&#125;&#125;</span>
          <span class="hljs-attr">REMOTE_USER:</span> <span class="hljs-string">$&#123;&#123;</span> <span class="hljs-string">secrets.REMOTE_USER</span> <span class="hljs-string">&#125;&#125;</span>
          <span class="hljs-attr">SOURCE:</span> <span class="hljs-string">$&#123;&#123;</span> <span class="hljs-string">env.CERTS_OUTPUT_DIRECTORY</span> <span class="hljs-string">&#125;&#125;/</span>
          <span class="hljs-attr">TARGET:</span> <span class="hljs-string">/path/to/ssl/certs/$&#123;&#123;</span> <span class="hljs-string">env.CERTS_OUTPUT_DIRECTORY</span> <span class="hljs-string">&#125;&#125;/</span>

      <span class="hljs-comment"># 重载 Nginx</span>
      <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">Force-reload</span> <span class="hljs-string">nginx</span>
        <span class="hljs-attr">uses:</span> <span class="hljs-string">appleboy/ssh-action@v0.1.4</span>
        <span class="hljs-attr">with:</span>
          <span class="hljs-attr">host:</span> <span class="hljs-string">$&#123;&#123;</span> <span class="hljs-string">matrix.host</span> <span class="hljs-string">&#125;&#125;</span>
          <span class="hljs-attr">username:</span> <span class="hljs-string">$&#123;&#123;</span> <span class="hljs-string">secrets.REMOTE_USER</span> <span class="hljs-string">&#125;&#125;</span>
          <span class="hljs-attr">key:</span> <span class="hljs-string">$&#123;&#123;</span> <span class="hljs-string">secrets.SSH_PRIVATE_KEY</span> <span class="hljs-string">&#125;&#125;</span>
          <span class="hljs-attr">script:</span> <span class="hljs-string">|</span>
            <span class="hljs-string">sudo</span> <span class="hljs-string">/opt/hooks/reload-nginx.sh</span></code></pre><h2 id="杂项">杂项</h2><p>部分情况下，GitHub Actions 中的 <code>GITHUB_TOKEN</code> 只有 Read repository contents permission，而本文中的 Actions 要求这个 Token 具有 Read and write permissions，那么需要在仓库的 Settings &gt; Actions &gt; General 页面的底部赋予其写入权限，如图所示：</p><p><img src="https://s1.baoshuo.ren/2022/05/15/WA5tTau3mnBLIqZ.png" alt="" loading="lazy"></p><p>设置好后点击 Save 按钮即可。</p><h2 id="参考资料">参考资料</h2><ol><li><a href="https://blog.men.ci/ssl-with-github-actions/" rel="external nofollow noreferrer">使用 GitHub Actions 自动申请与部署 ACME SSL 证书</a>，Menci，2022 年 5 月 11 日。对原文章内容的使用已经过作者同意。</li><li><a href="https://u.sb/acme-sh-ssl/" rel="external nofollow noreferrer">使用 acme.sh 配置自动续签 SSL 证书</a>，烧饼博客，2022 年 2 月 3 日。</li></ol><p>文章头图由 <a href="https://men.ci" rel="external nofollow noreferrer">Menci</a> 制作，使用已经过授权，在此表示感谢。</p>]]></content>
        <author>
            <name>宝硕</name>
            <uri>https://baoshuo.ren</uri>
        </author>
    </entry>
    <entry>
        <title type="html"><![CDATA[强制卸载三星应用分身中的残留应用]]></title>
        <id>/post/uninstall-samsung-extra-dual-app/</id>
        <link href="/post/uninstall-samsung-extra-dual-app/"/>
        <updated>2022-04-30T01:40:32.000Z</updated>
        <content type="html"><![CDATA[<p>前一阵子不小心手抖把手机里的 Chrome 卸载了，然后就装不上了。</p><img src="https://s1.baoshuo.ren/2022/04/30/6Y5HdtnT4fKrcxZ.jpg" width="350"><p>▲ 安装时的报错信息</p><p>这个迷惑的报错信息误导了我很长时间，再加上我在学校里拿不到手机，于是 3 月初的问题一直拖到了 4 月底才解决。</p><p>拿到手机之后我突然想看看手机里有什么不再需要的应用需要卸载，清理清理手机的存储空间。于是我翻到了这么一个应用：</p><img src="https://s1.baoshuo.ren/2022/04/30/TvSn9tKzrZ5qifx.jpg" width="350"><p>▲ 应用图标右下角的橙色标志代表了这是一个安装在应用分身中的应用</p><p>但是我手机里的应用分身只能安装两个应用：微信和 QQ。所以问题应该就是出在了这里。我试着点击了下方的「卸载」按钮，但提示卸载成功并重启后，这个 Chrome 浏览器依然静静地呆在手机里，丝毫没有要离开的意思。</p><p>我在网上找到了一篇名为《<a href="https://www.sizau.com/a/one-ui-dual-app.html" rel="external nofollow noreferrer">技术 | One UI 不熔断，让应用分身双开任何应用</a>》的文章，里面讲解了如何在应用分身中安装其他应用的方法，还提到了应用分身其实是以 Android 多用户的形式实现的，分身中的所有应用都安装在了名为 <code>DUAL_APP</code> 的用户下。知道了这些信息，事情就好办得多了，直接用 ADB 把它搞掉就行了（<a href="https://developer.android.com/studio/releases/platform-tools#downloads" rel="external nofollow noreferrer">ADB 下载地址</a>）。</p><p><a href="https://publish.samsungsimulator.com/simulator/418c1904-4e51-4517-bee3-334744957266/#!topic/%E8%AE%BE%E7%BD%AE%E8%8F%9C%E5%8D%95/%E5%BC%80%E5%90%AF%E5%BC%80%E5%8F%91%E8%80%85%E9%80%89%E9%A1%B9" rel="external nofollow noreferrer">在手机上开启开发者模式</a> 后，在「开发者选项」中允许「USB 调试」，然后使用数据线将手机连接到电脑，这样就可以在电脑上通过 ADB 操控手机了。</p><p>使用下面的命令来查看手机中的用户列表：</p><pre><code class="hljs shell">adb shell pm list users</code></pre><p><img src="https://s1.baoshuo.ren/2022/04/30/9PDszfwVaoT8NCQ.png" alt="" loading="lazy"></p><p>▲ 图中被红色方框框住的就是应用分身对应的用户了</p><p>然后使用下面的命令来查看分身中的应用列表：</p><pre><code class="hljs shell">adb shell pm list packages --user 95</code></pre><p><img src="https://s1.baoshuo.ren/2022/04/30/F3rhWgUpY4evMZa.png" alt="" loading="lazy"></p><p>▲ 图中被红色方框框住的就是应用分身中的 Chrome 浏览器的包名了</p><p>那么就可以卸载分身中的 Chrome 浏览器了：</p><pre><code class="hljs shell">adb uninstall --user 95 com.android.chrome</code></pre><p><img src="https://s1.baoshuo.ren/2022/04/30/HInGCjd4JRuUrwT.png" alt="" loading="lazy"></p><p>卸载完成后，就可以通过你喜欢的方式安装应用了。我这里同样使用了 ADB 来进行 Chrome 浏览器的安装操作：</p><pre><code class="hljs shell">adb install &quot;com.android.chrome_101.0.4951.41-495104123.apk&quot;</code></pre><p><img src="https://s1.baoshuo.ren/2022/04/30/yNFCt7fqYPAoDBO.png" alt="" loading="lazy"></p><p>最后不要忘记关掉「USB 调试」功能，以免产生安全风险。</p>]]></content>
        <author>
            <name>宝硕</name>
            <uri>https://baoshuo.ren</uri>
        </author>
    </entry>
    <entry>
        <title type="html"><![CDATA[2022 年常中集训游记]]></title>
        <id>/post/travel-scz-2022/</id>
        <link href="/post/travel-scz-2022/"/>
        <updated>2022-02-28T09:03:57.000Z</updated>
        <summary type="html"><![CDATA[这是我第一次出省参加外校集训。此行的目的地是江苏省常州高级中学，于 1907 年建校，截止本文写作时该校在「OIerDb 全国信息学竞赛学校排行榜」上位列第九。]]></summary>
        <content type="html"><![CDATA[<img src="https://s1.baoshuo.ren/2022/02/28/J5yx9hPKLZdu4Hz.jpg" width="100%" alt="2022 年常中集训游记" /><p>这是我第一次出省参加外校集训。此行的目的地是江苏省常州高级中学，于 1907 年建校，截止本文写作时该校在「OIerDb 全国信息学竞赛学校排行榜」上位列第九。</p><span id="more"></span><h2 id="启程">启程</h2><p>走前 2 天，也就是 2 月 18 日，我们才正式确定要动身去常中参加集训，当时火车票余票已经所剩无几了，索性直接买了一等座，省时省力，就是有点费钱。</p><p><img src="https://s1.baoshuo.ren/2022/02/28/ys2OdY56rtDC43U.jpg" width="51.25%" style="margin-right:4px"><img src="https://s1.baoshuo.ren/2022/02/28/JzSrD97LyP4KI8b.jpg" width="45%"></p><p>一等座确实比二等座舒服了很多，还有免费的零食、饮料、矿泉水。不过，要是下次可以自己挑的话，我还是选二等座，经济实惠。</p><img src="https://s1.baoshuo.ren/2022/02/28/AnK1PqdCfQHEcYj.jpg" width="300" style="display:block;margin:0 auto 1rem"><p>晚饭在火车上买了份「豚骨面」，花了 39 元，除了汤有点发酸（可能是醋倒多了）以外别的没啥毛病。</p><h2 id="见闻">见闻</h2><h3 id="住宿">住宿</h3><p>由于学校没有给我们提供宿舍，所以我们两人成团一起住宾馆，每间 160 元/晚。</p><p><img src="https://s1.baoshuo.ren/2022/02/28/vbwahiHPXu7IU21.jpg" alt="" loading="lazy"></p><p>环境还行，凑合着住。</p><h3 id="食堂">食堂</h3><p><img src="https://s1.baoshuo.ren/2022/02/28/YgAPOB6K7xFnwJI.jpg" alt="" loading="lazy"></p><p>▲ 外景</p><img src="https://s1.baoshuo.ren/2022/02/27/xaUc8KZ1WICibop.jpg" width="300" style="display:block;margin:0 auto 1rem"><p>▲ 饭卡</p><p>食堂的餐食比假期的二南好多了，但我觉得赶不上开学时候的二南食堂。</p><h3 id="蹭网">蹭网</h3><p>常中并没有给我们分配上网账号，所以要么用打开文件资源管理器都能死机的台式机上网，要么用自己的笔记本离线操作。</p><p>毛主席说过：「自己动手，丰衣足食。」所以我们把台式机的网线拔下来插到了自己的电脑上，并且手动配好了 IP 地址，成功解决了上网问题。</p><p>蹭网期间出一个小插曲：有人拿自己配好的网开热点给大家共享网络，结果被系统自动断网并且封掉设备了…</p><h3 id="校园">校园</h3><p><img src="https://s1.baoshuo.ren/2022/02/28/LS9EumNvBynMIV5.jpg" alt="" loading="lazy"></p><p>进入校园。</p><p><img src="https://s1.baoshuo.ren/2022/02/28/5K2pODGQ1U3ufhF.jpg" alt="" loading="lazy"></p><p>标志性的「<strong>SCZ</strong>」标识。</p><p><img src="https://s1.baoshuo.ren/2022/02/28/RYWTNgijmfVn6H2.jpg" alt="" loading="lazy"></p><p>校园一角。</p><p><img src="https://s1.baoshuo.ren/2022/02/28/wF9MVZO6W21rvnp.jpg" alt="" loading="lazy"></p><p>教学楼外景。</p><img src="https://s1.baoshuo.ren/2022/02/28/vqHWncS4VOZ6Rhd.jpg" height="450"><p>小亭子。</p><img src="https://s1.baoshuo.ren/2022/02/28/r7RFDVZcCAPuoNx.jpg" width="48%" style="margin-right:4px"> <img src="https://s1.baoshuo.ren/2022/02/28/RYzfbEPtmDBk6F9.jpg" width="48%"><p>学校旁边的 <a href="https://baike.baidu.com/item/%E5%A4%A9%E5%AE%81%E5%AE%9D%E5%A1%94" rel="external nofollow noreferrer">天宁宝塔</a>。</p><h2 id="返程">返程</h2><p>来的时候在火车上吃的是面条，于是返程的时候买了一盒「红烧牛肉饭」，花了 40 元，味道也不错。</p><p><img src="https://s1.baoshuo.ren/2022/02/28/4pWTVO6eE1UBwKk.jpg" alt="" loading="lazy"></p><h3 id="花絮">花絮</h3><p>回学校的最后一段路是坐公交回去的。</p><p>到站了，老师带着我们下了车，下车后才发现 zzq 还在车上，于是我们眼睁睁地看着公交车继续前行，而 zzq 还不知道他已经坐过站了…</p><h2 id="后记-8">后记</h2><p>在校期间的学习、交流等活动均属保密范畴，在本文中不做叙述。</p><p>希望以后还能有这么好的机会参加外出集训。</p>]]></content>
        <author>
            <name>宝硕</name>
            <uri>https://baoshuo.ren</uri>
        </author>
    </entry>
    <entry>
        <title type="html"><![CDATA[再见，2021 —— 我的 2021 年度总结]]></title>
        <id>/post/goodbye-2021/</id>
        <link href="/post/goodbye-2021/"/>
        <updated>2021-12-31T06:21:49.000Z</updated>
        <summary type="html"><![CDATA[时光飞逝，2021 年就这么过完了。在这一年，我经历了很多，也学到了很多。现在，让我坐在电脑前，用文字的方式将这一切都记录下来…]]></summary>
        <content type="html"><![CDATA[<img src="https://arina.loli.net/2022/01/01/E215KwxIFUGnXlN.png" width="100%" alt="再见，2021 —— 我的 2021 年度总结" /><p>时光飞逝，2021 年就这么过完了。在这一年，我经历了很多，也学到了很多。现在，让我坐在电脑前，用文字的方式将这一切都记录下来…</p><span id="more"></span><blockquote><p>本文内容按照发生时间先后排序。</p></blockquote><h2 id="大事记">大事记</h2><h3 id="封校的日子">封校的日子</h3><p>2021 年 1 月 3 日，<a href="https://zh.wikipedia.org/wiki/2019%E5%86%A0%E7%8A%B6%E7%97%85%E6%AF%92%E7%97%85%E6%B2%B3%E5%8C%97%E7%9C%81%E7%96%AB%E6%83%85#1%E6%9C%88_2" rel="external nofollow noreferrer">石家庄疫情</a> 爆发，石家庄市进入战时状态<sup>（<a href="http://www.xinhuanet.com/local/2021-01/04/c_1126942898.htm" rel="external nofollow noreferrer">新华网</a>）</sup>。</p><p>次日清晨，学校里传开了一条爆炸性新闻 —— 封校了！</p><p>中午下课后，大家纷纷奔向学校超市，开始抢购商品。由于初三下课最晚，等我们奔向超市的时候，超市空得连价签都没了。我并没有去抢，因为我在元旦假期返校的时候带了不少东西，足够我吃了。</p><p>然而超市一连好几天无货可卖，这使得我们都开始担心 —— 万一哪天没饭了怎么办？而这时学校终于传来了好消息：学校和政府终于为超市协调来了货源，可以继续上架面包、牛奶和生活必需品了。</p><p>不过我去食堂的时候倒是发现了一个以前从未出现的奇妙现象，那就是肉给的比菜多。我举一个典型事例：我去食堂买板面吃，食堂阿姨给我盛了半勺子肉，然后从旁边的菜盆里夹了三根很小的菠菜叶放到了碗里。除此之外，免费续米饭的量也变得越来越少。不过有的吃我就知足了，没必要那么挑。</p><p>周末学校还给放了电影，周日按照正常留宿作息多睡了会。封校的第一周就这么过去了。</p><p>谁也没想到封校会持续那么久，于是大家都在学校呆着，在学习的同时等待外界的好消息。</p><p>有一次教育处的尹主任值我们班晚自习，我正好坐第一排，作业写完了没事干，又去不了高中部，便和老师聊了起来。我向老师抱怨初三的学生觉不够睡，而初一的学生休息时间太多以至于睡不着觉，希望能多给初三的学生点休息时间，不然上课得困死。听完以后，老师给年级主任发了条微信。没想到，第二节晚自习下课，年级就广播说以后每周六都让初三的多睡一小时。多亏了尹主任的反馈，我终于能补个好觉了，上课也终于不用再半睡半醒了。</p><p>就这样又过了大概二十天，外面终于传来了好消息 —— 解封了！</p><p>听到解封的消息时，我的心情很复杂 —— 我的健康码是黄色的。这代表即使学校解封了，我也回不了家。</p><p>好在解封的第二天，我的健康码变回了绿色，当天下午我被接回了家，一切都结束了。</p><h3 id="中考">中考</h3><p>6 月 21 日，我迎来了人生中的第一次大考 —— 中考。</p><img style="display:inline-block" width="42.5%" src="https://arina.loli.net/2021/12/29/rtJy8mUM4jSRBNa.png"> <img style="display:inline-block" width="55%" src="https://arina.loli.net/2021/12/29/Gn4h1Qx2aMYkAsz.png"><p>说实话，头进考场我还是有一点点发慌的，因为我的知识大多都是退役以后现补的。物理的力学还没补，语文的古诗文刚背完原文没背课注和赏析，<span title="看完会吐">政治看都没看</span>…</p><p>总之没好好复习就是了。就这样硬着头皮进了考场，考啥算啥吧。</p><p>考完以后便是漫长的等待。7 月 3 日 0 时，终于出分了：</p><img width="500" src="https://arina.loli.net/2021/12/30/5PuseCqbXcI1KJ7.png/500/1000"><p>中考试卷的难易度还算适中，考得不算特别差，全市三千多名。</p><p>由于疫情的原因，石家庄并没有举行体育和实验的考试，所以中考总分只有 610 分。这对于体育不是很好的我来说是一个救命稻草，要不然我得比别人低至少 10 分，就没学可上了。</p><p>中考成绩出来以后，我向我的竞赛教练咨询了一下我的成绩，教练告诉我没啥问题，能上二南。</p><img width="500" src="https://arina.loli.net/2021/12/31/ot5Q9TGgVdzjNAn.png/500/1000"> <img width="300" src="https://arina.loli.net/2022/01/01/Mf75RmDqwz2UvAV.jpg"><p>居然混进了一个省重点高中… 失学儿童有学上了！</p><p>上了高中以后因为学习竞赛，被分到了省理科竞赛实验班，大概是全校最好的班级了吧。只不过因为班里其他人都是各地状元，所以我的文化课被同学们吊起来暴锤。</p><p>总体还行。只是没想到因为这些事就被别人称为了「别人家的孩子」，当不起当不起，毕竟我是真的菜…</p><h3 id="竞赛">竞赛</h3><p>今年的竞赛成绩并不理想。</p><p>CSP 拿了个省二，再多考 19 分就有省一了。</p><p>NOIP 打算冲省一，结果考试的时候电脑蓝屏了… 以后再也不用画图当草稿纸了！</p><p>不过和自己的好朋友们在一起<span title="卷">努力</span>还是很开心的~</p><p>丢人的练习详情可以在 GitHub 上查看：<a href="https://github.com/renbaoshuo/OI-codes/compare/2020...2021" rel="external nofollow noreferrer">Compare 2020…2021 - renbaoshuo/OI-codes</a>。</p><h2 id="一些零碎">一些零碎</h2><h3 id="gpg">GPG</h3><p>今年年初，我开始使用 GPG 来对我的消息和提交签名。</p><p>我的 GPG 公钥可以在 <a href="https://github.com/renbaoshuo.gpg" rel="external nofollow noreferrer">GitHub</a> 上找到。</p><h3 id="hustoj">HUSTOJ</h3><p><img src="https://arina.loli.net/2021/12/31/TOlfnVsAbjMhm7w.png" alt="" loading="lazy"></p><p><img src="https://arina.loli.net/2021/12/31/gcy5o86unOZTVLP.png" alt="" loading="lazy"></p><p>年初的时候给 HUSTOJ 贡献了两个主题：<a href="https://github.com/zhblue/hustoj/pull/722" rel="external nofollow noreferrer">SYZOJ</a> 和 <a href="https://github.com/zhblue/hustoj/pull/742" rel="external nofollow noreferrer">MDUI</a>。</p><p>因为 SYZOJ 主题被设置为了默认主题，所以年末的时候还被教练找上门问 HUSTOJ 相关的问题来了。</p><h3 id="计算机网络">计算机网络</h3><p>从寒假开始我开始接触计算机网络相关的知识，并且在 DN42 和公网上进行了相关实践。</p><h3 id="pure-主题">Pure 主题</h3><p><img src="https://arina.loli.net/2021/12/31/xLCYesoFNqvWfbz.png" alt="" loading="lazy"></p><p>这个主题移植自 <a href="https://github.com/imhanjie/gridea-theme-pure" rel="external nofollow noreferrer">imhanjie/gridea-theme-pure</a>。</p><p>源代码公开在 <a href="https://github.com/renbaoshuo/hexo-theme-pure" rel="external nofollow noreferrer">GitHub</a> 上。</p><h3 id="我的-yubikey">我的 Yubikey</h3><img width="400" src="https://arina.loli.net/2022/01/01/oMcSKAaizC7X9fZ.jpg"><p>体验良好，于是年末又入了个 CanoKey 作为备用 Key。</p><h3 id="oierdb-ng">OIerDb NG</h3><p><img src="https://arina.loli.net/2021/12/31/iBmAh6MeGRHyKl7.png" alt="" loading="lazy"></p><p>这是个从 12 月份刚刚开始搞的项目，目前正处于开发期，由我和 <a href="https://men.ci" rel="external nofollow noreferrer">Menci</a> 共同维护。</p><p>计划中 <a href="https://oier.baoshuo.dev" rel="external nofollow noreferrer">OIerDb NG</a> 将会最终替代现在的 <a href="https://bytew.net/OIer" rel="external nofollow noreferrer">OIerDb</a>。</p><p>OIerDb NG 的前端缓存式查询方法在提高查询速度的同时还省去了后端服务器的处理。</p><p>代码开源在 <a href="https://github.com/OIerDb-ng/OIerDb" rel="external nofollow noreferrer">GitHub</a> 上，欢迎 Star ~</p><h3 id="其他-2">其他</h3><img width="700" src="https://arina.loli.net/2021/12/31/y5cxk7JwaolAnO1.png"><p>其实里面有好多都是贡献给自己的私有仓库了。</p><p>可以直接去 <a href="https://github.com/renbaoshuo?tab=overview&amp;from=2021-12-01&amp;to=2021-12-31" rel="external nofollow noreferrer">我的 GitHub 主页</a> 上看公开的贡献详情，懒得再多说了。</p><h2 id="后记-2">后记</h2><p>2021 年一转眼就过完了，有很多新收获，同时也有很多遗憾，就不再多说了。</p><p>希望自己 2022 年会过得更好吧，也祝读者们新年快乐。</p><p><small>本文封面图片来自美国驻华使领馆官方推特账号，其他图片均为本人所拍摄或截取。</small></p>]]></content>
        <author>
            <name>宝硕</name>
            <uri>https://baoshuo.ren</uri>
        </author>
    </entry>
    <entry>
        <title type="html"><![CDATA[浅谈静态博客的自动部署方案]]></title>
        <id>/post/auto-deploy-static-blog/</id>
        <link href="/post/auto-deploy-static-blog/"/>
        <updated>2021-11-10T15:57:14.000Z</updated>
        <summary type="html"><![CDATA[笔者最近阅读了 ChrAlpha 大佬的 初探无后端静态博客自动化部署方案 这篇博文，发现其中的一些内容已经过时，所以我决定写下这篇博文来简单说一说现在（2021 年）静态博客的自动部署方案。]]></summary>
        <content type="html"><![CDATA[<img src="https://s1.baoshuo.ren/2021/10/31/uyZDJLU9NntF684.png" width="100%" alt="浅谈静态博客的自动部署方案" /><p>笔者最近阅读了 ChrAlpha 大佬的 <a href="https://blog.ichr.me/post/automated-deployment-of-serverless-static-blog/" rel="external nofollow noreferrer">初探无后端静态博客自动化部署方案</a> 这篇博文，发现其中的一些内容已经过时，所以我决定写下这篇博文来简单说一说现在（2021 年）静态博客的自动部署方案。</p><span id="more"></span><p>笔者 9 月中旬将自己的 OI 博客（<a href="https://oi.baoshuo.ren" rel="external nofollow noreferrer">oi.baoshuo.ren</a>）迁到了 GitHub 上并使用 GitHub Actions 进行持续部署，在感觉良好以后又在 10 月初将自己的主博客（<a href="https://blog.baoshuo.ren">blog.baoshuo.ren</a>）也迁移到了上面，这期间我尝试了多家 CI/CD 服务，并总结了一些配置要领。</p><p>本文中使用的 NodeJS 包管理器为 yarn 。</p><h2 id="github-actions">GitHub Actions</h2><p>GitHub Actions 是笔者最常用的 CI/CD 服务，没有之一。关于 GitHub Actions 的介绍可以查看 <a href="https://docs.github.com/en/actions" rel="external nofollow noreferrer">GitHub Actions 官网文档</a> 和阮老师的 <a href="https://www.ruanyifeng.com/blog/2019/09/getting-started-with-github-actions.html" rel="external nofollow noreferrer">GitHub Actions 入门教程</a> 。</p><p>配置 GitHub Actions 是非常方便的，无需绑定任何第三方平台，仅需在仓库中新建一个 <code>.github/workflows/*.yml</code> 即可。</p><blockquote><p>Hexo 核心团队成员之一 <a href="https://skk.moe" rel="external nofollow noreferrer">Sukka</a> 大佬在他的 <a href="https://blog.skk.moe/post/deploy-blog-to-cf-workers-site/" rel="external nofollow noreferrer">将 Hexo 部署到 Cloudflare Workers Site 上的趟坑记录</a> 一文中强烈建议不要使用任何 Hexo 的 GitHub Action ，把 Hexo 当成一个普通的依赖 NodeJS 的构建程序，遵照这个思路编写配置文件即可。</p></blockquote><pre><code class="hljs yaml"><span class="hljs-attr">name:</span> <span class="hljs-string">Build</span>

<span class="hljs-attr">on:</span>
  <span class="hljs-attr">push:</span>
    <span class="hljs-attr">branches:</span>
      <span class="hljs-bullet">-</span> <span class="hljs-string">master</span>
  <span class="hljs-attr">workflow_dispatch:</span>

<span class="hljs-attr">jobs:</span>
  <span class="hljs-attr">build:</span>
    <span class="hljs-attr">runs-on:</span> <span class="hljs-string">ubuntu-latest</span>
    <span class="hljs-attr">steps:</span>
      <span class="hljs-bullet">-</span> <span class="hljs-attr">uses:</span> <span class="hljs-string">actions/checkout@v2</span>
      <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">Use</span> <span class="hljs-string">Node.js</span> <span class="hljs-number">14</span>
        <span class="hljs-attr">uses:</span> <span class="hljs-string">actions/setup-node@v2</span>
        <span class="hljs-attr">with:</span>
          <span class="hljs-attr">node-version:</span> <span class="hljs-number">14</span>
          <span class="hljs-attr">cache:</span> <span class="hljs-string">yarn</span>
      <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">Install</span> <span class="hljs-string">Dependencies</span>
        <span class="hljs-attr">run:</span> <span class="hljs-string">yarn</span> <span class="hljs-string">install</span>
      <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">Build</span> <span class="hljs-string">Site</span>
        <span class="hljs-attr">run:</span> <span class="hljs-string">yarn</span> <span class="hljs-string">build</span>
      <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">Deploy</span> <span class="hljs-string">to</span> <span class="hljs-string">GitHub</span> <span class="hljs-string">Pages</span>
        <span class="hljs-attr">uses:</span> <span class="hljs-string">peaceiris/actions-gh-pages@v3</span>
        <span class="hljs-attr">with:</span>
          <span class="hljs-attr">github_token:</span> <span class="hljs-string">$&#123;&#123;</span> <span class="hljs-string">secrets.GITHUB_TOKEN</span> <span class="hljs-string">&#125;&#125;</span>
          <span class="hljs-attr">publish_dir:</span> <span class="hljs-string">public</span>
          <span class="hljs-attr">cname:</span> <span class="hljs-string">blog.baoshuo.ren</span></code></pre><p>该工作流的大体步骤如下：</p><ol><li>检出仓库中的源文件到工作目录</li><li>安装 NodeJS 和 yarn 包管理器，如果使用的是 npm 包管理器请自行修改。</li><li>安装依赖。</li><li>构建站点。</li><li>部署到 GitHub Pages 。</li></ol><p>在构建完成后会发现文章的更新时间出现了错误，可以在生成前添加下面这步来将文件的修改日期更正为该文件最后一次 commit 时的时间。</p><pre><code class="hljs yml"><span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">Fix</span> <span class="hljs-string">File</span> <span class="hljs-string">Modify</span> <span class="hljs-string">Date</span>
  <span class="hljs-attr">run:</span> <span class="hljs-string">|</span>
    <span class="hljs-string">git</span> <span class="hljs-string">ls-files</span> <span class="hljs-string">|</span> <span class="hljs-string">while</span> <span class="hljs-string">read</span> <span class="hljs-string">filepath;</span> <span class="hljs-string">do</span> <span class="hljs-string">touch</span> <span class="hljs-string">-d</span> <span class="hljs-string">&quot;$(git log -1 --format=&#x27;@%ct&#x27; $filepath)&quot;</span> <span class="hljs-string">&quot;$filepath&quot;</span> <span class="hljs-string">&amp;&amp;</span> <span class="hljs-string">echo</span> <span class="hljs-string">&quot;Fixed: $filepath&quot;</span><span class="hljs-string">;</span> <span class="hljs-string">done</span></code></pre><p>当然，为了让 git 有日志可寻，还得在检出的时候顺带把所有提交历史一并拉下来，指定 <code>fetch-depth</code> 就能做到：</p><pre><code class="hljs yaml"><span class="hljs-bullet">-</span> <span class="hljs-attr">uses:</span> <span class="hljs-string">actions/checkout@v2</span>
  <span class="hljs-attr">with:</span>
    <span class="hljs-attr">fetch-depth:</span> <span class="hljs-number">0</span></code></pre><p>然后开启 GitHub Pages 功能即可访问到构建好的站点了。</p><h2 id="cloudflare-pages">Cloudflare Pages</h2><p>如果觉得 GitHub Actions + GitHub Pages 比较麻烦的话，才推出不久的 Cloudflare Pages 或许是一个不错的选择。</p><p>前往 <a href="https://dash.cloudflare.com" rel="external nofollow noreferrer">CloudFlare 管理面板</a> 登录账号后即可在右侧找到「网页」或者「Pages」功能的入口。</p><p>点击新建按钮，选择要使用的仓库，点击下一步。</p><p><img src="https://s1.baoshuo.ren/2021/10/31/9HpOja1N6JIK4DP.png" alt="" loading="lazy"></p><p>Cloudflare Pages 的构建配置模板中并没有给出 Hexo 的模板，所以需要自己填写：</p><p><img src="https://s1.baoshuo.ren/2021/10/31/zc7GdhKqCSfliQ1.png" alt="" loading="lazy"></p><p>完成之后点击确定就可以开始构建站点了。</p><p><img src="https://s1.baoshuo.ren/2021/10/31/Z9YrJGNByXhKbkl.png" alt="" loading="lazy"></p><p>构建完成后，访问分配的 <code>pages.dev</code> 子域名即可查看构建好的站点。</p><p>可以在「自定义域」选项卡中添加自定义域名。</p><h2 id="netlify">Netlify</h2><p>Netlify 是一家为静态网站提供托管服务的平台，有一定的免费额度，对于小型站点来说使用免费套餐就足够了。</p><p>首先登陆账号，点击「New site from Git」按钮新建一个站点。</p><p><img src="https://s1.baoshuo.ren/2021/10/31/sULdZkfIgOBhzJP.png" alt="" loading="lazy"></p><p>可以看到 Netlify 自动识别出了博客使用的框架并且填充好了构建命令，接下来只需要点击下一步即可。</p><p><img src="https://s1.baoshuo.ren/2021/10/31/yVlnMEJgeLSzwFD.png" alt="" loading="lazy"></p><p>新建站点完成以后可以在「Domain Settings」页面中修改默认分配的 <code>netlify.app</code> 子域名，并添加自定义域名。</p><h2 id="vercel">Vercel</h2><p>Vercel 是一个类似于 Netlify 的静态网站托管平台（Vercel 也支持托管 Serverless 函数，不过不在本文的讨论范围内）。</p><p><img src="https://s1.baoshuo.ren/2021/10/22/1oLr8fiODTNXSRP.png" alt="" loading="lazy"></p><p>绑定好 GitHub 账号后导入一个新的项目即可。</p><p><img src="https://s1.baoshuo.ren/2021/10/31/EAsH2CWLUTZFeXu.png" alt="" loading="lazy"></p><p>Vercel 也和 Netlify 自动填充好了构建命令，如果没有特殊需求可以直接点击下一步。</p><p>可以在项目的域名设置中绑定自定义域名。</p><h2 id="参考资料-3">参考资料</h2><ol><li><a href="https://blog.ichr.me/post/automated-deployment-of-serverless-static-blog/" rel="external nofollow noreferrer">初探无后端静态博客自动化部署方案</a>，ChrAlpha，2020 年 2 月 14 日。</li><li><a href="https://stackoverflow.com/questions/42032035/finding-files-older-than-certain-dates-in-git-repository" rel="external nofollow noreferrer">Finding files older than certain dates in Git repository</a>，Scott Weldon (on Stack Overflow)，2017 年 2 月 7 日。</li><li><a href="https://blog.skk.moe/post/deploy-blog-to-cf-workers-site/" rel="external nofollow noreferrer">将 Hexo 部署到 Cloudflare Workers Site 上的趟坑记录</a>，Sukka，2020 年 6 月 7 日。</li></ol>]]></content>
        <author>
            <name>宝硕</name>
            <uri>https://baoshuo.ren</uri>
        </author>
    </entry>
    <entry>
        <title type="html"><![CDATA[USTC Hackergame 2021 Write Up]]></title>
        <id>/post/ustc-hackergame-2021-write-up/</id>
        <link href="/post/ustc-hackergame-2021-write-up/"/>
        <updated>2021-10-30T04:00:00.000Z</updated>
        <content type="html"><![CDATA[<h2 id="签到">签到</h2><p><img src="https://s1.baoshuo.ren/2021/10/24/6HiDz8gjEVMQsph.png" alt="" loading="lazy"></p><p>点击 <code>Next</code> 键，发现页面的 URL 后多了个 <code>?page=1</code> ，结合第一个页面中的 <code>1970-01-01</code> 字样，可以判断出来 <code>page</code> 参数应为比赛期间的 Unix 时间戳。</p><p>示例：<a href="http://202.38.93.111:10000/?page=1635002186" rel="external nofollow noreferrer">http://202.38.93.111:10000/?page=1635002186</a></p><h2 id="进制十六——参上">进制十六——参上</h2><p><img src="https://s1.baoshuo.ren/2021/10/24/swZPQblAxcqCtEz.png" alt="" loading="lazy"></p><p>可以照着 16 进制数据搞一搞，然后 flag 就出来了：</p><p><img src="https://s1.baoshuo.ren/2021/10/24/poz4TdtU8nVPg75.png" alt="" loading="lazy"></p><h2 id="去吧！追寻自由的电波">去吧！追寻自由的电波</h2><p>下载音频之后使用 Adobe Audition 进行变速即可。</p><p><img src="https://s1.baoshuo.ren/2021/10/24/GyoM3w185UhPxbz.png" alt="" loading="lazy"></p><h2 id="旅行照片">旅行照片</h2><p><img src="https://s1.baoshuo.ren/2021/10/25/lHJ6SwxrW8mQf53.png" alt="" loading="lazy"></p><p>从图片中可以看出拍摄者在 14 层，并且楼下有一个蓝色的肯德基，那么使用 Google 搜索关键词 <code>海洋 蓝色 KFC</code> 可以得到以下结果：</p><p><img src="https://s1.baoshuo.ren/2021/10/25/FzxEHLfX5ylKkiN.png" alt="" loading="lazy"></p><p>从照片的描述中可以得到这家肯德基位于秦皇岛新澳海底世界。</p><p>在百度地图上可以找到这家肯德基的电话、详细位置。同时按照卫星图可以推断出拍摄者所在的方向，进而推断出拍摄的大致时间。</p><p><img src="https://s1.baoshuo.ren/2021/10/25/crgFKpCOaoq8WzN.png" alt="" loading="lazy"></p><p>flag 获取成功。</p><h2 id="flag-助力大红包">FLAG 助力大红包</h2><p>查看点击助力按钮后的浏览器请求可以发现请求时有一个名为 IP 的参数，尝试修改这个参数发现会报错提示前后端检测 IP 不一致，那么考虑添加 <code>X-Forwarded-For</code> 头伪造经过代理的来源 IP 地址即可。</p><p>比赛平台的速率限制为每秒最多请求一次，所以在每次请求后还需要等待 1 秒。</p><pre><code class="hljs bash"><span class="hljs-keyword">for</span> ((i=0; <span class="hljs-variable">$i</span> &lt;= 255; i = (<span class="hljs-variable">$i</span> + 1))); <span class="hljs-keyword">do</span>
    curl <span class="hljs-string">&quot;http://202.38.93.111:10888/invite/<span class="hljs-variable">$invite_id</span>&quot;</span> -H <span class="hljs-string">&quot;X-Forwarded-For: <span class="hljs-variable">$i</span>.11.45.14&quot;</span> -d <span class="hljs-string">&quot;ip=<span class="hljs-variable">$i</span>.11.45.14&quot;</span>
    <span class="hljs-built_in">sleep</span> 1
<span class="hljs-keyword">done</span></code></pre><h2 id="猫咪问答-pro-max">猫咪问答 Pro Max</h2><ol><li>2017 年，中科大信息安全俱乐部（SEC@USTC）并入中科大 Linux 用户协会（USTCLUG）。目前，信息安全俱乐部的域名（<a href="http://sec.ustc.edu.cn" rel="external nofollow noreferrer">sec.ustc.edu.cn</a>）已经无法访问，但你能找到信息安全俱乐部的社团章程在哪一天的会员代表大会上通过的吗？</li></ol><p>Wayback Machine 是个好东西啊。（<a href="https://web.archive.org/web/20170515053637/http://sec.ustc.edu.cn/doku.php/codes" rel="external nofollow noreferrer">页面存档</a>）</p><ol start="2"><li>中国科学技术大学 Linux 用户协会在近五年多少次被评为校五星级社团？</li></ol><p><img src="https://s1.baoshuo.ren/2021/10/24/32Oq1tW86oke7rI.png" alt="" loading="lazy"></p><p>LUG 官网上直接搜就出来了。但实际上的答案应该是 5 ，可能是官网没更新最新信息。</p><ol start="3"><li>中国科学技术大学 Linux 用户协会位于西区图书馆的活动室门口的牌子上“LUG @ USTC”下方的小字是？</li></ol><blockquote><p>谷歌是你的好朋友。 <cite>Hackergame 2020 「猫咪问答++」 flag 。</cite></p></blockquote><p><img src="https://s1.baoshuo.ren/2021/10/24/MCq9mGNQFUDoHy1.png" alt="" loading="lazy"></p><p>可以看到正确答案为 <code>Development Team of Library</code> 。</p><ol start="4"><li>在 SIGBOVIK 2021 的一篇关于二进制 Newcomb-Benford 定律的论文中，作者一共展示了多少个数据集对其理论结果进行验证？</li></ol><p>可以在 <a href="http://sigbovik.org/2021/proceedings.pdf" rel="external nofollow noreferrer">the record of the proceedings of SIGBOVIK 2021</a>（<a href="https://web.archive.org/web/20210626111527/http://www.sigbovik.org/2021/proceedings.pdf" rel="external nofollow noreferrer">页面存档</a>）的 212 页找到这篇论文。</p><ol start="5"><li>不严格遵循协议规范的操作着实令人生厌，好在 IETF 于 2021 年成立了 Protocol Police 以监督并惩戒所有违背 RFC 文档的行为个体。假如你发现了某位同学可能违反了协议规范，根据 Protocol Police 相关文档中规定的举报方法，你应该将你的举报信发往何处？</li></ol><p>搜索关键词：<a href="https://www.google.com/search?q=IETF+Protocol+Police" rel="external nofollow noreferrer">IETF Protocol Police</a></p><p>可以搜到这个「搞笑 RFC」：<a href="https://datatracker.ietf.org/doc/html/rfc8962#section-6" rel="external nofollow noreferrer">Establishing the Protocol Police</a> ，在第 6 节中有相关介绍。</p><p>正确答案应为 <code>/dev/null</code> 。</p><h2 id="卖瓜">卖瓜</h2><p>最开始拿到题我先想的是能不能用负数凑，结果发现不行，于是考虑溢出。</p><p>试了试发现使用 6 斤瓜无法触发溢出，而使用 9 斤瓜的就可以触发溢出了。</p><p><img src="https://s1.baoshuo.ren/2021/10/27/HGwsJeqB63SZrNA.png" alt="" loading="lazy"></p><p>写了个脚本跑一跑，试出来了几个负数，挨个试了下发现放 2e18 个 9 斤瓜可以凑到 20 斤。</p><p><img src="https://s1.baoshuo.ren/2021/10/27/APRwaqf6SO3DTyH.png" alt="" loading="lazy"></p><p>然后在计算器里算了一下，只需要加 6 斤的瓜和 9 斤的瓜各 29782938247303441 个就能让称的显示变成 -1 。</p><p>接下来放 2 个 6 斤瓜和 1 个 9 斤瓜就能拿到 flag 了。</p><h2 id="透明的文件">透明的文件</h2><p>本题与 <a href="https://en.wikipedia.org/wiki/ANSI_escape_code" rel="external nofollow noreferrer">ANSI Escape Code</a> 有关。</p><p>首先需要将文件中的 <code>[</code> 替换成 <code>\033[</code> ，然后再找一个支持显示 ANSI 控制码的终端输出。</p><p>然后发现一片空白，啥也没有。</p><p>捣鼓到快怀疑人生才发现终端上的某些字符被遮挡了，进而想到这个脚本可能清除了终端上某些地方的字符来显示 flag 。</p><p>先编写一个复读函数用来填满终端：</p><pre><code class="hljs bash"><span class="hljs-function"><span class="hljs-title">repeat</span></span>() &#123;
    <span class="hljs-keyword">for</span> ((i = 1; <span class="hljs-variable">$i</span> &lt;= <span class="hljs-variable">$1</span>; i = (<span class="hljs-variable">$i</span> + 1))); <span class="hljs-keyword">do</span>
        <span class="hljs-built_in">echo</span> -n <span class="hljs-string">&quot;▉&quot;</span>
    <span class="hljs-keyword">done</span>
&#125;</code></pre><p><img src="https://s1.baoshuo.ren/2021/10/29/mniZ4Qch5rHCxWI.png" alt="" loading="lazy"></p><p>再配合上方替换好的文件输出即可，效果如图。</p><h2 id="amnesia">Amnesia</h2><h3 id="轻度失忆">轻度失忆</h3><p>使用 <code>putchar()</code> 函数即可解决此问题。</p><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span>

<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;
    <span class="hljs-built_in">putchar</span>(<span class="hljs-string">&#x27;H&#x27;</span>);
    <span class="hljs-built_in">putchar</span>(<span class="hljs-string">&#x27;e&#x27;</span>);
    <span class="hljs-built_in">putchar</span>(<span class="hljs-string">&#x27;l&#x27;</span>);
    <span class="hljs-built_in">putchar</span>(<span class="hljs-string">&#x27;l&#x27;</span>);
    <span class="hljs-built_in">putchar</span>(<span class="hljs-string">&#x27;o&#x27;</span>);
    <span class="hljs-built_in">putchar</span>(<span class="hljs-string">&#x27;,&#x27;</span>);
    <span class="hljs-built_in">putchar</span>(<span class="hljs-string">&#x27; &#x27;</span>);
    <span class="hljs-built_in">putchar</span>(<span class="hljs-string">&#x27;w&#x27;</span>);
    <span class="hljs-built_in">putchar</span>(<span class="hljs-string">&#x27;o&#x27;</span>);
    <span class="hljs-built_in">putchar</span>(<span class="hljs-string">&#x27;r&#x27;</span>);
    <span class="hljs-built_in">putchar</span>(<span class="hljs-string">&#x27;l&#x27;</span>);
    <span class="hljs-built_in">putchar</span>(<span class="hljs-string">&#x27;d&#x27;</span>);
    <span class="hljs-built_in">putchar</span>(<span class="hljs-string">&#x27;!&#x27;</span>);
    <span class="hljs-built_in">putchar</span>(<span class="hljs-string">&#x27;\n&#x27;</span>);
    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
&#125;</code></pre><h2 id="图之上的信息">图之上的信息</h2><p>可以使用 <code>__schema</code> 字段查询所有存在的类型：</p><pre><code class="hljs graphql">&#123;
  __schema &#123;
    types &#123;
      name
    &#125;
  &#125;
&#125;</code></pre><p><img src="https://s1.baoshuo.ren/2021/10/25/OpGkfi3FyAbugwT.png" alt="" loading="lazy"></p><p>发现一个名为 <code>GUser</code> 的类型，再构造一个语句查询类型结构：</p><pre><code class="hljs graphql">&#123;
  __type(name: &quot;GUser&quot;) &#123;
    name
    fields &#123;
      name
      type &#123;
        name
        kind
        ofType &#123;
          name
          kind
        &#125;
      &#125;
    &#125;
  &#125;
&#125;</code></pre><p><img src="https://s1.baoshuo.ren/2021/10/25/XzhIAwocnVMx6Lk.png" alt="" loading="lazy"></p><p>顺便获取了下 <code>GNote</code> 类型的结构：</p><p><img src="https://s1.baoshuo.ren/2021/10/25/9mtWaPAFoYfDLXu.png" alt="" loading="lazy"></p><p>进行查询即可得到 flag ：</p><p><img src="https://s1.baoshuo.ren/2021/10/25/wKs5BpteaYbAcoP.png" alt="" loading="lazy"></p><h2 id="后记-9">后记</h2><p>今年拿的名次比去年的高，感觉在这一年里自己的 web 水平有很大的提升，但 math 还是一如既往地爆了零，和我的数学中考成绩一样的烂。</p><p>以后如果有时间的话逆向、汇编什么的也都要学一学，不然的话每次一看见 binary 就有点不知所措、无从下手属实不太好。</p><p>推荐阅读：<a href="/post/ustc-hackergame-2020-write-up/">USTC Hackergame 2020 Write Up</a>。</p>]]></content>
        <author>
            <name>宝硕</name>
            <uri>https://baoshuo.ren</uri>
        </author>
    </entry>
    <entry>
        <title type="html"><![CDATA[浅谈跨域资源共享（CORS）]]></title>
        <id>/post/cors/</id>
        <link href="/post/cors/"/>
        <updated>2021-10-02T14:24:02.000Z</updated>
        <summary type="html"><![CDATA[跨域资源共享（CORS）是一种基于 HTTP 头来让网页的受限资源能够被其他域名的页面访问的一种机制。通过该机制，页面能够自由地使用不同源的图片、样式、脚本、iframes 以及视频。 在通常情况下，一些跨域的请求会被同源策略禁止。而 CORS 定义了一种方式，可以允许 Web 应用服务器进行跨源访问控制，从而使得跨源数据传输得以安全进行。]]></summary>
        <content type="html"><![CDATA[<img src="https://s1.baoshuo.ren/2021/10/02/6YfLj17HUV4e9Wd.png" width="100%" alt="浅谈跨域资源共享（CORS）" /><p>跨域资源共享（CORS）是一种基于 HTTP 头来让网页的受限资源能够被其他域名的页面访问的一种机制。通过该机制，页面能够自由地使用不同源（cross-origin）的图片、样式、脚本、iframes 以及视频。</p><p>在通常情况下，一些跨域的请求（特别是 ajax）会被同源策略（same-origin policy）禁止。而 CORS 定义了一种方式，可以允许 Web 应用服务器进行跨源访问控制，从而使得跨源数据传输得以安全进行。</p><hr><p>目前几乎所有现代浏览器都支持 CORS ，可以在 <a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/CORS#%E6%B5%8F%E8%A7%88%E5%99%A8%E5%85%BC%E5%AE%B9%E6%80%A7" rel="external nofollow noreferrer">MDN</a> 上找到有关浏览器兼容性的信息。</p><p>浏览器将 CORS 请求分成两类：简单请求（simple request）和非简单请求（not-so-simple request）。<em>这两个术语并不属于 Fetch 规范。</em></p><h2 id="简单请求">简单请求</h2><p>某些请求不会触发 CORS 预检请求。本文中称这样的请求为「简单请求」。</p><h3 id="定义">定义</h3><p>若请求满足所有下述条件则该请求可被视为「简单请求」：</p><ol><li>请求方法为 <code>HEAD</code>，<code>GET</code> 或 <code>POST</code> 。</li><li>除了被用户代理自动设置的字段以及在 Fetch 规范中被定义为 <a href="https://fetch.spec.whatwg.org/#forbidden-header-name" rel="external nofollow noreferrer">禁用头名称</a> 的字段之外，HTTP 头信息只允许包含 Fetch 规范定义的 <a href="https://fetch.spec.whatwg.org/#cors-safelisted-request-header" rel="external nofollow noreferrer">对 CORS 安全的首部字段集合</a> ：<ul><li><code>Accept</code></li><li><code>Accept-Language</code></li><li><code>Content-Language</code></li><li><code>Last-Event-ID</code></li><li><code>Content-Type</code> 仅限于三个值：<code>application/x-www-form-urlencoded</code>、<code>multipart/form-data</code> 或 <code>text/plain</code></li></ul></li><li>请求中的任意 <code>XMLHttpRequestUpload</code> 对象均没有注册任何事件监听器；<code>XMLHttpRequestUpload</code> 对象可以使用 <code>XMLHttpRequest.upload</code> 属性访问。</li><li>请求中没有使用 <code>ReadableStream</code> 对象。</li></ol><p>简单请求的设计是为了兼容表单（form），因为历史上表单就一直可以发出跨域请求。</p><h3 id="基本流程">基本流程</h3><p>对于简单请求，浏览器会直接发出 CORS 请求。具体来说，就是增加一个名为 <code>Origin</code> 的字段到 HTTP 头中。</p><pre><code class="hljs http"><span class="hljs-keyword">GET</span> <span class="hljs-string">/cors</span> <span class="hljs-meta">HTTP/1.1</span>
<span class="hljs-attribute">Origin</span><span class="hljs-punctuation">: </span>http://foo.example
<span class="hljs-attribute">Host</span><span class="hljs-punctuation">: </span>foo.example
<span class="hljs-attribute">Accept-Language</span><span class="hljs-punctuation">: </span>zh-CN
<span class="hljs-attribute">Connection</span><span class="hljs-punctuation">: </span>keep-alive
<span class="hljs-attribute">User-Agent</span><span class="hljs-punctuation">: </span>Mozilla/5.0...</code></pre><p>上面的头信息中，<code>Origin</code> 字段用来说明本次请求来自哪个源，服务器端根据这个值决定是否同意这个请求。</p><p>如果 <code>Origin</code> 指定的源在许可范围内，服务器返回的响应头会添加以下几个字段：</p><ul><li><code>Access-Control-Allow-Origin</code> 字段表明服务器允许的请求源，其值要么为请求时 Origin 字段的值，要么为 <code>*</code> 。</li><li><code>Access-Control-Allow-Credentials</code> 字段表明服务器是否允许发送凭据信息，该字段是可选的，默认情况下不允许发送凭据信息。</li><li><code>Access-Control-Expose-Headers</code> 字段表明服务器指定的允许获取的 HTTP 头字段，该字段是可选的。</li></ul><p>如果 <code>Origin</code> 指定的源不在许可范围内，服务器会返回一个不带 <code>Access-Control-Allow-Origin</code> 字段的正常的 HTTP 回应。当浏览器发现没有包含这个字段就知道请求出错了，会抛出一个异常。需要注意的是，这种错误的 HTTP 响应码有可能是 200 或 204 ，因此无法通过状态码识别。</p><h3 id="代码示例">代码示例</h3><pre><code class="hljs javascript"><span class="hljs-title function_">fetch</span>(<span class="hljs-string">&#x27;https://baoshuo.ren&#x27;</span>, &#123;
  <span class="hljs-attr">mode</span>: <span class="hljs-string">&#x27;no-cors&#x27;</span>,
&#125;);</code></pre><h2 id="非简单请求-——-预检请求">非简单请求 —— 预检请求</h2><p>上面提到，CORS 请求除了简单请求外还有非简单请求。简单来说，非简单请求时对服务器有特殊要求的请求，比如请求方法是 <code>PUT</code> 或 <code>DELETE</code> ，或者 HTTP 头中 <code>Content-Type</code> 字段的值不是上文所述的那三个「对 CORS 安全的 <code>Content-type</code> 字段值」。</p><h3 id="基本流程-2">基本流程</h3><p>非简单请求的 CORS 请求，会在正式通信之前增加一次称为「预检」（preflight）的 HTTP 查询请求。</p><p><img src="https://s1.baoshuo.ren/2021/10/02/Nt9o2cX7gWzuMCr.png" alt="" loading="lazy"></p><p>从上面的报文中可以看到，浏览器先发送了一个使用 <code>OPTIONS</code> 方法的「预检请求」。OPTIONS 是 HTTP/1.1 协议中定义的方法，用以从服务器获取更多信息。该方法不会对服务器资源产生影响。预检请求中同时携带了下面两个首部字段：</p><pre><code class="hljs http"><span class="hljs-attribute">Access-Control-Request-Method</span><span class="hljs-punctuation">: </span>POST
<span class="hljs-attribute">Access-Control-Request-Headers</span><span class="hljs-punctuation">: </span>X-PINGOTHER, Content-Type</code></pre><ul><li><code>Access-Control-Request-Method</code> 字段将告知服务器实际请求将要使用的方法。</li><li><code>Access-Control-Request-Headers</code> 字段将告知服务器实际请求将要携带的自定义请求首部字段。</li></ul><p>服务器将据此决定是否允许实际请求，并返回相应的响应。</p><pre><code class="hljs http"><span class="hljs-attribute">Access-Control-Allow-Origin</span><span class="hljs-punctuation">: </span>http://foo.example
<span class="hljs-attribute">Access-Control-Allow-Methods</span><span class="hljs-punctuation">: </span>POST, GET, OPTIONS
<span class="hljs-attribute">Access-Control-Allow-Headers</span><span class="hljs-punctuation">: </span>X-PINGOTHER, Content-Type
<span class="hljs-attribute">Access-Control-Allow-Credentials</span><span class="hljs-punctuation">: </span>true
<span class="hljs-attribute">Access-Control-Max-Age</span><span class="hljs-punctuation">: </span>86400</code></pre><ul><li><code>Access-Control-Allow-Origin</code> 字段与简单请求时并无差异。</li><li><code>Access-Control-Allow-Methods</code> 字段表明服务器允许哪些方法发起请求。</li><li><code>Access-Control-Allow-Headers</code> 字段表明服务器允许请求头中携带的额外字段。</li><li><code>Access-Control-Allow-Credentials</code> 字段与简单请求时并无差异。</li><li><code>Access-Control-Max-Age</code> 字段表明该响应的有效时间，在有效时间内浏览器无须为同一请求再次发起预检请求。需要注意的是浏览器自身维护了一个最大有效时间，如果该字段的值超出了浏览器维护的最大有效时间则不会生效。</li></ul><p>如果服务器「否定」了一个预检请求，也会返回一个正常的 HTTP 回应，但不包含任何与 CORS 相关的 HTTP 头信息字段。此时浏览器就会认定服务器不同意预检请求，并抛出一个错误。</p><p>一旦通过了预检请求，接下来的步骤就都和简单请求一样了，此处不过多赘述。</p><h3 id="代码示例-2">代码示例</h3><pre><code class="hljs javascript"><span class="hljs-title function_">fetch</span>(<span class="hljs-string">&#x27;https://baoshuo.ren&#x27;</span>, &#123;
  <span class="hljs-attr">mode</span>: <span class="hljs-string">&#x27;cors&#x27;</span>,
&#125;);</code></pre><h2 id="附带身份凭证的-cors-请求">附带身份凭证的 CORS 请求</h2><p>上文中提到，CORS 请求默认不发送凭据信息（Cookie 和 HTTP 认证信息），如果要向服务器发送凭据，不仅需要服务器指定 HTTP 头的 <code>Access-Control-Allow-Credentials</code> 字段，还需要在请求时指明是否发送凭据信息。</p><h3 id="代码示例-3">代码示例</h3><p>使用 <code>XmlHttpRequest</code> 向服务器发起 CORS 请求时，需要将 <code>withCredentials</code> 标志设置为 <code>true</code> 。</p><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> xhr = <span class="hljs-keyword">new</span> <span class="hljs-title class_">XMLHttpRequest</span>();
xhr.<span class="hljs-title function_">open</span>(<span class="hljs-string">&#x27;GET&#x27;</span>, <span class="hljs-string">&#x27;https://baoshuo.ren&#x27;</span>, <span class="hljs-literal">true</span>);
xhr.<span class="hljs-property">withCredentials</span> = <span class="hljs-literal">true</span>;
xhr.<span class="hljs-property">onreadystatechange</span> = handler; <span class="hljs-comment">// 此处的 Handler 需要自行定义</span>
xhr.<span class="hljs-title function_">send</span>();</code></pre><p>使用 fetch 进行请求时则需要设置 <code>credentials</code> 为 <code>include</code> 才能使浏览器向跨域源发送包含凭据的请求。</p><pre><code class="hljs javascript"><span class="hljs-title function_">fetch</span>(<span class="hljs-string">&#x27;https://baoshuo.ren&#x27;</span>, &#123;
  <span class="hljs-attr">credentials</span>: <span class="hljs-string">&#x27;include&#x27;</span>,
&#125;);</code></pre><h2 id="与-jsonp-的比较">与 JSONP 的比较</h2><p>CORS 与 JSONP 的使用目的是相同的，但是 CORS 比 JSONP 更强大。</p><p>JSONP 的缺点是只支持 GET 请求，而 CORS 则支持所有类型的 HTTP 请求。如果网站需要兼容老式浏览器或者需要向不支持 CORS 的网站请求数据仍然需要使用 JSONP 。</p><h2 id="参考资料-4">参考资料</h2><ol><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/CORS" rel="external nofollow noreferrer">跨源资源共享（CORS）</a>，MDN Web Docs，2021 年 8 月 8 日。</li><li><a href="https://www.ruanyifeng.com/blog/2016/04/cors.html" rel="external nofollow noreferrer">跨域资源共享 CORS 详解</a>，阮一峰的网络日志，2016 年 4 月 12 日。</li><li><a href="https://zh.wikipedia.org/wiki/%E8%B7%A8%E4%BE%86%E6%BA%90%E8%B3%87%E6%BA%90%E5%85%B1%E4%BA%AB" rel="external nofollow noreferrer">跨域资源共享</a>，维基百科，2021 年 5 月 3 日。</li><li>3.2. CORS protocol，<a href="https://fetch.spec.whatwg.org/#http-cors-protocol" rel="external nofollow noreferrer">Fetch Standard</a>，2021 年 9 月 30 日。</li><li>参数，<a href="https://developer.mozilla.org/zh-CN/docs/Web/API/fetch#%E5%8F%82%E6%95%B0" rel="external nofollow noreferrer">WorkerOrGlobalScope.fetch()</a>，MDN Web Docs，2021 年 9 月 1 日。</li></ol>]]></content>
        <author>
            <name>宝硕</name>
            <uri>https://baoshuo.ren</uri>
        </author>
    </entry>
    <entry>
        <title type="html"><![CDATA[NOI Linux 2.0 上手体验]]></title>
        <id>/post/noi-linux-2/</id>
        <link href="/post/noi-linux-2/"/>
        <updated>2021-08-08T13:44:33.000Z</updated>
        <summary type="html"><![CDATA[时隔多年，CCF 终于发布了新版的 NOI Linux ，替换了以前基于 Ubuntu 14.04 的 NOI Linux 1.4.1。]]></summary>
        <content type="html"><![CDATA[<img src="https://s1.baoshuo.ren/2021/08/15/POMht9fim1vVKcp.png" width="100%" alt="NOI Linux 2.0 上手体验" /><p>时隔多年，CCF 终于发布了新版的 NOI Linux ，替换了以前基于 Ubuntu 14.04 的 NOI Linux 1.4.1。</p><span id="more"></span><p>在 NOI Linux 2.0 发布的当天，我就迫不及待地下载好了镜像（<a href="https://noiresources.ccf.org.cn/ubuntu-noi-v2.0.iso" rel="external nofollow noreferrer"><code>ubuntu-noi-v2.0.iso</code></a>），但由于时间原因，没有第一时间进行体验。</p><h2 id="安装">安装</h2><p>首先先新建好一台虚拟机。</p><p><img src="https://s1.baoshuo.ren/2021/07/25/ceaObqknR3FTtlU.png" alt="" loading="lazy"></p><p>新建虚拟机及挂载镜像的步骤不再过多叙述，在安装时需要断开网络连接。</p><p><img src="https://s1.baoshuo.ren/2021/07/25/PeYV6lquxawzL7b.png" alt="" loading="lazy"></p><p>开屏就是自定义的启动界面。</p><p>安装后需要连接网络，运行 <code>sudo apt update</code> 更新软件包列表，然后安装 <code>open-vm-tools-desktop</code> ，安装完成后建议重启虚拟机。</p><h2 id="简单体验">简单体验</h2><h3 id="整体评价">整体评价</h3><ol><li>在考场上如果提供 NOI Linux 虚拟机的话，可能需要手动安装 VMware Tools （因为没网所以不能装 Open VM Tools），略麻烦。</li><li>系统操作有点卡，不知道是不是因为虚拟机的原因。</li><li>预装的软件部分是处于半残状态的，在考场上无法正常使用。</li><li>编译器版本较新，默认支持一些新的语言特性。</li><li>在考场上推荐使用 Sublime Text 或者 Code::Blocks 进行代码编写，不推荐使用 VSCode 。</li></ol><h3 id="更新">更新</h3><p><img src="https://s1.baoshuo.ren/2021/08/08/MbBrDuQyYpwP9TA.png" alt="" loading="lazy"></p><p>模拟考试环境时不建议安装<strong>任何</strong>更新，以还原考场上的「本真的」NOI Linux 。如果需要日常使用则建议安装更新。</p><h3 id="vscode">VSCode</h3><p><img src="https://s1.baoshuo.ren/2021/08/08/vs2mDg5KCO61n8X.png" alt="" loading="lazy"></p><p>CCF 预置在 NOI Linux 2.0 中的 VSCode 只能当一个编辑器，并且并没有安装中文语言包和完整的 C/C++ 扩展，处于半残状态。</p><h3 id="sublime-text">Sublime Text</h3><p><img src="https://s1.baoshuo.ren/2021/08/08/TuEGMtsYcndIoNm.png" alt="" loading="lazy"></p><p>相比于 VSCode ，NOI Linux 预装的 Sublime Text 的自动补全功能在始终离线的环境下依旧能正常工作，同时 Sublime Text 也支持单文件编译运行，颜值也不低，写起代码来很舒服。</p><h3 id="code-blocks">Code::Blocks</h3><p><img src="https://s1.baoshuo.ren/2021/08/08/J598DiCRqthEgTS.png" alt="" loading="lazy"></p><p>Code::Blocks 是一个免费、开源、跨平台的集成开发环境，可以在 <a href="https://www.codeblocks.org/" rel="external nofollow noreferrer">codeblocks.org</a> 上找到系统对应版本的 Code::Blocks 预编译二进制包及其源码。</p><p>NOI Linux 中内置的 Code::Blocks 的自动补全、代码提示等功能均能正常使用，且不需要网络连接。</p><h3 id="nano">Nano</h3><p><img src="https://s1.baoshuo.ren/2021/08/08/9BrALjlHxGK54kR.png" alt="" loading="lazy"></p><p>关于 Nano 此处就不再过多叙述，可以在 <a href="https://nano-editor.org" rel="external nofollow noreferrer">The GNU nano homepage</a> 上找到系统对应版本的 Nano 预编译二进制包及其源码。</p><h3 id="emacs">Emacs</h3><p><img src="https://s1.baoshuo.ren/2021/08/08/FQdGqx8bv2oZNJL.png" alt="" loading="lazy"></p><p>笔者并没有深度体验过 Emacs ，所以不做过多评价，在这里推荐一篇入门教程：<a href="https://liujiacai.net/blog/2020/11/25/why-emacs/" rel="external nofollow noreferrer">Emacs 入门指南：Why &amp; How - Keep Coding</a> 。</p><p>可以在 <a href="https://www.gnu.org/software/emacs/" rel="external nofollow noreferrer">GNU Emacs</a> 找到系统对应版本的 Emacs 预编译二进制包及其源码。</p><h3 id="vim">Vim</h3><p><img src="https://s1.baoshuo.ren/2021/08/08/aN9xjIneAYByEXv.png" alt="" loading="lazy"></p><p>Vim 还是老样子，可以在 <a href="https://www.vim.org" rel="external nofollow noreferrer">vim.org</a> 上找到系统对应版本的 Vim 预编译二进制包及其源码，关于 Vim 的使用请参阅 <a href="http://linux.vbird.org/linux_basic/0310vi.php" rel="external nofollow noreferrer">第九章、vim 程式編輯器 - 鳥哥的 Linux 私房菜</a>。</p><h3 id="编译器">编译器</h3><p><img src="https://s1.baoshuo.ren/2021/08/07/lWviXCj9Txqgmr8.png" alt="" loading="lazy"></p><blockquote><p>使用 <code>g++ -dM -E -x c++ /dev/null | grep -F __cplusplus</code> 命令可以查看编译器默认使用的 C++ 标准。</p></blockquote><p>通过上图可以得出 NOI Linux 自带的编译器默认的 C++ 标准是 C++ 14 ，希望 CCF 在比赛评测的时候不要添加 <code>--std=c++98</code> ，同时选手也需要做好无法使用 C++ 14 特性的准备。</p><h3 id="对拍">对拍</h3><p>NOI Linux 2.0 依旧安装了 Arbiter 评测系统，但是由于系统内置了 Python ，所以可以自行编写对拍程序。</p><h2 id="后记-5">后记</h2><p>NOI Linux 的本次更新使得 NOI Linux 系统更加地人性化、更加适合 OIer 们的使用。美中不足的一点是此版本的 NOI Linux 仍然没有卸载 <code>openssh-client</code> 软件包。</p><h2 id="参考资料-11">参考资料</h2><ol><li><a href="https://noi.cn/gynoi/jsgz/2021-07-16/732450.shtml" rel="external nofollow noreferrer">NOI Linux 2.0 发布，将于 9 月 1 日起正式启用！ - noi.cn</a></li><li><a href="https://docs.vmware.com/cn/VMware-Tools/11.3.0/com.vmware.vsphere.vmwaretools.doc/GUID-C48E1F14-240D-4DD1-8D4C-25B6EBE4BB0F.html" rel="external nofollow noreferrer">安装 Open VM Tools - VMware Tools - VMware Docs</a></li></ol>]]></content>
        <author>
            <name>宝硕</name>
            <uri>https://baoshuo.ren</uri>
        </author>
    </entry>
    <entry>
        <title type="html"><![CDATA[使用 Cloudflare Warp 为单栈 VPS 添加双栈网络访问]]></title>
        <id>/post/vps-cloudflare-warp/</id>
        <link href="/post/vps-cloudflare-warp/"/>
        <updated>2021-07-15T09:57:25.000Z</updated>
        <summary type="html"><![CDATA[Warp 是 Cloudflare 提供的一项基于 WireGuard 的网络流量安全及加速服务，能够让你通过连接到 Cloudflare 的边缘节点实现隐私保护及链路优化。]]></summary>
        <content type="html"><![CDATA[<img src="https://s1.baoshuo.ren/2021/08/15/UOBRkoXaV9wnYW6.jpg" width="100%" alt="使用 Cloudflare Warp 为单栈 VPS 添加双栈网络访问" /><p><a href="https://blog.cloudflare.com/1111-warp-better-vpn/" rel="external nofollow noreferrer">Warp</a> 是 Cloudflare 提供的一项基于 WireGuard 的网络流量安全及加速服务，能够让你通过连接到 Cloudflare 的边缘节点实现隐私保护及链路优化。</p><span id="more"></span><p>由于 Cloudflare 官方的 <a href="https://developers.cloudflare.com/warp-client/setting-up/linux" rel="external nofollow noreferrer">Warp Client</a> 过于臃肿，导致我看到安装包大小后就决定直接放弃安装，于是我选择了 <a href="https://github.com/ViRb3/wgcf" rel="external nofollow noreferrer">ViRb3/wgcf</a> 替代。</p><p><img src="https://s1.baoshuo.ren/2021/07/15/dHClLqSsvDKbrBc.png" alt="" loading="lazy"></p><h2 id="安装依赖">安装依赖</h2><p>可以前往 <a href="https://github.com/ViRb3/wgcf/releases/latest" rel="external nofollow noreferrer">Releases 页面</a> 下载编译好的二进制文件以供使用。</p><p>安装好之后运行 <code>wgcf --help</code> ，得到类似下图的输出即为安装成功：</p><p><img src="https://s1.baoshuo.ren/2021/07/15/lDaywAzQGd8HI9S.png" alt="" loading="lazy"></p><p>另外还需按照 <a href="https://www.wireguard.com/install/" rel="external nofollow noreferrer">WireGuard 官网</a> 上的说明安装 WireGuard 。</p><p>根据需求可能还需要安装 <code>resolvconf</code> 。</p><h2 id="生成-wireguard-配置文件">生成 WireGuard 配置文件</h2><p>先使用 <code>wgcf register</code> 命令注册 Warp ，使用键盘上的方向键选择 「Yes」 并回车确认：</p><p><img src="https://s1.baoshuo.ren/2021/07/15/MYT5bkX4r2pGHUv.png" alt="" loading="lazy"></p><p>注册成功后的提示：</p><p><img src="https://s1.baoshuo.ren/2021/07/15/y4homkVbqsr9PYj.png" alt="" loading="lazy"></p><p>之后使用 <code>wgcf generate</code> 命令生成配置文件。</p><p><img src="https://s1.baoshuo.ren/2021/07/15/3zWUZYTdGhn9qkP.png" alt="" loading="lazy"></p><h2 id="修改-wireguard-配置文件">修改 WireGuard 配置文件</h2><p>这是一份生成出来的配置文件：</p><pre><code class="hljs ini"><span class="hljs-section">[Interface]</span>
<span class="hljs-attr">PrivateKey</span> = ******
<span class="hljs-attr">Address</span> = <span class="hljs-number">172.16</span>.*.*/<span class="hljs-number">32</span>
<span class="hljs-attr">Address</span> = fd01:******/<span class="hljs-number">128</span>
<span class="hljs-attr">DNS</span> = <span class="hljs-number">1.1</span>.<span class="hljs-number">1.1</span>
<span class="hljs-attr">MTU</span> = <span class="hljs-number">1280</span>

<span class="hljs-section">[Peer]</span>
<span class="hljs-attr">PublicKey</span> = ******
<span class="hljs-attr">AllowedIPs</span> = <span class="hljs-number">0.0</span>.<span class="hljs-number">0.0</span>/<span class="hljs-number">0</span>
<span class="hljs-attr">AllowedIPs</span> = ::/<span class="hljs-number">0</span>
<span class="hljs-attr">Endpoint</span> = engage.cloudflareclient.com:<span class="hljs-number">2408</span></code></pre><ul><li>添加 IPv4 网络访问<ol><li>删去 <code>[Interface]</code> 中的 <code>Address = fd01:******/128</code> ；</li><li>删去 <code>[Peer]</code> 中的 <code>AllowedIPs = ::/0</code> ；</li><li>将 Endpoint 的域名替换为解析出来的 IPv6 地址，如 <code>[2606:4700:d0::a29f:c001]:2408</code> 。</li></ol></li><li>添加 IPv6 网络访问<ol><li>删去 <code>[Interface]</code> 中的 <code>Address = 172.16.*.*/32</code> ；</li><li>删去 <code>[Peer]</code> 中的 <code>AllowedIPs = 0.0.0.0/0</code> ；</li><li>将 Endpoint 的域名替换为解析出来的 IPv4 地址，如 <code>162.159.192.1:2408</code> 。</li></ol></li></ul><p>如果不需要使用 Cloudflare 的 DNS 服务可以删去 <code>DNS = 1.1.1.1</code> 这一行，使用的话需要安装 <code>resolvconf</code> 。</p><h2 id="启动-wireguard-隧道">启动 WireGuard 隧道</h2><p>将刚才修改好的配置文件移动到 <code>/etc/wireguard/</code> 目录下，推荐命名为 <code>wgcf.conf</code> ，下面的操作以这个文件名为准。</p><p>使用 <code>systemd enable --now wg-quick@wgcf</code> 命令启动隧道，然后使用 <code>wg show wgcf</code> 命令查看隧道状态。</p><p>如果在启动时出现了错误，可以使用 <code>systemd status wg-quick@wgcf</code> 命令查看错误信息，修复后使用 <code>systemd start wg-quick@wgcf</code> 启动隧道。</p><p><img src="https://s1.baoshuo.ren/2021/07/15/M9D1L2rFfHCPtcU.png" alt="" loading="lazy"></p><p>之后就可以享受双栈网络带来的便利了~</p><p>注：日常如果需要重启隧道可以使用 <code>systemctl restart wg-quick@wgcf</code> 命令。</p><h2 id="后记-11">后记</h2><p>折腾这些的原因是我从某个 Player IX 那里嫖的 VM 没有提供 IPv4 网络访问权限，这让我日常的维护工作麻烦了很多，于是我想到了 Cloudflare Warp 这个东西。CloudFlare Warp 提供的网络访问相较于 <a href="http://TunnelBroker.net" rel="external nofollow noreferrer">TunnelBroker.net</a> 、 <a href="http://TunnelBroker.ch" rel="external nofollow noreferrer">TunnelBroker.ch</a> 等一众隧道要好很多，延迟并不像其他隧道那样高。</p><p>在查找资料的过程中我也发现了很多博客里面所描述的内容有误或已经过时，所以综合其他文章的内容加上自己的实践，写下了这篇文章。</p><h2 id="参考资料-14">参考资料</h2><ol><li><a href="https://luotianyi.vc/5252.html" rel="external nofollow noreferrer">【WGCF】连接 CF WARP 为服务器添加 IPv4/IPv6 网络 - Luminous’ Home</a></li><li><a href="https://p3terx.com/archives/use-cloudflare-warp-to-add-extra-ipv4-or-ipv6-network-support-to-vps-servers-for-free.html" rel="external nofollow noreferrer">Cloudflare WARP 给 VPS 服务器额外添加 IPv4 或 IPv6 网络获得“原生”IP - P3TERX</a></li></ol>]]></content>
        <author>
            <name>宝硕</name>
            <uri>https://baoshuo.ren</uri>
        </author>
    </entry>
    <entry>
        <title type="html"><![CDATA[搭建 BIRD Looking Glass 速成指北]]></title>
        <id>/post/bird-looking-glass/</id>
        <link href="/post/bird-looking-glass/"/>
        <updated>2021-05-03T04:23:00.000Z</updated>
        <summary type="html"><![CDATA[BIRD 是 Linux 上常用的一款 BGP 路由软件。bird-lg-go 是 蓝天 使用 Go 语言编写的 Looking Glass 程序，内存占用比原版 bird-lg 更低。它提供了一个网页面板，可以显示各个服务器上的 BIRD 路由软件的状态，以及查询到指定 IP 的路由。]]></summary>
        <content type="html"><![CDATA[<p>BIRD 是 Linux 上常用的一款 BGP 路由软件。bird-lg-go 是 <a href="https://lantian.pub" rel="external nofollow noreferrer">蓝天</a> 使用 Go 语言编写的 Looking Glass 程序，内存占用比原版 bird-lg 更低。它提供了一个网页面板，可以显示各个服务器上的 BIRD 路由软件的状态，以及查询到指定 IP 的路由。</p><span id="more"></span><ul><li>项目地址：<a href="https://github.com/xddxdd/bird-lg-go" rel="external nofollow noreferrer">https://github.com/xddxdd/bird-lg-go</a></li><li>成品： <a href="https://lg.dn42.as141776.net" rel="external nofollow noreferrer">https://lg.dn42.as141776.net</a></li></ul><h2 id="安装-docker-和-docker-compose">安装 Docker 和 Docker Compose</h2><p>虽然这个程序可以直接运行，但我还是比较喜欢套个 Docker 防止污染环境。</p><pre><code class="hljs bash">curl -sSL https://get.docker.com | sh
pip install docker-compose</code></pre><h2 id="编排-docker-compose-服务">编排 Docker Compose 服务</h2><p>在运行 web 的服务器上找个地方（如 <code>/var/bird-lg/</code>），将下面的内容修改后写入 <code>docker-compose.yml</code> 中：</p><pre><code class="hljs yml"><span class="hljs-attr">version:</span> <span class="hljs-string">&#x27;3&#x27;</span>

<span class="hljs-attr">services:</span>
  <span class="hljs-attr">bird-lg:</span>
    <span class="hljs-attr">image:</span> <span class="hljs-string">xddxdd/bird-lg-go</span>
    <span class="hljs-attr">container_name:</span> <span class="hljs-string">bird-lg</span>
    <span class="hljs-attr">restart:</span> <span class="hljs-string">always</span>
    <span class="hljs-attr">environment:</span>
      <span class="hljs-bullet">-</span> <span class="hljs-string">BIRDLG_SERVERS=cn1,eu1</span> <span class="hljs-comment"># 节点列表，以逗号分隔</span>
      <span class="hljs-bullet">-</span> <span class="hljs-string">BIRDLG_DOMAIN=dn42.as141776.net</span> <span class="hljs-comment"># 节点 endpiont 后缀</span>
      <span class="hljs-bullet">-</span> <span class="hljs-string">BIRDLG_TITLE_BRAND=Looking</span> <span class="hljs-string">Glass</span> <span class="hljs-comment"># 标签栏上显示的名称</span>
      <span class="hljs-bullet">-</span> <span class="hljs-string">BIRDLG_NAVBAR_BRAND=Looking</span> <span class="hljs-string">Glass</span> <span class="hljs-comment"># 页面上显示的名称</span>
      <span class="hljs-bullet">-</span> <span class="hljs-string">BIRDLG_WHOIS=whois.lantian.dn42</span> <span class="hljs-comment"># Whois 服务器地址</span>
      <span class="hljs-bullet">-</span> <span class="hljs-string">BIRDLG_DNS_INTERFACE=asn.dn42</span>
    <span class="hljs-attr">ports:</span>
      <span class="hljs-bullet">-</span> <span class="hljs-string">&#x27;5000:5000&#x27;</span>
  <span class="hljs-attr">bird-lgproxy:</span>
    <span class="hljs-attr">image:</span> <span class="hljs-string">xddxdd/bird-lgproxy-go</span>
    <span class="hljs-attr">container_name:</span> <span class="hljs-string">bird-lgproxy</span>
    <span class="hljs-attr">restart:</span> <span class="hljs-string">always</span>
    <span class="hljs-attr">volumes:</span>
      <span class="hljs-bullet">-</span> <span class="hljs-string">&#x27;/var/run/bird/bird.ctl:/var/run/bird/bird.ctl&#x27;</span>
    <span class="hljs-attr">ports:</span>
      <span class="hljs-bullet">-</span> <span class="hljs-string">&#x27;8000:8000&#x27;</span></code></pre><p>在各个节点上只需要写入下面内容即可：</p><pre><code class="hljs yml"><span class="hljs-attr">version:</span> <span class="hljs-string">&#x27;3&#x27;</span>

<span class="hljs-attr">services:</span>
  <span class="hljs-attr">bird-lgproxy:</span>
    <span class="hljs-attr">image:</span> <span class="hljs-string">xddxdd/bird-lgproxy-go</span>
    <span class="hljs-attr">container_name:</span> <span class="hljs-string">bird-lgproxy</span>
    <span class="hljs-attr">restart:</span> <span class="hljs-string">always</span>
    <span class="hljs-attr">volumes:</span>
      <span class="hljs-bullet">-</span> <span class="hljs-string">&#x27;/var/run/bird/bird.ctl:/var/run/bird/bird.ctl&#x27;</span>
    <span class="hljs-attr">ports:</span>
      <span class="hljs-bullet">-</span> <span class="hljs-string">&#x27;8000:8000&#x27;</span></code></pre><p>之后启动 Docker 容器：</p><pre><code class="hljs bash">docker-compose up -d</code></pre><h2 id="使用-nginx-反代页面">使用 nginx 反代页面</h2><p>使用下方的配置启动反向代理即可。</p><pre><code class="hljs nginx"><span class="hljs-section">server</span> &#123;
    <span class="hljs-attribute">listen</span>      *:<span class="hljs-number">80</span>;
    <span class="hljs-attribute">listen</span>      [::]:<span class="hljs-number">80</span>;
    <span class="hljs-attribute">server_name</span> lg.dn42.as141776.net;

    <span class="hljs-comment"># reverse proxy</span>
    <span class="hljs-section">location</span> / &#123;
        <span class="hljs-attribute">proxy_pass</span>                         http://127.0.0.1:5000;
        <span class="hljs-attribute">proxy_http_version</span>                 <span class="hljs-number">1</span>.<span class="hljs-number">1</span>;
        <span class="hljs-attribute">proxy_cache_bypass</span>                 <span class="hljs-variable">$http_upgrade</span>;

        <span class="hljs-comment"># Proxy headers</span>
        <span class="hljs-attribute">proxy_set_header</span> Upgrade           <span class="hljs-variable">$http_upgrade</span>;
        <span class="hljs-attribute">proxy_set_header</span> Host              <span class="hljs-variable">$host</span>;
        <span class="hljs-attribute">proxy_set_header</span> X-Real-IP         <span class="hljs-variable">$remote_addr</span>;
        <span class="hljs-attribute">proxy_set_header</span> X-Forwarded-For   <span class="hljs-variable">$proxy_add_x_forwarded_for</span>;
        <span class="hljs-attribute">proxy_set_header</span> X-Forwarded-Proto <span class="hljs-variable">$scheme</span>;
        <span class="hljs-attribute">proxy_set_header</span> X-Forwarded-Host  <span class="hljs-variable">$host</span>;
        <span class="hljs-attribute">proxy_set_header</span> X-Forwarded-Port  <span class="hljs-variable">$server_port</span>;

        <span class="hljs-comment"># Proxy timeouts</span>
        <span class="hljs-attribute">proxy_connect_timeout</span>              <span class="hljs-number">60s</span>;
        <span class="hljs-attribute">proxy_send_timeout</span>                 <span class="hljs-number">60s</span>;
        <span class="hljs-attribute">proxy_read_timeout</span>                 <span class="hljs-number">60s</span>;
    &#125;
&#125;</code></pre><h2 id="配置-dns-解析">配置 DNS 解析</h2><p>bird-lg-go 的节点 endpiont 生成逻辑是 <code>http://[节点].[endpoint后缀]:8000</code> ，如 <code>http://eu1.dn42.as141776.net:8000</code> ，所以只需要去配置对应的解析。</p><blockquote><p><strong>警告</strong></p><p>建议解析到节点的公网 IP 上，以免 DN42 炸掉时 Looking Glass 也一并炸掉。</p></blockquote><p>配置示例：</p><pre><code class="hljs stylus">eu1<span class="hljs-selector-class">.dn42</span><span class="hljs-selector-class">.as141776</span><span class="hljs-selector-class">.net</span>.  <span class="hljs-number">3600</span>    IN      A       <span class="hljs-number">136.243</span>.<span class="hljs-number">221.96</span>
cn1<span class="hljs-selector-class">.dn42</span><span class="hljs-selector-class">.as141776</span><span class="hljs-selector-class">.net</span>.  <span class="hljs-number">3600</span>    IN      CNAME   home<span class="hljs-selector-class">.baoshuo</span><span class="hljs-selector-class">.ren</span>.</code></pre><h2 id="成果">成果</h2><p><img src="https://s1.baoshuo.ren/2021/05/03/iaFfTWAhpdZGJ9t.png" alt="" loading="lazy"></p>]]></content>
        <author>
            <name>宝硕</name>
            <uri>https://baoshuo.ren</uri>
        </author>
    </entry>
    <entry>
        <title type="html"><![CDATA[初探 DN42 网络]]></title>
        <id>/post/dn42-network/</id>
        <link href="/post/dn42-network/"/>
        <updated>2021-04-04T03:29:32.000Z</updated>
        <summary type="html"><![CDATA[DN42 全称 Decentralized Network 42（42 号去中心网络），是一个大型、去中心化的 BGP 网络。DN42 的目的是模拟一个互联网。它使用了大量在目前互联网骨干上应用的技术（例如 BGP 和递归 DNS），可以很好地模拟一个真实的网络环境。]]></summary>
        <content type="html"><![CDATA[<img src="https://s1.baoshuo.ren/2021/04/03/R6IHLundNjpKxCD.png" width="100%" alt="初探 DN42 网络" /><p>DN42 全称 Decentralized Network 42（42 号去中心网络），是一个大型、去中心化的 BGP 网络。DN42 的目的是模拟一个互联网。它使用了大量在目前互联网骨干上应用的技术（例如 BGP 和递归 DNS），可以很好地模拟一个真实的网络环境。</p><span id="more"></span><p>DN42 适合以下类别的用户：</p><ul><li>想要研究网络技术，练习服务器、路由器等网络设备配置，甚至后续在真实互联网建立 AS 的用户。</li><li>已经拥有真实 AS ，但担心自己<a href="https://blog.cloudflare.com/how-verizon-and-a-bgp-optimizer-knocked-large-parts-of-the-internet-offline-today/" rel="external nofollow noreferrer">配置错误广播出错误路由、干掉半个互联网</a>，希望有个地方测试的用户。</li></ul><p>DN42 不适合以下类别的用户：</p><ul><li>单纯想要保护隐私、规避网络审查的用户</li><li>在网内消耗大量流量，例如用于解锁流媒体服务的用户</li></ul><p>所以，DN42 的使用门槛还是比较高的。这与在真实互联网中一样，你要扮演一个 ISP （互联网服务提供商），注册自己的个人信息， ASN 号码，IPv4 和 IPv6 的地址池，并且使用 BGP 在自己的服务器上广播它们。你还要和其它的用户联系，和他们进行 Peering（对等互联），一步步进入完整的 DN42 网络。</p><hr><p>DN42 在 <code>172.20.0.0/14</code> 和 <code>fd00::/8</code> 上运行，而这两个 IP 段都是分配给内网使用的。换句话说，你在 DN42 上怎么折腾，都不会影响到服务器其它的互联网连接。</p><p>你可以通过加入 <a href="https://t.me/Dn42Chat" rel="external nofollow noreferrer">Telegram 群组</a> 或者 <a href="irc://irc.hackint.org/#dn42" rel="external nofollow noreferrer">IRC 频道</a> 来寻求帮助。</p><p>请注意，DN42 是一个测试网络，所有人都在帮助所有人。即使你不小心搞砸了，也没有人会指责你。</p><p>欢迎在搭建完成自己的内网以后与我进行对等互联，可以访问 <a href="https://dn42.baoshuo.ren" rel="external nofollow noreferrer">dn42.baoshuo.ren</a> 获取更多信息。</p><p>若无特别说明，本文中所使用的系统环境均为 <code>Ubuntu 20.04.2 LTS</code> ，本文中所有使用 <code>&lt;&gt;</code> 包裹的内容均需要自行替换。</p><h2 id="注册-dn42">注册 DN42</h2><p>在注册过程中会大量使用到一些 UNIX 工具（如 Git 、 GPG 等），所以最好使用 Linux 或者 macOS 系统完成整个流程，如果你正在使用 Windows 系统，那么可以使用 <a href="http://aka.ms/wsl" rel="external nofollow noreferrer">WSL</a> 。</p><h3 id="注册前的准备">注册前的准备</h3><ul><li>了解如何编写 RPSL （<a href="https://tools.ietf.org/html/rfc2622/" rel="external nofollow noreferrer">RFC2622</a>） 格式的配置文件。</li><li>了解如何使用 <a href="https://zh.wikipedia.org/wiki/%E6%97%A0%E7%B1%BB%E5%88%AB%E5%9F%9F%E9%97%B4%E8%B7%AF%E7%94%B1" rel="external nofollow noreferrer">CIDR</a> （<a href="https://tools.ietf.org/html/rfc1518" rel="external nofollow noreferrer">RFC1518</a>，<a href="https://tools.ietf.org/html/rfc1519" rel="external nofollow noreferrer">RFC1519</a>） 格式表示 IP 地址块。</li><li>熟悉 <a href="https://dn42.dev" rel="external nofollow noreferrer">DN42 Wiki</a> 中的 <a href="https://dn42.dev/howto/Getting-Started" rel="external nofollow noreferrer">Getting-Started</a> 、 <a href="https://dn42.dev/howto/Address-Space" rel="external nofollow noreferrer">Address Space</a> 页面中的内容。</li><li>在 <a href="https://git.dn42.dev" rel="external nofollow noreferrer">DN42 Git</a> 中有一个注册好的账户。</li><li>会使用英文与他人交流。</li></ul><h3 id="克隆-dn42-注册表-git-仓库">克隆 DN42 注册表 Git 仓库</h3><p>将 <a href="https://git.dn42.dev/dn42/registry" rel="external nofollow noreferrer">dn42/registry</a> 这个仓库 clone 到本地。</p><p>新建一个名为 <code>&lt;用户名&gt;-&lt;日期, YYYYMMDD&gt;/&lt;自定义名称&gt;</code> 的分支。</p><pre><code class="hljs bash">git checkout -b &lt;用户名&gt;-&lt;日期, YYYYMMDD&gt;/register</code></pre><h3 id="注册维护者">注册维护者</h3><p>在仓库的 <code>data/mntner</code> 目录下新建一个文件，命名为 <code>&lt;昵称&gt;-MNT</code> 。</p><p>文件内填入以下内容：</p><pre><code class="hljs rpsl">mntner:             &lt;昵称&gt;-MNT
admin-c:            &lt;昵称&gt;-DN42
tech-c:             &lt;昵称&gt;-DN42
auth:               &lt;身份验证信息&gt;
mnt-by:             &lt;维护者&gt;
source:             DN42</code></pre><p>示例：<a href="https://git.dn42.dev/dn42/registry/src/branch/master/data/mntner/BAOSHUO-MNT" rel="external nofollow noreferrer"><code>data/mntner/BAOSHUO-MNT</code> at dn42/registry@master</a></p><ul><li><code>mntner</code> ：维护者（全称为 Maintainer），这个维护者的名称，与文件名相同。</li><li><code>admin-c</code> ：管理员联系信息（Admin Contact），需要指向 <a href="#%E6%B3%A8%E5%86%8C%E8%81%94%E7%B3%BB%E4%BA%BA">注册联系人</a> 一节中的 <code>person</code> 文件，一般为 <code>&lt;昵称&gt;-DN42</code> 。</li><li><code>tech-c</code> ：技术人员联系信息（Tech Contact），需要指向 <a href="#%E6%B3%A8%E5%86%8C%E8%81%94%E7%B3%BB%E4%BA%BA">注册联系人</a> 一节中的 <code>person</code> 文件，一般为 <code>&lt;昵称&gt;-DN42</code> 。</li><li><code>auth</code> ：身份验证信息，接受 <strong>GPG 公钥</strong> 和 <strong>SSH 公钥</strong> ，可以查看 <a href="https://dn42.dev/howto/Registry-Authentication" rel="external nofollow noreferrer">Registry Authentication</a> 页面获取详细信息。</li><li><code>mnt-by</code> ：由谁维护（全称为 Maintain by），此处需要指向这个维护者本身，即 <code>&lt;昵称&gt;-MNT</code> 。</li><li><code>source</code> ：信息来源，默认为 <code>DN42</code> 。</li></ul><h3 id="注册联系人">注册联系人</h3><p>在仓库的 <code>data/person</code> 目录下新建一个文件，命名为 <code>&lt;昵称&gt;-DN42</code> 。</p><pre><code class="hljs rpsl">person:             &lt;姓名&gt;
contact:            &lt;邮箱&gt;
nic-hdl:            &lt;NIC 句柄&gt;
mnt-by:             &lt;维护者&gt;
source:             DN42</code></pre><p>示例：<a href="https://git.dn42.dev/dn42/registry/src/branch/master/data/person/BAOSHUO-DN42" rel="external nofollow noreferrer"><code>data/person/BAOSHUO-DN42</code> at dn42/registry@master</a></p><ul><li><code>person</code> ：姓名。</li><li><code>contact</code> ：联系方式，一般为邮箱。</li><li><code>nic-hdl</code> ：NIC 句柄（即 <a href="https://en.wikipedia.org/wiki/NIC_handle" rel="external nofollow noreferrer">NIC handle</a>），指向文件本身，与文件名相同。</li><li><code>mnt-by</code> ：由谁维护（全称为 Maintain by），指向你在 <a href="#%E6%B3%A8%E5%86%8C%E7%BB%B4%E6%8A%A4%E8%80%85">注册维护者</a> 一节中注册的的维护者信息。</li><li><code>source</code> ：固定为 <code>DN42</code>。</li></ul><h3 id="注册-asn">注册 ASN</h3><p>在国际互联网上，ASN 范围 <code>4200000000 - 4294967294</code> 是被保留以供私人使用的，而 DN42 占用的就是其中的一块： <code>4242420000 - 4242429999</code> 。目前 DN42 开放注册的 ASN 范围是 <code>4242420000 - 4242423999</code> ，只需要在这个区间里面挑一个没有被他人占用的号码即可。</p><p>DN42 Registry 的管理员 burble 提供了一个在线查看可用 ASN 的工具: <a href="https://explorer.burble.com/free#/asn" rel="external nofollow noreferrer">DN42 Free ASN Explorer</a> 。访问该页面就会随机生成 10 个当前还未注册的 ASN 以便使用。</p><p>在仓库的 <code>data/aut-num</code> 目录下新建一个文件，命名为刚才选中的 AS 号码。</p><pre><code class="hljs rpsl">aut-num:            &lt;AS 号码, 带 AS 前缀&gt;
as-name:            &lt;AS 名称&gt;
descr:              &lt;AS 简介&gt;
admin-c:            &lt;NIC 句柄&gt;
tech-c:             &lt;NIC 句柄&gt;
mnt-by:             &lt;维护者&gt;
source:             DN42</code></pre><p>示例：<a href="https://git.dn42.dev/dn42/registry/src/branch/master/data/aut-num/AS4242420247" rel="external nofollow noreferrer"><code>data/aut-num/AS4242420247</code> at dn42/registry@master</a></p><ul><li><code>aut-num</code> ：AS 号，此处可以使用私有 AS 号码，也可以使用公网 AS 号码（不推荐）。</li><li><code>as-name</code> ：AS 的名称，可以设置为 <code>&lt;昵称&gt;-AS</code> 。</li><li><code>descr</code> ：（选填）AS 简介，随意填写。</li><li><code>admin-c</code> ：管理员联系信息（Admin Contact），指向你在 <a href="#%E6%B3%A8%E5%86%8C%E8%81%94%E7%B3%BB%E4%BA%BA">注册联系人</a> 一节中注册的 NIC 句柄。</li><li><code>tech-c</code> ：技术员联系信息（Tech Contact），指向你在 <a href="#%E6%B3%A8%E5%86%8C%E8%81%94%E7%B3%BB%E4%BA%BA">注册联系人</a> 一节中注册的 NIC 句柄。</li><li><code>mnt-by</code> ：由谁维护（Maintain by），指向你在 <a href="#%E6%B3%A8%E5%86%8C%E7%BB%B4%E6%8A%A4%E8%80%85">注册维护者</a> 一节中注册的的维护者信息。</li><li><code>source</code> ：如果使用私有 AS 号码则此处填写 <code>DN42</code> ，否则填写 ASN 所对应的 RIR 名称。</li></ul><h3 id="注册-ipv4-地址块">注册 IPv4 地址块</h3><p><em>如果您想在 DN42 上创建一个 IPv6 Only 网络，请不要注册 IPv4 地址块，并忽略 <a href="#%E6%B7%BB%E5%8A%A0%E8%B7%AF%E7%94%B1%E8%AE%B0%E5%BD%95">添加路由记录</a> 一节中的 IPv4 部分。</em></p><p>在国际互联网上， <code>172.16.0.0/12</code> 是由 <a href="https://tools.ietf.org/html/rfc1918" rel="external nofollow noreferrer">RFC1918</a> 规定的由专用网络使用的 IP 地址块，而 DN42 占用的就是其中的一块： <code>172.20.0.0/14</code> 。目前 DN42 开放注册的地址块范围可以在 <a href="https://dn42.dev/howto/Address-Space#ipv4-address-space" rel="external nofollow noreferrer">Address Space</a> 页面上查看。</p><p>DN42 Registry 的管理员 burble 提供了一个在线查看可用 IPv4 地址块的网站，点击 <a href="https://explorer.burble.com/free#/4" rel="external nofollow noreferrer">DN42 Free IPv4 Explorer</a> 即可随机生成 10 个当前还未注册的 IPv4 地址块。</p><p>和在真实互联网上一样，DN42 的 IPv4 地址资源也是十分紧缺的，因此 IPv4 的申请原则是「够用就好」。如果节点数量足够少，只申请 <code>/28</code> 或 <code>/29</code> 大小的地址块就够用了。</p><p>在仓库的 <code>data/inetnum</code> 目录下新建一个文件，命名为 IP 地址块的 CIDR 格式，并使用 <code>_</code> 代替 <code>/</code>。</p><pre><code class="hljs rpsl">inetnum:            &lt;起始 IP 地址&gt; - &lt;结束 IP 地址&gt;
cidr:               &lt;IP 地址块的 CIDR 格式&gt;
netname:            &lt;IP 地址块名称&gt;
descr:              &lt;IP 地址块简介&gt;
country:            &lt;IP 地址块所属国家&gt;
admin-c:            &lt;NIC 句柄&gt;
tech-c:             &lt;NIC 句柄&gt;
mnt-by:             &lt;维护者&gt;
status:             ASSIGNED
source:             DN42</code></pre><p>示例：<a href="https://git.dn42.dev/dn42/registry/src/branch/master/data/inetnum/172.23.250.64_26" rel="external nofollow noreferrer"><code>data/inetnum/172.23.250.64_26</code> at dn42/registry@master</a></p><ul><li><code>inetnum</code> ：这个地址块的范围。</li><li><code>cidr</code> ：以 CIDR 格式表示的这个地址块的范围，含义与 <code>inetnum</code> 相同。</li><li><code>netname</code> ：这个地址块的名称。可以设置为 <code>&lt;昵称&gt;-IPV4</code> 。</li><li><code>descr</code> ：（选填）这个地址块的简介。</li><li><code>nserver</code> ：（选填）IP 地址反向解析的 DNS 服务器。</li><li><code>country</code> ：你的 <a href="https://zh.wikipedia.org/wiki/ISO_3166" rel="external nofollow noreferrer">ISO 3166</a> 国家代码，填 <code>CN</code> 代表中国大陆地区。</li><li><code>admin-c</code> ：管理员联系信息（Admin Contact），指向你在 <a href="#%E6%B3%A8%E5%86%8C%E8%81%94%E7%B3%BB%E4%BA%BA">注册联系人</a> 一节中注册的 NIC 句柄。</li><li><code>tech-c</code> ：技术员联系信息（Tech Contact），指向你在 <a href="#%E6%B3%A8%E5%86%8C%E8%81%94%E7%B3%BB%E4%BA%BA">注册联系人</a> 一节中注册的 NIC 句柄。</li><li><code>mnt-by</code> ：由谁维护（Maintain by），指向你在 <a href="#%E6%B3%A8%E5%86%8C%E7%BB%B4%E6%8A%A4%E8%80%85">注册维护者</a> 一节中注册的的维护者信息。</li><li><code>status</code> ：固定为 <code>ASSIGNED</code>。</li><li><code>source</code> ：固定为 <code>DN42</code>。</li></ul><h3 id="注册-ipv6-地址块">注册 IPv6 地址块</h3><p>在国际互联网上， <code>fc00::/7</code> 是由 <a href="https://tools.ietf.org/html/rfc4193" rel="external nofollow noreferrer">RFC4193</a> 定义的 <a href="https://en.wikipedia.org/wiki/Unique_local_address" rel="external nofollow noreferrer">唯一本地地址</a>，而 DN42 占用的就是其中的一块： <code>fd00::/8</code> 。目前 DN42 开放注册的地址块范围可以在 <a href="https://dn42.dev/howto/Address-Space#ipv6-address-space" rel="external nofollow noreferrer">Address Space</a> 页面上查看。</p><p>DN42 Registry 的管理员 burble 提供了一个在线查看可用 IPv6 地址块的网站，点击 <a href="https://explorer.burble.com/free#/6" rel="external nofollow noreferrer">DN42 Free IPv6 Explorer</a> 即可随机生成 10 个当前还未注册的 IPv6 地址块。</p><p>在仓库的 <code>data/inet6num</code> 目录下新建一个文件，命名为 IPv6 地址块的 CIDR 格式，并使用 <code>_</code> 代替 <code>/</code>。</p><pre><code class="hljs rpsl">inet6num:           &lt;起始 IPv6 地址&gt; - &lt;结束 IPv6 地址&gt;
cidr:               &lt;IPv6 地址块的 CIDR 格式&gt;
netname:            &lt;IPv6 地址块名称&gt;
descr:              &lt;IPv6 地址块简介&gt;
country:            &lt;IPv6 地址块所属国家&gt;
admin-c:            &lt;NIC 句柄&gt;
tech-c:             &lt;NIC 句柄&gt;
mnt-by:             &lt;维护者&gt;
status:             ASSIGNED
source:             DN42</code></pre><p>示例：<a href="https://git.dn42.dev/dn42/registry/src/branch/master/data/inet6num/fd42:4242:247::_48" rel="external nofollow noreferrer"><code>data/inet6num/fd42:4242:247::_48</code> at dn42/registry@master</a></p><ul><li><code>inet6num</code> ：这个地址块的范围。</li><li><code>cidr</code> ：使用 CIDR 格式表示的这个地址块的范围，含义与 <code>inet6num</code> 相同。</li><li><code>netname</code> ：这个地址块的名称。可以设置为 <code>&lt;昵称&gt;-IPV6</code> 。</li><li><code>descr</code> ：（选填）这个地址块的简介。</li><li><code>nserver</code> ：（选填）IP 地址反向解析的 DNS 服务器。</li><li><code>country</code> ：你的 <a href="https://zh.wikipedia.org/wiki/ISO_3166" rel="external nofollow noreferrer">ISO 3166</a> 国家代码，填 <code>CN</code> 代表中国大陆地区。</li><li><code>admin-c</code> ：管理员联系信息（Admin Contact），指向你在 <a href="#%E6%B3%A8%E5%86%8C%E8%81%94%E7%B3%BB%E4%BA%BA">注册联系人</a> 一节中注册的 NIC 句柄。</li><li><code>tech-c</code> ：技术员联系信息（Tech Contact），指向你在 <a href="#%E6%B3%A8%E5%86%8C%E8%81%94%E7%B3%BB%E4%BA%BA">注册联系人</a> 一节中注册的 NIC 句柄。</li><li><code>mnt-by</code> ：由谁维护（Maintain by），指向你在 <a href="#%E6%B3%A8%E5%86%8C%E7%BB%B4%E6%8A%A4%E8%80%85">注册维护者</a> 一节中注册的的维护者信息。</li><li><code>status</code> ：固定为 <code>ASSIGNED</code>。</li><li><code>source</code> ：固定为 <code>DN42</code>。</li></ul><h3 id="添加路由记录">添加路由记录</h3><p>在仓库的 <code>data/route</code> 目录下新建一个文件，命名为 IP 地址块的 CIDR 格式，并使用 <code>_</code> 代替 <code>/</code>。</p><pre><code class="hljs rpsl">route:              &lt;IP 地址块的 CIDR 格式&gt;
descr:              &lt;简介&gt;
origin:             &lt;AS 号码, 带 AS 前缀&gt;
mnt-by:             &lt;维护者&gt;
source:             DN42</code></pre><ul><li><code>route</code> ：这个 IPv4 地址块的范围，CIDR 格式。</li><li><code>descr</code> ：（选填）路由简介。</li><li><code>origin</code> ：填写你的 AS 号码。</li><li><code>mnt-by</code> ：由谁维护（Maintain by），指向你在 <a href="#%E6%B3%A8%E5%86%8C%E7%BB%B4%E6%8A%A4%E8%80%85">注册维护者</a> 一节中注册的的维护者信息。</li><li><code>source</code> ：固定为 <code>DN42</code>。</li></ul><p>如需添加 IPv6 路由，将本节所述的 <code>route</code> 改为 <code>route6</code> 即可，此处不再赘述。</p><h3 id="上传更改到-dn42-注册表">上传更改到 DN42 注册表</h3><p>完成以上步骤之后，使用 <code>git diff</code> 查看文件变动，检查无误后，使用 <code>git add .</code> 暂存。</p><p><img src="https://s1.baoshuo.ren/2021/08/14/RhjwYHFGcaKUSye.png" alt="" loading="lazy"></p><p>运行仓库根目录下的 <code>./check-my-stuff &lt;维护者&gt;</code> 检查文件内容是否有误，确定无误后，提交。</p><p>在提交时，如果需要使用 GPG 签名，需要在添加 <code>-S</code> 参数，如 <code>git commit -S</code> ；如果使用 SSH 签名，请直接使用 <code>git commit</code> 进行提交，待提交后再进行签名工作。</p><p>使用下面的命令进行签名：</p><pre><code class="hljs bash">./sign-my-commit --ssh --key &lt;SSH 私钥文件&gt; &lt;维护者&gt;</code></pre><p>之后使用下面的命令上传即可：</p><pre><code class="hljs bash">git push --set-upstream origin &lt;用户名&gt;-&lt;日期, YYYYMMDD&gt;/register</code></pre><p><img src="https://s1.baoshuo.ren/2021/04/04/1YwNjs8uvOJMFoq.png" alt="" loading="lazy"></p><p>上传后在 DN42 Git 中切换到自己的分支，并创建一个合并请求，等待管理员审核。</p><h3 id="注意事项">注意事项</h3><ol><li>各个项目的键和值之间有一长串空格，键、冒号与空格的总长度必须是 20 个字符，且不能随意修改。为了编辑时的方便，注册表中提供了一个脚本 <code>fmt-my-stuff</code> ，只需要使用 <code>./fmt-my-stuff &lt;维护者&gt;</code> 即可自动完成此步骤。</li><li>DN42 Registry 的工作语言是英语。请使用英语完成全部流程，以免出现不必要的麻烦。</li><li>请认真对待管理员提出的更改请求，按照要求完成全部修改后直接上传到原分支下即可，无需再新开合并请求。</li><li>推荐使用随机的 IPv4 与 IPv6 地址块，避免与其他网络重复。请明白，DN42 并不是这些网络资源的权威注册机构。</li></ol><h2 id="dn42-bird2-使用入门">DN42 BIRD2 使用入门</h2><p>如无特别说明，本部分中所使用的 BIRD 版本为 <code>2.0.7</code> 。</p><h3 id="安装-bird2">安装 BIRD2</h3><pre><code class="hljs bash">apt update
apt install bird2 -y</code></pre><p>一般情况下，执行此命令即可自动安装 BIRD2 并启动系统服务。</p><h3 id="编写-bird-配置文件">编写 BIRD 配置文件</h3><p>对于刚刚加入 DN42 网络的新人来说，推荐使用 <a href="https://dn42.dev/howto/Bird2#example-configuration" rel="external nofollow noreferrer">howto/Bird2 - DN42 Wiki</a> 中的示例配置以节省配置时间。</p><p>这套配置默认使用了 Multi Protocol BGP ，如果不想使用此功能请自行编写配置文件，如果没有 DN42 IPv4 地址需要去掉文件中的 IPv4 部分。</p><p>将以下配置写入到 <code>/etc/bird/bird.conf</code> 中：</p><pre><code class="hljs pgsql">define OWNAS       = &lt;<span class="hljs-keyword">AS</span> 号&gt;;
define OWNIP       = &lt;DN42 IPv4 地址&gt;;
define OWNIPv6     = &lt;DN42 IPv6 地址&gt;;
define OWNNET      = &lt;DN42 IPv4 地址块, <span class="hljs-type">CIDR</span> 格式&gt;;
define OWNNETv6    = &lt;DN42 IPv6 地址块, <span class="hljs-type">CIDR</span> 格式&gt;;
define OWNNETSET   = [ &lt;DN42 IPv4 地址块, <span class="hljs-type">CIDR</span> 格式&gt;+ ];
define OWNNETSETv6 = [ &lt;DN42 IPv6 地址块, <span class="hljs-type">CIDR</span> 格式&gt;+ ];

router id OWNIP;

protocol device &#123;
    scan <span class="hljs-type">time</span> <span class="hljs-number">10</span>;
&#125;

<span class="hljs-keyword">function</span> is_self_net() &#123;
    <span class="hljs-keyword">return</span> net ~ OWNNETSET;
&#125;

<span class="hljs-keyword">function</span> is_self_net_v6() &#123;
    <span class="hljs-keyword">return</span> net ~ OWNNETSETv6;
&#125;

<span class="hljs-keyword">function</span> is_valid_network() &#123;
    <span class="hljs-keyword">return</span> net ~ [
        <span class="hljs-number">172.20</span><span class="hljs-number">.0</span><span class="hljs-number">.0</span>/<span class="hljs-number">14</span>&#123;<span class="hljs-number">21</span>,<span class="hljs-number">29</span>&#125;, # dn42
        <span class="hljs-number">172.20</span><span class="hljs-number">.0</span><span class="hljs-number">.0</span>/<span class="hljs-number">24</span>&#123;<span class="hljs-number">28</span>,<span class="hljs-number">32</span>&#125;, # dn42 Anycast
        <span class="hljs-number">172.21</span><span class="hljs-number">.0</span><span class="hljs-number">.0</span>/<span class="hljs-number">24</span>&#123;<span class="hljs-number">28</span>,<span class="hljs-number">32</span>&#125;, # dn42 Anycast
        <span class="hljs-number">172.22</span><span class="hljs-number">.0</span><span class="hljs-number">.0</span>/<span class="hljs-number">24</span>&#123;<span class="hljs-number">28</span>,<span class="hljs-number">32</span>&#125;, # dn42 Anycast
        <span class="hljs-number">172.23</span><span class="hljs-number">.0</span><span class="hljs-number">.0</span>/<span class="hljs-number">24</span>&#123;<span class="hljs-number">28</span>,<span class="hljs-number">32</span>&#125;, # dn42 Anycast
        <span class="hljs-number">172.31</span><span class="hljs-number">.0</span><span class="hljs-number">.0</span>/<span class="hljs-number">16</span>+,       # ChaosVPN
        <span class="hljs-number">10.100</span><span class="hljs-number">.0</span><span class="hljs-number">.0</span>/<span class="hljs-number">14</span>+,       # ChaosVPN
        <span class="hljs-number">10.127</span><span class="hljs-number">.0</span><span class="hljs-number">.0</span>/<span class="hljs-number">16</span>&#123;<span class="hljs-number">16</span>,<span class="hljs-number">32</span>&#125;, # neonetwork
        <span class="hljs-number">10.0</span><span class="hljs-number">.0</span><span class="hljs-number">.0</span>/<span class="hljs-number">8</span>&#123;<span class="hljs-number">15</span>,<span class="hljs-number">24</span>&#125;     # Freifunk.net
    ];
&#125;

roa4 <span class="hljs-keyword">table</span> dn42_roa;
roa6 <span class="hljs-keyword">table</span> dn42_roa_v6;

protocol static &#123;
    roa4 &#123; <span class="hljs-keyword">table</span> dn42_roa; &#125;;
    <span class="hljs-keyword">include</span> &quot;/etc/bird/roa_dn42.conf&quot;;
&#125;;

protocol static &#123;
    roa6 &#123; <span class="hljs-keyword">table</span> dn42_roa_v6; &#125;;
    <span class="hljs-keyword">include</span> &quot;/etc/bird/roa_dn42_v6.conf&quot;;
&#125;;

<span class="hljs-keyword">function</span> is_valid_network_v6() &#123;
  <span class="hljs-keyword">return</span> net ~ [
    fd00::/<span class="hljs-number">8</span>&#123;<span class="hljs-number">44</span>,<span class="hljs-number">64</span>&#125; # ULA address space <span class="hljs-keyword">as</span> per RFC <span class="hljs-number">4193</span>
  ];
&#125;

protocol kernel &#123;
    scan <span class="hljs-type">time</span> <span class="hljs-number">20</span>;

    ipv6 &#123;
        <span class="hljs-keyword">import</span> <span class="hljs-keyword">none</span>;
        export <span class="hljs-keyword">filter</span> &#123;
            <span class="hljs-keyword">if</span> source = RTS_STATIC <span class="hljs-keyword">then</span> reject;
            krt_prefsrc = OWNIPv6;
            accept;
        &#125;;
    &#125;;
&#125;;

protocol kernel &#123;
    scan <span class="hljs-type">time</span> <span class="hljs-number">20</span>;

    ipv4 &#123;
        <span class="hljs-keyword">import</span> <span class="hljs-keyword">none</span>;
        export <span class="hljs-keyword">filter</span> &#123;
            <span class="hljs-keyword">if</span> source = RTS_STATIC <span class="hljs-keyword">then</span> reject;
            krt_prefsrc = OWNIP;
            accept;
        &#125;;
    &#125;;
&#125;

protocol static &#123;
    route OWNNET reject;

    ipv4 &#123;
        <span class="hljs-keyword">import</span> <span class="hljs-keyword">all</span>;
        export <span class="hljs-keyword">none</span>;
    &#125;;
&#125;

protocol static &#123;
    route OWNNETv6 reject;

    ipv6 &#123;
        <span class="hljs-keyword">import</span> <span class="hljs-keyword">all</span>;
        export <span class="hljs-keyword">none</span>;
    &#125;;
&#125;

<span class="hljs-keyword">template</span> bgp dnpeers &#123;
    <span class="hljs-keyword">local</span> <span class="hljs-keyword">as</span> OWNAS;
    <span class="hljs-type">path</span> metric <span class="hljs-number">1</span>;

    ipv4 &#123;
        <span class="hljs-keyword">import</span> <span class="hljs-keyword">filter</span> &#123;
            <span class="hljs-keyword">if</span> is_valid_network() &amp;&amp; !is_self_net() <span class="hljs-keyword">then</span> &#123;
                <span class="hljs-keyword">if</span> (roa_check(dn42_roa, net, bgp_path.last) != ROA_VALID) <span class="hljs-keyword">then</span> &#123;
                    print &quot;[dn42] ROA check failed for &quot;, net, &quot; ASN &quot;, bgp_path.last;
                    reject;
                &#125;
                accept;
            &#125;
            reject;
        &#125;;

        export <span class="hljs-keyword">filter</span> &#123;
            <span class="hljs-keyword">if</span> is_valid_network() &amp;&amp; source ~ [RTS_STATIC, RTS_BGP] <span class="hljs-keyword">then</span> accept;
            reject;
        &#125;;
        <span class="hljs-keyword">import</span> <span class="hljs-keyword">limit</span> <span class="hljs-number">1000</span> action block;
    &#125;;

    ipv6 &#123;
        <span class="hljs-keyword">import</span> <span class="hljs-keyword">filter</span> &#123;
            <span class="hljs-keyword">if</span> is_valid_network_v6() &amp;&amp; !is_self_net_v6() <span class="hljs-keyword">then</span> &#123;
                <span class="hljs-keyword">if</span> (roa_check(dn42_roa_v6, net, bgp_path.last) != ROA_VALID) <span class="hljs-keyword">then</span> &#123;
                    print &quot;[dn42] ROA check failed for &quot;, net, &quot; ASN &quot;, bgp_path.last;
                    reject;
                &#125;
                accept;
            &#125;
            reject;
        &#125;;
        export <span class="hljs-keyword">filter</span> &#123;
            <span class="hljs-keyword">if</span> is_valid_network_v6() &amp;&amp; source ~ [RTS_STATIC, RTS_BGP] <span class="hljs-keyword">then</span> accept;
            reject;
        &#125;;
        <span class="hljs-keyword">import</span> <span class="hljs-keyword">limit</span> <span class="hljs-number">1000</span> action block;
    &#125;;
&#125;


<span class="hljs-keyword">include</span> &quot;/etc/bird/peers/*&quot;;</code></pre><p>然后在 <code>/etc/bird</code> 目录下创建一个文件夹，命名为 <code>peers</code> ，以便后续存储配置文件使用。</p><p>如果想更深入的学习如何编写 BIRD 配置文件，推荐查看 <a href="https://github.com/moesoha/bird-bgp-kickstart" rel="external nofollow noreferrer">BIRD 与 BGP 的新手开场</a> 和 <a href="https://bird.network.cz/?get_doc&amp;f=bird.html&amp;v=20" rel="external nofollow noreferrer">BIRD 官方文档</a> 。</p><h3 id="下载-roa-配置文件">下载 ROA 配置文件</h3><pre><code class="hljs bash">wget -4 -O /tmp/dn42_roa.conf https://dn42.burble.com/roa/dn42_roa_bird2_4.conf &amp;&amp; <span class="hljs-built_in">mv</span> -f /tmp/dn42_roa.conf /etc/bird/dn42_roa.conf
wget -4 -O /tmp/dn42_roa_v6.conf https://dn42.burble.com/roa/dn42_roa_bird2_6.conf &amp;&amp; <span class="hljs-built_in">mv</span> -f /tmp/dn42_roa_v6.conf /etc/bird/dn42_roa_v6.conf</code></pre><p>使用此命令即可将 ROA 文件下载到本机以供使用。</p><p>还需要将此命令添加为定时任务，推荐设置为每小时运行一次，否则不会更新到最新的 ROA ，每次更新后都需要使用 <code>birdc configure</code> 命令重载 BIRD 配置。</p><h3 id="重新加载-bird-配置">重新加载 BIRD 配置</h3><pre><code class="hljs bash">birdc configure</code></pre><p>使用该命令重新加载 BIRD 配置，并使用 <code>birdc show protocol</code> 查看状态。</p><p><img src="https://s1.baoshuo.ren/2021/08/16/ZSPe6a3fpuDATG2.png" alt="" loading="lazy"></p><h2 id="dn42-wireguard-使用入门">DN42 WireGuard 使用入门</h2><p>WireGuard 是一种简单易用、速度快、现代化的 VPN ，它利用了最先进的加密技术，并使用 UDP 协议传输数据。WireGuard 设计为通用 VPN ，可在嵌入式设备和超级计算机上运行，​​ 适用于许多不同的环境。WireGuard 起初是专为 Linux 编写并发布的，后来被移植到各个平台上。在 <a href="http://WireGuard.com" rel="external nofollow noreferrer">WireGuard.com</a> 上可以找到它的 <a href="https://www.wireguard.com/papers/wireguard.pdf" rel="external nofollow noreferrer">技术白皮书</a> 。</p><h3 id="安装-wireguard">安装 WireGuard</h3><pre><code class="hljs bash">apt update
apt install wireguard -y</code></pre><p>一般情况下，执行此命令即可直接安装 WireGuard 和 WireGuard Tools ，无需额外操作。</p><h3 id="生成公钥与私钥">生成公钥与私钥</h3><pre><code class="hljs bash">wg genkey | <span class="hljs-built_in">tee</span> privatekey | wg pubkey &gt; publickey</code></pre><p>使用此命令即可在当前目录下生成两个名叫 <code>privatekey</code> 和 <code>publickey</code> 的文件，分别代表私钥和公钥。</p><h3 id="搭建-wireguard-隧道">搭建 WireGuard 隧道</h3><p>搭建 WireGuard 隧道非常简便，只需要生成一对公钥与私钥并与对等端交换公钥即可。</p><p>如果需要通过 WireGuard 隧道建立 BGP 会话，不能使用 WireGuard 内建的多 Peer 功能，必须为每个对等端创建一条隧道。</p><p>在 <code>/etc/wireguard</code> 目录下新建一个名为 <code>&lt;隧道名&gt;.conf</code> 的文件：</p><pre><code class="hljs ini"><span class="hljs-section">[Interface]</span>
<span class="hljs-attr">PrivateKey</span> = &lt;私钥&gt;
<span class="hljs-attr">ListenPort</span> = &lt;监听端口&gt;
<span class="hljs-attr">PostUp</span>     = ip address add &lt;链路本地地址&gt;/<span class="hljs-number">64</span> dev %i
<span class="hljs-attr">PostUp</span>     = ip addr add &lt;本地 IPv6 地址&gt;/<span class="hljs-number">128</span> peer &lt;对端 IPv6 地址&gt;/<span class="hljs-number">128</span> dev %i
<span class="hljs-attr">PostUp</span>     = ip addr add &lt;本地 IPv4 地址&gt;/<span class="hljs-number">32</span> peer &lt;对端 IPv4 地址&gt;/<span class="hljs-number">32</span> dev %i
<span class="hljs-attr">Table</span>      = <span class="hljs-literal">off</span></code></pre><ul><li><code>PrivateKey</code> ：私钥。</li><li><code>ListenPort</code> ：监听端口。</li><li>第一个 <code>PostUp</code> ：（可选，推荐）添加链路本地地址。</li><li>第二个 <code>PostUp</code> ：（可选）添加本地和对等端的 DN42 IPv6 地址。</li><li>第三个 <code>PostUp</code> ：（可选）添加本地和对等端的 DN42 IPv4 地址。</li><li><code>Table</code> ：必须设定为 <code>off</code> （不导入系统路由表），否则会导致系统断网。</li></ul><p>当使用链路本地地址建立 BGP 会话时，可以不设置 DN42 IPv4 和 DN42 IPv6 地址，但是机器上必须有一张网卡上绑定了本机的 DN42 IPv4 和 DN42 IPv6 地址。同理，如果不使用链路本地地址建立 BGP 会话则无需添加链路本地地址。</p><pre><code class="hljs ini"><span class="hljs-section">[Peer]</span>
<span class="hljs-attr">PublicKey</span>           = &lt;对端公钥&gt;
<span class="hljs-attr">PresharedKey</span>        = &lt;对端预共享密钥&gt;
<span class="hljs-attr">Endpoint</span>            = &lt;对端 IP/域名 和 端口号&gt;
<span class="hljs-attr">PersistentKeepalive</span> = <span class="hljs-number">30</span>
<span class="hljs-attr">AllowedIPs</span>          = <span class="hljs-number">10.0</span>.<span class="hljs-number">0.0</span>/<span class="hljs-number">8</span>, <span class="hljs-number">172.20</span>.<span class="hljs-number">0.0</span>/<span class="hljs-number">14</span>, <span class="hljs-number">172.31</span>.<span class="hljs-number">0.0</span>/<span class="hljs-number">16</span>, fd00::/<span class="hljs-number">8</span>, fe80::/<span class="hljs-number">64</span></code></pre><ul><li><code>PublicKey</code> ：对端公钥。</li><li><code>PresharedKey</code> ：（可选）对端预共享密钥。</li><li><code>Endpoint</code> ：（可选）对端的连接域名/IP 及端口号。<br>如果对端没有公网 IP 地址，需要本地设置为被动模式则无需填写此项。</li><li><code>PersistentKeepalive</code> ：（可选）每隔多少秒发送一次握手信息防止连接被中断并更新对端 IP 。<br>如果本地没有公网 IP 地址，必须配置此项。</li><li><code>AllowedIPs</code> ：允许使用 WireGuard 转发流量的 IP 地址段。</li></ul><p>之后使用 <code>wg-quick up &lt;隧道名&gt;</code> 来启动隧道即可。</p><p>如需开机自启，可以在测试无误后执行 <code>systemctl enable wg-quick@&lt;隧道名&gt;</code> 。</p><h3 id="检测隧道状态">检测隧道状态</h3><pre><code class="hljs bash">wg show &lt;隧道名&gt;</code></pre><p>使用该命令即可查看隧道状态。</p><p><img src="https://s1.baoshuo.ren/2021/08/16/wxgUJNHnQAXFMdS.png" alt="" loading="lazy"></p><p>如上图所示，当 <code>latest handshake</code> 时间较近且 <code>transfer</code> 有收有发时可以认为隧道正常。</p><p>如需查看所有隧道的状态，直接使用 <code>wg</code> 命令即可。</p><h2 id="与其他网络进行对等互联">与其他网络进行对等互联</h2><h3 id="系统配置">系统配置</h3><p>在 DN42 网络中，没有绝对意义上的客户端，每个人都可能是他人的路由器，经常会出现数据包的来源网卡与回复使用的网卡不一致的情况，因此需要打开 Linux 内核的数据包转发功能，具体操作如下：</p><pre><code class="hljs bash"><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;net.ipv4.ip_forward=1&quot;</span> &gt;&gt; /etc/sysctl.conf
<span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;net.ipv6.conf.default.forwarding=1&quot;</span> &gt;&gt; /etc/sysctl.conf
<span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;net.ipv6.conf.all.forwarding=1&quot;</span> &gt;&gt; /etc/sysctl.conf
sysctl -p</code></pre><p>同时，也需要关闭 Linux 内核的 <code>rp_filter</code> 的严格模式，具体操作如下：</p><pre><code class="hljs bash"><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;net.ipv4.conf.default.rp_filter=0&quot;</span> &gt;&gt; /etc/sysctl.conf
<span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;net.ipv4.conf.all.rp_filter=0&quot;</span> &gt;&gt; /etc/sysctl.conf
sysctl -p</code></pre><p>除此之外，还需要关闭一些自动化的配置 iptables 防火墙的工具，如 UFW 。</p><h3 id="搭建-wireguard-隧道-2">搭建 WireGuard 隧道</h3><p>请参考 <a href="#DN42-WireGuard-%E4%BD%BF%E7%94%A8%E5%85%A5%E9%97%A8">DN42 WireGuard 使用入门</a> 一节。</p><h3 id="配置-bgp-会话">配置 BGP 会话</h3><p>在 <code>/etc/bird/peers</code> 目录下新建一个文件，命名为 <code>&lt;名字&gt;.conf</code> 。</p><p>如果使用链路本地地址进行 Peer 的话，需要按照下面的配置示例进行配置：</p><pre><code class="hljs bird">protocol bgp &lt;名字&gt; from dnpeers &#123;
    neighbor &lt;对端链路本地地址&gt; % &#x27;&lt;对端 WireGuard 隧道名&gt;&#x27; as &lt;对端 ASN&gt;;
    source address &lt;本地的链路本地地址&gt;;
&#125;</code></pre><p>否则按照下面的配置示例进行配置：</p><pre><code class="hljs bird">protocol bgp &lt;名字&gt; from dnpeers &#123;
    neighbor &lt;对端 IPv6 地址&gt; as &lt;对端 ASN&gt;;
&#125;</code></pre><p>然后使用 <code>birdc configure</code> 重载配置即可。</p><h2 id="更新日志">更新日志</h2><ul><li>2021-04-04 第一版 <sup>（2021 年 8 月 10 日存档于 <a href="https://web.archive.org/web/20210810062825/https://blog.baoshuo.ren/post/dn42-network/" rel="external nofollow noreferrer">互联网档案馆</a>）</sup></li><li>2021-08-14 第二版</li></ul><h2 id="参考资料-6">参考资料</h2><ol><li><a href="https://dn42.dev/howto/Getting-Started" rel="external nofollow noreferrer">Getting Started - DN42 Wiki</a></li><li><a href="https://git.dn42.dev/dn42/registry/src/branch/master/README.md" rel="external nofollow noreferrer">Guide for creating a Pull Request - dn42/registry - DN42 Git</a></li><li><a href="https://lantian.pub/article/modify-website/dn42-experimental-network-2020.lantian/" rel="external nofollow noreferrer">DN42 实验网络介绍及注册教程（2020-10-01 更新） - Lan Tian @ Blog</a></li><li><a href="https://datatracker.ietf.org/" rel="external nofollow noreferrer">IETF Datatracker</a></li><li><a href="https://en.wikipedia.org/wiki/Unique_local_address" rel="external nofollow noreferrer">Unique local address - Wikipedia</a></li><li><a href="https://github.com/moesoha/bird-bgp-kickstart" rel="external nofollow noreferrer">BIRD 与 BGP 的新手开场 - Soha Jin - GitHub</a></li></ol>]]></content>
        <author>
            <name>宝硕</name>
            <uri>https://baoshuo.ren</uri>
        </author>
    </entry>
    <entry>
        <title type="html"><![CDATA[年轻人的第一个 ASN]]></title>
        <id>/post/my-own-asn/</id>
        <link href="/post/my-own-asn/"/>
        <updated>2021-03-20T17:06:09.000Z</updated>
        <summary type="html"><![CDATA[很久之前就有了这样的一个想法：拥有一个自己的 ASN 。2021 年的寒假末尾，我终于找到了一个肯给我这个未成年人申请 ASN 的 LIR 。]]></summary>
        <content type="html"><![CDATA[<img src="https://s1.baoshuo.ren/2021/02/28/XMjiBGVdHmARW48.png" width="100%" alt="年轻人的第一个 ASN" /><p>很久之前就有了这样的一个想法：拥有一个自己的 ASN 。2021 年的寒假末尾，我终于找到了一个肯给我这个未成年人申请 ASN 的 LIR 。</p><span id="more"></span><p>于是这个世界上又多了一个祸害公网的人。</p><p><strong>2021-12-09 更新</strong>：将 IP 广播部分直接链接到《<a href="/post/dn42-network">初探 DN42 网络</a>》中的「DN42 BIRD2 使用入门」一节，以及一些不大不小的修改。</p><h2 id="注册-asn-2">注册 ASN</h2><p>我找了某个 LIR 注册的 APNIC 的 ASN ，下号用时 3 个工作日。</p><p>需要提供的信息有这些（带有 <code>[保密]</code> 标签的是非公开信息，只有你的 LIR 和 APINC 会知道）：</p><ol><li>[保密] 身份证明材料</li><li>主标识</li><li>联系人邮箱</li><li>noc 邮箱</li><li>abuse 邮箱</li><li>国家</li><li>联系人地址</li><li>联系人姓名</li><li>联系人电话</li><li>ASN 的标识</li><li>ASN 的全名</li><li>ASN 所属国家</li><li>[保密] 两个上游 ASN</li><li>[保密] ASN 将要部署在的物理位置</li></ol><p>然后等了 3 个工作日，我的 ASN 申请终于通过审核并下号了。</p><p>需要注意的是 APNIC 每半年会向联系人邮箱发送一封验证邮件，所以邮箱需要保持畅通，并且及时查看新邮件。</p><h2 id="申请-vultr-的-bgp-广播功能">申请 Vultr 的 BGP 广播功能</h2><p>Vultr 的 BGP 广播功能可以称得上是「新手友好」的了。Vultr 良好的过滤系统保证了一般情况下即使发送了错误的路由表也不会漏到公网去，不怕搞炸，方便学习时使用。</p><p>点击 <a href="https://my.vultr.com/bgp/" rel="external nofollow noreferrer">https://my.vultr.com/bgp/</a> 进入 Vultr BGP 广播功能的开通页面。</p><p><img src="https://s1.baoshuo.ren/2021/03/12/aYNdpciAb217wuP.png" alt="" loading="lazy"></p><p>点击页面中的 <strong>Get Started</strong> 进入 BGP 开通申请页面。</p><p><img src="https://s1.baoshuo.ren/2021/03/12/Sb6AoPXTuJ3YIKn.png" alt="" loading="lazy"></p><ol><li>将 <strong>I have my own IP space</strong> 和 <strong>I have my own ASN</strong> 设置为 YES 。</li><li>在 <strong>My ASN</strong> 处填写 ASN （不含 <code>AS</code> 前缀）。</li><li>在 <strong>BGP Password</strong> 处填写你想要的 BGP 密码。</li><li>在 <strong>IP Prefixes</strong> 处填写你的 IP 前缀（CIDR 格式）。</li><li><strong>Routes we shoule send you</strong> 选择 <strong>Full Table</strong> 。</li><li>LOA 按照下方提供的模板照抄即可。</li></ol><p>然后点击 <strong>Setup</strong> 即可。</p><details><summary>LOA 模板</summary><p>这是一篇 LOA 模板，照抄即可。</p><pre><code class="hljs text">AUTHORIZATION LETTER

[日期, 如 Feb 27, 2021]

To whom it may concern,

This letter serves as authorization for [服务商公司名, 如 Vultr] with [ASN, 如 AS2333] to announce the following IP address blocks:

[IP SPACE / ASN / SUBNET]
[IP SPACE / ASN / SUBNET]
[...]

As a representative of the company [公司名称] that is the owner of the subnet and/or ASN, I hereby declare that I&#x27;m authorized to represent and sign for this LOA.

Should you have questions about this request, email me at [邮箱], or call: [电话号码]

From,

[姓名]
[公司名称]
[职位, 如 Network Administrator]
[电话号码]</code></pre></details><p><img src="https://s1.baoshuo.ren/2021/03/13/nbQxcZLFNV6KBgP.png" alt="" loading="lazy"></p><p>提交完毕之后会出现如图所示的界面，点击 <strong>Start</strong> 即可开始验证进程。</p><p><img src="https://s1.baoshuo.ren/2021/03/13/6QKhFL4PGxoeEXn.png" alt="" loading="lazy"></p><p>以 AS141776 的验证为例，选择好接收验证邮件的邮箱，然后点击 <strong>Send</strong> 即可。</p><p><img src="https://s1.baoshuo.ren/2021/03/13/rE4txqgBLeZK9Ou.png" alt="" loading="lazy"></p><p><img src="https://s1.baoshuo.ren/2021/03/13/rAOSIP5oezGRqpc.png" alt="" loading="lazy"></p><p>点击邮箱里的链接即可（第一个是允许，第二个是拒绝）</p><p><img src="https://s1.baoshuo.ren/2021/03/13/xBXiqmukOQbZT6r.png" alt="" loading="lazy"></p><p>验证成功后的提示。</p><p>之后等待客服开通即可。</p><p>由于我是在晚上申请的 Vultr BGP 服务，所以几分钟就开通好了。</p><p><img src="https://s1.baoshuo.ren/2021/03/13/2aLwgPWHzlxF9DY.png" alt="" loading="lazy"></p><p>之后不要忘记去控制台重启实例哦~</p><h2 id="使用-bird2-广播-ip">使用 BIRD2 广播 IP</h2><p>可以参考我在 <a href="/post/dn42-network/#dn42-bird2-%E4%BD%BF%E7%94%A8%E5%85%A5%E9%97%A8">初探 DN42 网络</a> 这篇文章的「DN42 BIRD2 使用入门」一节中描述的步骤，此处不再赘述。</p><p>如果不会写配置文件可以参考 <a href="https://github.com/renbaoshuo/network-configs" rel="external nofollow noreferrer">renbaoshuo/network-configs</a> 仓库中的配置。</p><h2 id="一些注意事项">一些注意事项</h2><h3 id="拆分-ip-段">拆分 IP 段</h3><p>由于我一下子用不了那么多 IP ，所以我决定把我的 <code>/44</code> 拆分成几个 <code>/48</code> 来用。</p><p>如果不涉及 whois 信息的修改操作，那么只需要修改一下 bird 的配置分开广播即可。</p><p>APNIC 修改 whois 信息的流程可以参考 <a href="https://www.apnic.net/manage-ip/using-whois/updating-whois/objects/email-updates/" rel="external nofollow noreferrer">Sending updates by email - APNIC</a> 页面上的指引发送邮件。</p><h3 id="网络交换中心（internet-exchange）">网络交换中心（Internet Exchange）</h3><p>加 IX 的操作流程和 Peer 差不多，注意只发送自己和自己下游（如果有）的路由，不能把上游发来的路由也塞进去，否则会被断开连接。</p><h2 id="名词释义">名词释义</h2><ul><li>LIR: 本地互联网注册机构</li><li>RIR: 区域互联网注册机构 （<a href="https://zh.wikipedia.org/zh-cn/%E5%8C%BA%E5%9F%9F%E4%BA%92%E8%81%94%E7%BD%91%E6%B3%A8%E5%86%8C%E7%AE%A1%E7%90%86%E6%9C%BA%E6%9E%84" rel="external nofollow noreferrer">维基百科</a>）</li><li>ASN: 自治系统编号（<a href="https://zh.wikipedia.org/zh-cn/%E8%87%AA%E6%B2%BB%E7%B3%BB%E7%BB%9F" rel="external nofollow noreferrer">维基百科</a>）</li><li>BGP: 边界网关协议（<a href="https://zh.wikipedia.org/zh-cn/%E8%BE%B9%E7%95%8C%E7%BD%91%E5%85%B3%E5%8D%8F%E8%AE%AE" rel="external nofollow noreferrer">维基百科</a>）</li><li>BIRD: 一个功能齐全的动态 IP 路由守护程序（<a href="https://bird.network.cz" rel="external nofollow noreferrer">官方网站</a>）</li></ul><h2 id="参考资料-9">参考资料</h2><ol><li><a href="https://www.vultr.com/docs/example-letter-of-authorization-for-bgp-announcements" rel="external nofollow noreferrer">Example Letter of Authorization for BGP Announcements</a>，Vultr Docs。</li><li><a href="https://blog.lsc.moe/post/12/" rel="external nofollow noreferrer">IP 广播 : CentOS 7 使用 bird6 广播 IPv6</a>，LiCEO。</li><li><a href="/post/dn42-network/">初探 DN42 网络</a>，宝硕博客。</li><li><a href="https://hex.moe/p/c5ad0614/" rel="external nofollow noreferrer">年轻人的第一个私人BGP(一) - 注册一个ASN</a>，LovelyWei’s 废纸篓。</li><li><a href="https://hex.moe/p/d6a20b99/" rel="external nofollow noreferrer">年轻人的第一个私人BGP(二) - 广播你的IP</a>，LovelyWei’s 废纸篓。</li></ol>]]></content>
        <author>
            <name>宝硕</name>
            <uri>https://baoshuo.ren</uri>
        </author>
    </entry>
</feed>