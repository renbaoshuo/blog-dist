{"pageProps":{"title":"初识 Service Worker —— 使用 Workbox 快速开发 Service Worker - 宝硕博客","post":{"title":"初识 Service Worker —— 使用 Workbox 快速开发 Service Worker","excerpt":"对于优化前端加载性能这个问题，许多人以 http-cache、异步加载、304 状态码、文件压缩、CDN 等方法来解决。\n其实除了这些方法，还有一个比它们都强大的，那就是 Service Worker 。","content":"<p>对于优化前端加载性能这个问题，许多人以 http-cache、异步加载、304 状态码、文件压缩、CDN 等方法来解决。<br>其实除了这些方法，还有一个比它们都强大的，那就是 Service Worker 。</p><span id=more></span><p>我们可以使用 Google Chrome 团队的 <a href=https://github.com/GoogleChrome/workbox rel=\"external nofollow noreferrer\">Workbox</a> 来实现 Service Worker 的快速开发。</p><h2 id=注册-service-worker>注册 Service Worker</h2><p>在页面中添加以下内容以注册一个 Service Worker 。</p><pre><code class=\"hljs html\"><span class=hljs-tag>&lt;<span class=hljs-name>script</span>&gt;</span><span class=language-javascript></span>\n<span class=language-javascript>  <span class=hljs-comment>// 检测是否支持 Service Worker</span></span>\n<span class=language-javascript>  <span class=hljs-comment>// 也可使用 navigator.serviceWorker 判断</span></span>\n<span class=language-javascript>  <span class=hljs-keyword>if</span> (<span class=hljs-string>&#x27;serviceWorker&#x27;</span> <span class=hljs-keyword>in</span> navigator) &#123;</span>\n<span class=language-javascript>    <span class=hljs-comment>// 为了保证首屏渲染性能，在页面 onload 完之后注册 Service Worker</span></span>\n<span class=language-javascript>    <span class=hljs-comment>// 不使用 window.onload 以免冲突</span></span>\n<span class=language-javascript>    <span class=\"hljs-variable language_\">window</span>.<span class=\"hljs-title function_\">addEventListener</span>(<span class=hljs-string>&#x27;load&#x27;</span>, <span class=hljs-function>() =&gt;</span> &#123;</span>\n<span class=language-javascript>      navigator.<span class=hljs-property>serviceWorker</span>.<span class=\"hljs-title function_\">register</span>(<span class=hljs-string>&#x27;/sw.js&#x27;</span>);</span>\n<span class=language-javascript>    &#125;);</span>\n<span class=language-javascript>  &#125;</span>\n<span class=language-javascript></span><span class=hljs-tag>&lt;/<span class=hljs-name>script</span>&gt;</span></code></pre><p>当然，在这之前你需要先有一个 Service Worker 的代码 <code>/sw.js</code> 。</p><p>你可以在这个文件中写入以下代码来检测是否成功地注册了 Service Worker 。</p><pre><code class=\"hljs javascript\"><span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">clear</span>();\n<span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=hljs-string>&#x27;Successful registered service worker.&#x27;</span>);</code></pre><p><img src=https://s1.baoshuo.ren/2021/02/28/Eu4mVIC2kNrUgiL.png alt=\"\" loading=lazy></p><h2 id=引入-workbox>引入 Workbox</h2><p>你可以使用 Google 提供的 CDN 来引入 Workbox 。<br>只需在 <code>sw.js</code> 的开头写入以下内容即可：</p><pre><code class=\"hljs javascript\"><span class=\"hljs-title function_\">importScripts</span>(\n  <span class=hljs-string>&#x27;https://storage.googleapis.com/workbox-cdn/releases/6.1.1/workbox-sw.js&#x27;</span>\n);</code></pre><p>如果你觉得 Google 的 CDN 不太靠谱的话，可以使用 <code>workbox-cli</code> 将资源存在本地：</p><pre><code class=\"hljs bash\">npm i workbox-cli -g\nworkbox copyLibraries &#123;path/to/workbox/&#125;</code></pre><p>这时需要在 <code>sw.js</code> 的开头将上方写入的内容替换为以下内容即可：</p><pre><code class=\"hljs javascript\"><span class=\"hljs-title function_\">importScripts</span>(<span class=hljs-string>&#x27;&#123;path/to&#125;/workbox/workbox-sw.js&#x27;</span>);\nworkbox.<span class=\"hljs-title function_\">setConfig</span>(&#123;\n  <span class=hljs-attr>modulePathPrefix</span>: <span class=hljs-string>&#x27;&#123;path/to&#125;/workbox/&#x27;</span>,\n&#125;);</code></pre><h2 id=workbox-策略>Workbox 策略</h2><h3 id=stale-while-revalidate（重新验证时过期）>Stale While Revalidate（重新验证时过期）</h3><p><img src=https://s1.baoshuo.ren/2021/02/28/rx8zafbqPe1JnkX.png alt=\"\" loading=lazy></p><p>此策略将对网络请求使用缓存来响应（如果有），并在后台更新缓存。如果未缓存，它将等待网络响应并使用它。<br>这是一个相当安全的策略，因为这意味着用户会定期更新其缓存。这种策略的缺点是：它总是从网络上请求资源，较为浪费用户的带宽。</p><pre><code class=\"hljs javascript\"><span class=\"hljs-title function_\">registerRoute</span>(\n  <span class=hljs-keyword>new</span> <span class=\"hljs-title class_\">RegExp</span>(matchString),\n  <span class=hljs-keyword>new</span> workbox.<span class=hljs-property>strategies</span>.<span class=\"hljs-title class_\">StaleWhileRevalidate</span>()\n);</code></pre><h3 id=network-first（网络优先）>Network First（网络优先）</h3><p><img src=https://s1.baoshuo.ren/2021/02/28/9ViWk1ZyU4CuDxE.png alt=\"\" loading=lazy></p><p>此策略将尝试首先从网络获得响应。如果收到响应，它将把它传递给浏览器，并将其保存到缓存中。如果网络请求失败，将使用最后一个缓存的响应。</p><pre><code class=\"hljs javascript\"><span class=\"hljs-title function_\">registerRoute</span>(<span class=hljs-keyword>new</span> <span class=\"hljs-title class_\">RegExp</span>(matchString), <span class=hljs-keyword>new</span> workbox.<span class=hljs-property>strategies</span>.<span class=\"hljs-title class_\">NetworkFirst</span>());</code></pre><h3 id=cache-first（缓存优先）>Cache First（缓存优先）</h3><p><img src=https://s1.baoshuo.ren/2021/02/28/jkn4Y3mNCRZrSdX.png alt=\"\" loading=lazy></p><p>此策略将首先检查缓存中是否有响应，如果有响应，则使用该策略。如果请求不在缓存中，则将使用网络，并将任何有效响应添加到缓存中，然后再传递给浏览器。</p><pre><code class=\"hljs javascript\"><span class=\"hljs-title function_\">registerRoute</span>(<span class=hljs-keyword>new</span> <span class=\"hljs-title class_\">RegExp</span>(matchString), <span class=hljs-keyword>new</span> workbox.<span class=hljs-property>strategies</span>.<span class=\"hljs-title class_\">CacheFirst</span>());</code></pre><h3 id=network-only（仅网络）>Network Only（仅网络）</h3><p><img src=https://s1.baoshuo.ren/2021/02/28/cQYTlvie1dX8hOF.png alt=\"\" loading=lazy></p><p>强制响应来自网络。</p><pre><code class=\"hljs javascript\"><span class=\"hljs-title function_\">registerRoute</span>(<span class=hljs-keyword>new</span> <span class=\"hljs-title class_\">RegExp</span>(matchString), <span class=hljs-keyword>new</span> workbox.<span class=hljs-property>strategies</span>.<span class=\"hljs-title class_\">NetworkOnly</span>());</code></pre><h3 id=cache-only（仅缓存）>Cache Only（仅缓存）</h3><p><img src=https://s1.baoshuo.ren/2021/02/28/71Sw5tTaBQKl8ri.png alt=\"\" loading=lazy></p><p>强制响应来自缓存。</p><pre><code class=\"hljs javascript\"><span class=\"hljs-title function_\">registerRoute</span>(<span class=hljs-keyword>new</span> <span class=\"hljs-title class_\">RegExp</span>(matchString), <span class=hljs-keyword>new</span> workbox.<span class=hljs-property>strategies</span>.<span class=\"hljs-title class_\">CacheOnly</span>());</code></pre><h3 id=策略配置>策略配置</h3><p>可以通过定义要使用的插件来自定义路由的行为。</p><pre><code class=\"hljs javascript\"><span class=hljs-keyword>new</span> workbox.<span class=hljs-property>strategies</span>.<span class=\"hljs-title class_\">StaleWhileRevalidate</span>(&#123;\n    <span class=hljs-comment>// Use a custom cache for this route.</span>\n    <span class=hljs-attr>cacheName</span>: <span class=hljs-string>&#x27;my-cache-name&#x27;</span>,\n\n    <span class=hljs-comment>// Add an array of custom plugins (e.g. `ExpirationPlugin`).</span>\n    <span class=hljs-attr>plugins</span>: [\n        ...\n    ]\n&#125;);</code></pre><h2 id=workbox-中的自定义策略>Workbox 中的自定义策略</h2><p>在某些情况下，您可能希望使用自己的其他策略来响应请求，或者只是通过模板在 Service Worker 中生成请求。<br>为此可以提供一个异步返回 <code>Response</code> 对象的函数 <code>handler</code> 。</p><pre><code class=\"hljs javascript\"><span class=hljs-keyword>const</span> <span class=\"hljs-title function_\">handler</span> = <span class=hljs-keyword>async</span> (<span class=hljs-params>&#123; url, event &#125;</span>) =&gt; &#123;\n  <span class=hljs-keyword>return</span> <span class=hljs-keyword>new</span> <span class=\"hljs-title class_\">Response</span>(<span class=hljs-string>`Custom handler response.`</span>);\n&#125;;\n\nworkbox.<span class=hljs-property>routing</span>.<span class=\"hljs-title function_\">registerRoute</span>(<span class=hljs-keyword>new</span> <span class=\"hljs-title class_\">RegExp</span>(matchString), handler);</code></pre><p>需要注意的是，如果在 <code>match</code> 回调中返回一个值，它将 <code>handler</code> 作为 <code>params</code> 参数传递到回调中。</p><pre><code class=\"hljs javascript\"><span class=hljs-keyword>const</span> <span class=\"hljs-title function_\">match</span> = (<span class=hljs-params>&#123; url, event &#125;</span>) =&gt; &#123;\n  <span class=hljs-keyword>if</span> (url.<span class=hljs-property>pathname</span> === <span class=hljs-string>&#x27;/example&#x27;</span>) &#123;\n    <span class=hljs-keyword>return</span> &#123;\n      <span class=hljs-attr>name</span>: <span class=hljs-string>&#x27;Workbox&#x27;</span>,\n      <span class=hljs-attr>type</span>: <span class=hljs-string>&#x27;guide&#x27;</span>,\n    &#125;;\n  &#125;\n&#125;;\n\n<span class=hljs-keyword>const</span> <span class=\"hljs-title function_\">handler</span> = <span class=hljs-keyword>async</span> (<span class=hljs-params>&#123; url, event, params &#125;</span>) =&gt; &#123;\n  <span class=hljs-comment>// Response will be &quot;A guide to Workbox&quot;</span>\n  <span class=hljs-keyword>return</span> <span class=hljs-keyword>new</span> <span class=\"hljs-title class_\">Response</span>(<span class=hljs-string>`A <span class=hljs-subst>$&#123;params.type&#125;</span> to <span class=hljs-subst>$&#123;params.name&#125;</span>`</span>);\n&#125;;\n\nworkbox.<span class=hljs-property>routing</span>.<span class=\"hljs-title function_\">registerRoute</span>(match, handler);</code></pre><p>如果 URL 中的某些信息可以在 match 回调中解析一次并在中使用，则这可能会对 <code>handler</code> 有所帮助。</p><h2 id=workbox-实践>Workbox 实践</h2><p>通常对于大部分项目使用 Workbox 时一般会引入相应的 gulp 或者 webpack 插件，在构建流程中完成对 Service Worker 的注册、将指定 URL 进行 Precache、完成 sw.js 的生成，等等。<br>但是对于 Hexo、Jekyll 这些静态站点生成器或者 WordPress、Typecho 这些 CMS，如果不安装相应的插件，就需要自己从头编写一个 <code>sw.js</code>。</p><p>先写一下总的配置：</p><pre><code class=\"hljs javascript\"><span class=hljs-keyword>let</span> cacheSuffixVersion = <span class=hljs-string>&#x27;-210227&#x27;</span>; <span class=hljs-comment>// 缓存版本号</span>\n<span class=hljs-keyword>const</span> maxEntries = <span class=hljs-number>100</span>; <span class=hljs-comment>// 最大条目数</span>\n\ncore.<span class=\"hljs-title function_\">setCacheNameDetails</span>(&#123;\n  <span class=hljs-attr>prefix</span>: <span class=hljs-string>&#x27;baoshuo-blog&#x27;</span>, <span class=hljs-comment>// 前缀</span>\n  <span class=hljs-attr>suffix</span>: cacheSuffixVersion, <span class=hljs-comment>// 后缀</span>\n&#125;);</code></pre><h3 id=google-fonts>Google Fonts</h3><p>Google Fonts 主要使用两个域名：<code>fonts.googleapis.com</code> 和 <code>fonts.gstatic.com</code> ，因此只需在匹配到这两个域名时进行缓存。</p><pre><code class=\"hljs javascript\">workbox.<span class=hljs-property>routing</span>.<span class=\"hljs-title function_\">registerRoute</span>(\n  <span class=hljs-comment>// 匹配 fonts.googleapis.com 和 fonts.gstatic.com 两个域名</span>\n  <span class=hljs-keyword>new</span> <span class=\"hljs-title class_\">RegExp</span>(<span class=hljs-string>&#x27;^https://(?:fonts\\\\.googleapis\\\\.com|fonts\\\\.gstatic\\\\.com)&#x27;</span>),\n  <span class=hljs-keyword>new</span> workbox.<span class=hljs-property>strategies</span>.<span class=\"hljs-title class_\">StaleWhileRevalidate</span>(&#123;\n    <span class=hljs-comment>// cache storage 名称和版本号</span>\n    <span class=hljs-attr>cacheName</span>: <span class=hljs-string>&#x27;font-cache&#x27;</span> + cacheSuffixVersion,\n    <span class=hljs-attr>plugins</span>: [\n      <span class=hljs-comment>// 使用 expiration 插件实现缓存条目数目和时间控制</span>\n      <span class=hljs-keyword>new</span> workbox.<span class=hljs-property>expiration</span>.<span class=\"hljs-title class_\">ExpirationPlugin</span>(&#123;\n        <span class=hljs-comment>// 最大保存项目</span>\n        maxEntries,\n        <span class=hljs-comment>// 缓存 30 天</span>\n        <span class=hljs-attr>maxAgeSeconds</span>: <span class=hljs-number>30</span> * <span class=hljs-number>24</span> * <span class=hljs-number>60</span> * <span class=hljs-number>60</span>,\n      &#125;),\n      <span class=hljs-comment>// 使用 cacheableResponse 插件缓存状态码为 0 的请求</span>\n      <span class=hljs-keyword>new</span> workbox.<span class=hljs-property>cacheableResponse</span>.<span class=\"hljs-title class_\">CacheableResponsePlugin</span>(&#123;\n        <span class=hljs-attr>statuses</span>: [<span class=hljs-number>0</span>, <span class=hljs-number>200</span>],\n      &#125;),\n    ],\n  &#125;)\n);</code></pre><h3 id=jsdelivr-cdn>jsDelivr CDN</h3><p>使用 jsDelivr CDN 时如果指定了库的版本，对应的文件可以称得上是永久不会改变的，所以使用 <code>CacheFirst</code> 来进行缓存。</p><pre><code class=\"hljs javascript\">workbox.<span class=hljs-property>routing</span>.<span class=\"hljs-title function_\">registerRoute</span>(\n  <span class=hljs-keyword>new</span> <span class=\"hljs-title class_\">RegExp</span>(<span class=hljs-string>&#x27;^https://cdn\\\\.jsdelivr\\\\.net&#x27;</span>),\n  <span class=hljs-keyword>new</span> workbox.<span class=hljs-property>strategies</span>.<span class=\"hljs-title class_\">CacheFirst</span>(&#123;\n    <span class=hljs-attr>cacheName</span>: <span class=hljs-string>&#x27;static-immutable&#x27;</span> + cacheSuffixVersion,\n    <span class=hljs-attr>fetchOptions</span>: &#123;\n      <span class=hljs-attr>mode</span>: <span class=hljs-string>&#x27;cors&#x27;</span>,\n      <span class=hljs-attr>credentials</span>: <span class=hljs-string>&#x27;omit&#x27;</span>,\n    &#125;,\n    <span class=hljs-attr>plugins</span>: [\n      <span class=hljs-keyword>new</span> workbox.<span class=hljs-property>expiration</span>.<span class=\"hljs-title class_\">ExpirationPlugin</span>(&#123;\n        <span class=hljs-attr>maxAgeSeconds</span>: <span class=hljs-number>30</span> * <span class=hljs-number>24</span> * <span class=hljs-number>60</span> * <span class=hljs-number>60</span>,\n        <span class=hljs-attr>purgeOnQuotaError</span>: <span class=hljs-literal>true</span>,\n      &#125;),\n    ],\n  &#125;)\n);</code></pre><h3 id=google-analytics>Google Analytics</h3><p>Workbox 有一个 <a href=https://developers.google.com/web/tools/workbox/guides/enable-offline-analytics rel=\"external nofollow noreferrer\">Google Analytics 离线统计插件</a>，可惜我用的是 Sukka 大佬编写的<a href=https://github.com/SukkaW/cloudflare-workers-async-google-analytics rel=\"external nofollow noreferrer\">非官方 Google Analytics 实现</a>，所以只能添加一个 <code>NetworkOnly</code> 来放弃离线统计。</p><pre><code class=\"hljs javascript\">workbox.<span class=hljs-property>routing</span>.<span class=\"hljs-title function_\">registerRoute</span>(\n  <span class=hljs-keyword>new</span> <span class=\"hljs-title class_\">RegExp</span>(<span class=hljs-string>&#x27;^https://api\\\\.baoshuo\\\\.ren/cfga/(.*)&#x27;</span>),\n  <span class=hljs-keyword>new</span> workbox.<span class=hljs-property>strategies</span>.<span class=\"hljs-title class_\">NetworkOnly</span>(&#123;\n    <span class=hljs-attr>plugins</span>: [\n      <span class=hljs-keyword>new</span> workbox.<span class=hljs-property>backgroundSync</span>.<span class=\"hljs-title class_\">BackgroundSyncPlugin</span>(<span class=hljs-string>&#x27;Optical_Collect&#x27;</span>, &#123;\n        <span class=hljs-attr>maxRetentionTime</span>: <span class=hljs-number>12</span> * <span class=hljs-number>60</span>, <span class=hljs-comment>// Retry for max of 12 Hours (specified in minutes)</span>\n      &#125;),\n    ],\n  &#125;)\n);</code></pre><h3 id=图片>图片</h3><p>由于我开通了 <a href=http://SM.MS rel=\"external nofollow noreferrer\">SM.MS</a> 的 LifeTime Premium VIP ，所以图片当然是要存到这里啦~</p><p><a href=http://SM.MS rel=\"external nofollow noreferrer\">SM.MS</a> 的图片域名有这几个：<code>i.loli.net</code>、<code>vip1.loli.net</code>、<code>vip2.loli.net</code>、<code>s1.baoshuo.ren</code>、<code>s1.baoshuo.ren</code>，只需要写一个正则匹配下就好了。</p><p>由于图片链接对应的文件像 jsDelivr 一样也是几乎永久都不会改变的，所以使用 <code>CacheFirst</code> 来进行缓存。</p><pre><code class=\"hljs javascript\">workbox.<span class=hljs-property>routing</span>.<span class=\"hljs-title function_\">registerRoute</span>(\n  <span class=hljs-keyword>new</span> <span class=\"hljs-title class_\">RegExp</span>(<span class=hljs-string>&#x27;^https://(?:i|vip[0-9])\\\\.loli\\\\.(?:io|net)&#x27;</span>),\n  <span class=hljs-keyword>new</span> workbox.<span class=hljs-property>strategies</span>.<span class=\"hljs-title class_\">CacheFirst</span>(&#123;\n    <span class=hljs-attr>cacheName</span>: <span class=hljs-string>&#x27;img-cache&#x27;</span> + cacheSuffixVersion,\n    <span class=hljs-attr>plugins</span>: [\n      <span class=hljs-comment>// 使用 expiration 插件实现缓存条目数目和时间控制</span>\n      <span class=hljs-keyword>new</span> workbox.<span class=hljs-property>expiration</span>.<span class=\"hljs-title class_\">ExpirationPlugin</span>(&#123;\n        maxEntries, <span class=hljs-comment>// 最大保存项目</span>\n        <span class=hljs-attr>maxAgeSeconds</span>: <span class=hljs-number>30</span> * <span class=hljs-number>24</span> * <span class=hljs-number>60</span> * <span class=hljs-number>60</span>, <span class=hljs-comment>// 缓存 30 天</span>\n      &#125;),\n      <span class=hljs-comment>// 使用 cacheableResponse 插件缓存状态码为 0 的请求</span>\n      <span class=hljs-keyword>new</span> workbox.<span class=hljs-property>cacheableResponse</span>.<span class=\"hljs-title class_\">CacheableResponsePlugin</span>(&#123;\n        <span class=hljs-attr>statuses</span>: [<span class=hljs-number>0</span>, <span class=hljs-number>200</span>],\n      &#125;),\n    ],\n  &#125;)\n);</code></pre><h3 id=友情链接>友情链接</h3><p>这些文件只是偶尔更新，使用 <code>StaleWhileRevalidate</code> ，可以兼顾速度与版本更新。</p><pre><code class=\"hljs javascript\">workbox.<span class=hljs-property>routing</span>.<span class=\"hljs-title function_\">registerRoute</span>(\n  <span class=hljs-keyword>new</span> <span class=\"hljs-title class_\">RegExp</span>(<span class=hljs-string>&#x27;^https://friends\\\\.baoshuo\\\\.ren(.*)(png|jpg|jpeg|svg|gif)&#x27;</span>),\n  <span class=hljs-keyword>new</span> workbox.<span class=hljs-property>strategies</span>.<span class=\"hljs-title class_\">StaleWhileRevalidate</span>(&#123;\n    <span class=hljs-attr>cacheName</span>: <span class=hljs-string>&#x27;img-cache&#x27;</span> + cacheSuffixVersion,\n    <span class=hljs-attr>fetchOptions</span>: &#123;\n      <span class=hljs-attr>mode</span>: <span class=hljs-string>&#x27;cors&#x27;</span>,\n      <span class=hljs-attr>credentials</span>: <span class=hljs-string>&#x27;omit&#x27;</span>,\n    &#125;,\n  &#125;)\n);\nworkbox.<span class=hljs-property>routing</span>.<span class=\"hljs-title function_\">registerRoute</span>(\n  <span class=hljs-keyword>new</span> <span class=\"hljs-title class_\">RegExp</span>(<span class=hljs-string>&#x27;https://friends\\\\.baoshuo\\\\.ren/links.json&#x27;</span>),\n  <span class=hljs-keyword>new</span> workbox.<span class=hljs-property>strategies</span>.<span class=\"hljs-title class_\">StaleWhileRevalidate</span>()\n);</code></pre><h3 id=disqus-评论>Disqus 评论</h3><p>DisqusJS 判断访客的 Disqus 可用性是通过检查 <code>shortname.disqus.com/favicon.ico</code> 和 <code>disqus.com/favicon.ico</code> ，显然是不能被缓存的。<br>API 可以在无网络时使用 <code>NetworkFirst</code> 来达到无网络时也能查看评论的效果。<br>另外 Disqus 本身也没有缓存的必要，所以对 <code>*.disqus.com</code> 使用 <code>NetworkOnly</code> 即可。<br>但是 <code>*.disquscdn.com</code> 下的头像、JS、CSS 是可以缓存一段时间的，所以使用 <code>CacheFirst</code> 缓存 10 天。</p><pre><code class=\"hljs javascript\"><span class=hljs-comment>// API</span>\nworkbox.<span class=hljs-property>routing</span>.<span class=\"hljs-title function_\">registerRoute</span>(\n  <span class=hljs-keyword>new</span> <span class=\"hljs-title class_\">RegExp</span>(<span class=hljs-string>&#x27;^https://api\\\\.baoshuo\\\\.ren/disqus/(.*)&#x27;</span>),\n  <span class=hljs-keyword>new</span> workbox.<span class=hljs-property>strategies</span>.<span class=\"hljs-title class_\">NetworkFirst</span>(&#123;\n    <span class=hljs-attr>cacheName</span>: <span class=hljs-string>&#x27;dsqjs-api&#x27;</span> + cacheSuffixVersion,\n    <span class=hljs-attr>fetchOptions</span>: &#123;\n      <span class=hljs-attr>mode</span>: <span class=hljs-string>&#x27;cors&#x27;</span>,\n      <span class=hljs-attr>credentials</span>: <span class=hljs-string>&#x27;omit&#x27;</span>,\n    &#125;,\n    <span class=hljs-attr>networkTimeoutSeconds</span>: <span class=hljs-number>3</span>,\n  &#125;)\n);\n<span class=hljs-comment>// Disqus</span>\nworkbox.<span class=hljs-property>routing</span>.<span class=\"hljs-title function_\">registerRoute</span>(\n  <span class=hljs-keyword>new</span> <span class=\"hljs-title class_\">RegExp</span>(<span class=hljs-string>&#x27;^https://(.*)disqus\\\\.com&#x27;</span>),\n  <span class=hljs-keyword>new</span> workbox.<span class=hljs-property>strategies</span>.<span class=\"hljs-title class_\">NetworkOnly</span>()\n);\nworkbox.<span class=hljs-property>routing</span>.<span class=\"hljs-title function_\">registerRoute</span>(\n  <span class=hljs-keyword>new</span> <span class=\"hljs-title class_\">RegExp</span>(<span class=hljs-string>&#x27;^https://(.*)disquscdn\\\\.com(.*)&#x27;</span>),\n  <span class=hljs-keyword>new</span> workbox.<span class=hljs-property>strategies</span>.<span class=\"hljs-title class_\">CacheFirst</span>(&#123;\n    <span class=hljs-attr>cacheName</span>: <span class=hljs-string>&#x27;disqus-cdn-cache&#x27;</span> + cacheSuffixVersion,\n    <span class=hljs-attr>plugins</span>: [\n      <span class=hljs-keyword>new</span> workbox.<span class=hljs-property>expiration</span>.<span class=\"hljs-title class_\">ExpirationPlugin</span>(&#123;\n        <span class=hljs-attr>maxAgeSeconds</span>: <span class=hljs-number>10</span> * <span class=hljs-number>24</span> * <span class=hljs-number>60</span> * <span class=hljs-number>60</span>,\n      &#125;),\n      <span class=hljs-keyword>new</span> workbox.<span class=hljs-property>cacheableResponse</span>.<span class=\"hljs-title class_\">CacheableResponsePlugin</span>(&#123;\n        <span class=hljs-attr>statuses</span>: [<span class=hljs-number>0</span>, <span class=hljs-number>200</span>],\n      &#125;),\n    ],\n  &#125;)\n);</code></pre><h3 id=后缀匹配>后缀匹配</h3><p>针对其余没有被域名匹配到的静态文件，通过文件后缀进行匹配并使用 <code>StaleWhileRevalidate</code> ，可以兼顾速度与版本更新。</p><pre><code class=\"hljs javascript\">workbox.<span class=hljs-property>routing</span>.<span class=\"hljs-title function_\">registerRoute</span>(\n  <span class=hljs-keyword>new</span> <span class=\"hljs-title class_\">RegExp</span>(<span class=hljs-string>&#x27;.*.(?:png|jpg|jpeg|svg|gif|webp)&#x27;</span>),\n  <span class=hljs-keyword>new</span> workbox.<span class=hljs-property>strategies</span>.<span class=\"hljs-title class_\">StaleWhileRevalidate</span>()\n);\nworkbox.<span class=hljs-property>routing</span>.<span class=\"hljs-title function_\">registerRoute</span>(\n  <span class=hljs-keyword>new</span> <span class=\"hljs-title class_\">RegExp</span>(<span class=hljs-string>&#x27;.*.(css|js)&#x27;</span>),\n  <span class=hljs-keyword>new</span> workbox.<span class=hljs-property>strategies</span>.<span class=\"hljs-title class_\">StaleWhileRevalidate</span>()\n);</code></pre><h3 id=默认行为>默认行为</h3><p>使用 Workbox 的 defaultHandler 匹配剩下的请求（包括页面自身），一律使用 <code>NetworkFirst</code> ，借助 Workbox 的 <code>runtimeCache</code> 起到加速和离线效果。</p><pre><code class=\"hljs javascript\">workbox.<span class=hljs-property>routing</span>.<span class=\"hljs-title function_\">setDefaultHandler</span>(\n  <span class=hljs-keyword>new</span> workbox.<span class=hljs-property>strategies</span>.<span class=\"hljs-title class_\">NetworkFirst</span>(&#123;\n    <span class=hljs-attr>networkTimeoutSeconds</span>: <span class=hljs-number>3</span>,\n  &#125;)\n);</code></pre><h2 id=参考资料-13>参考资料</h2><p><em>文章头图来自：<a href=https://developers.google.com/web/tools/workbox rel=\"external nofollow noreferrer\">https://developers.google.com/web/tools/workbox</a></em></p><p><em><a href=#Workbox-%E7%AD%96%E7%95%A5>Workbox 策略</a> 一节中的配图来自：<a href=https://web.dev/offline-cookbook/ rel=\"external nofollow noreferrer\">https://web.dev/offline-cookbook/</a></em></p><ul><li><a href=https://developers.google.com/web/tools/workbox/ rel=\"external nofollow noreferrer\">Workbox - Google Developers</a></li><li><a href=https://blog.skk.moe/post/hello-workbox/ rel=\"external nofollow noreferrer\">Workbox, not sw-toolbox &amp; sw-precache - Sukka’s Blog</a></li><li><a href=https://github.com/GoogleChrome/workbox rel=\"external nofollow noreferrer\">GoogleChrome/workbox - GitHub</a></li><li><a href=https://web.dev/offline-cookbook/#serving-suggestions rel=\"external nofollow noreferrer\">The Offline Cookbook - web.dev</a></li></ul>","thumb":"https://s1.baoshuo.ren/2021/02/28/kdnvD8ACWBa1tbI.png","date":"2021-02-27","updated":"2021-02-27","isoDate":"2021-02-27T16:02:04.000Z","isoUpdate":"2021-02-27T16:02:04.000Z","categories":[{"name":"技术向","url":"/categories/%E6%8A%80%E6%9C%AF%E5%90%91/"}],"tags":[{"name":"Web","url":"/tags/Web/"},{"name":"JavaScript","url":"/tags/JavaScript/"},{"name":"ServiceWorker","url":"/tags/ServiceWorker/"}],"license":null,"permalink":"https://blog.baoshuo.ren/post/workbox-service-worker/","url":"/post/workbox-service-worker/","prev":{"title":"年轻人的第一个 ASN","url":"/post/my-own-asn/"},"next":{"title":"浅谈网页「深色模式」的实现","url":"/post/darkmode/"},"toc":{"1":{"text":"注册 Service Worker","id":"注册-service-worker"},"2":{"text":"引入 Workbox","id":"引入-workbox"},"3":{"1":{"text":"Stale While Revalidate（重新验证时过期）","id":"stale-while-revalidate（重新验证时过期）"},"2":{"text":"Network First（网络优先）","id":"network-first（网络优先）"},"3":{"text":"Cache First（缓存优先）","id":"cache-first（缓存优先）"},"4":{"text":"Network Only（仅网络）","id":"network-only（仅网络）"},"5":{"text":"Cache Only（仅缓存）","id":"cache-only（仅缓存）"},"6":{"text":"策略配置","id":"策略配置"},"text":"Workbox 策略","id":"workbox-策略"},"4":{"text":"Workbox 中的自定义策略","id":"workbox-中的自定义策略"},"5":{"1":{"text":"Google Fonts","id":"google-fonts"},"2":{"text":"jsDelivr CDN","id":"jsdelivr-cdn"},"3":{"text":"Google Analytics","id":"google-analytics"},"4":{"text":"图片","id":"图片"},"5":{"text":"友情链接","id":"友情链接"},"6":{"text":"Disqus 评论","id":"disqus-评论"},"7":{"text":"后缀匹配","id":"后缀匹配"},"8":{"text":"默认行为","id":"默认行为"},"text":"Workbox 实践","id":"workbox-实践"},"6":{"text":"参考资料","id":"参考资料-13"}},"hasToc":true,"comments":true,"wordCount":"约 2.1 千字"},"__post":true},"__N_SSG":true}