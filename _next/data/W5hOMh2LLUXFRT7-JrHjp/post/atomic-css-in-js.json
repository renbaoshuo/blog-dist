{"pageProps":{"title":"拥抱 Atomic CSS-in-JS - 宝硕博客","post":{"title":"拥抱 Atomic CSS-in-JS","excerpt":"当下，Atomic CSS 愈发受到人们的关注。相比于传统 CSS 编写方法中每个组件对应一个 CSS 类，使用了 Atomic CSS 以后，每一个 CSS 类都唯一对应了一条独立的 CSS 规则，随着组件数量逐渐增加、能复用的 CSS 规则越来越多，最终的 CSS 产物体积也会下降许多，使得网页的加载速度能够产生一个质的飞跃。","content":[["$","p",{},["当下，Atomic CSS 愈发受到人们的关注。相比于传统 CSS 编写方法中每个组件对应一个 CSS 类，使用了 Atomic CSS 以后，每一个 CSS 类都唯一对应了一条独立的 CSS 规则，随着组件数量逐渐增加、能复用的 CSS 规则越来越多，最终的 CSS 产物体积也会下降许多，使得网页的加载速度能够产生一个质的飞跃。"]],["$","span",{"id":"more"},[]],["$","h2",{"id":"css-编写方法的发展历程"},["CSS 编写方法的发展历程"]],["$","p",{},["在介绍 Atomic CSS 之前，让我们先来回顾一下 CSS 编写方法的发展历程。"]],["$","h3",{"id":"oocss"},["OOCSS"]],["$","p",{},[["$","a",{"href":"https://github.com/stubbornella/oocss/wiki","rel":"external nofollow noreferrer"},["OOCSS"]],"（Object Oriented CSS），字面意思是面向对象的 CSS，是由 Nicole Sullivan 提出的 CSS 理论，其主要的两个原则是："]],["$","ul",{},[["$","li",{},["Separate structure and skin（分离结构和主题）"]],["$","li",{},["Separate container and content（分离容器和内容）"]]]],["$","p",{},["以 Bootstrap 的 ",["$","a",{"href":"https://getbootstrap.com/docs/5.2/components/buttons/","rel":"external nofollow noreferrer"},["Buttons"]]," 组件为例："]],["$","pre",{},[["$","code",{"class":"hljs html"},[["$","span",{"class":"hljs-tag"},["<",["$","span",{"class":"hljs-name"},["button"]]," ",["$","span",{"class":"hljs-attr"},["class"]],"=",["$","span",{"class":"hljs-string"},["\"btn btn-primary btn-sm\""]],">"]],"Button",["$","span",{"class":"hljs-tag"},["</",["$","span",{"class":"hljs-name"},["button"]],">"]]]]]],["$","p",{},["其中的 ",["$","code",{},[".btn"]]," 类是按钮的基本样式，",["$","code",{},[".btn-primary"]]," 类则用来指定按钮的颜色，",["$","code",{},[".btn-sm"]]," 类则用来指定按钮的大小。"]],["$","p",{},["这样的规范让开发者能设计出一套可以使用「组合」操作来产生多样的组件的方案，让代码更精简、便于管理与维护。"]],["$","h3",{"id":"smacss"},["SMACSS"]],["$","p",{},[["$","a",{"href":"http://smacss.com","rel":"external nofollow noreferrer"},["SMACSS"]],"（Scalable & Modular Architecture for CSS），是由 Jonathan Snook 提出的 CSS 理论。其主要原则有 3 条："]],["$","ul",{},[["$","li",{},["Categorizing CSS Rules（为 CSS 分类）"]],["$","li",{},["Naming Rules（命名规则）"]],["$","li",{},["Minimizing the Depth of Applicability（最小化适配深度）"]]]],["$","h4",{"id":"规则分类"},["规则分类"]],["$","p",{},["SMACSS 将规则分为了五类：Base（基础）、Layout（布局）、Module（模块）、State（状态）、Theme（主题）。"]],["$","p",{},[["$","strong",{},["基础（Base）"]]," 规则里放置默认样式。这些默认样式基本上都是元素选择器，不过也可以包含属性选择器，伪类选择器，孩子选择器，兄弟选择器。本质上来说，一个基础样式定义了元素在页面的任何位置应该是怎么样的。"]],["$","p",{},[["$","strong",{},["布局（Layout）"]]," 规则将页面拆分成几个部分，每个部分都可能有一到多个模块。顾名思义，这个分类主要用来做页面的整体或其中一块区域的布局。"]],["$","p",{},[["$","strong",{},["模块（Modules）"]]," 是我们的设计当中可重用，可模块化的部分。插图，侧边栏，文章列表等等都属于模块。"]],["$","p",{},[["$","strong",{},["状态（State）"]]," 规则定义了我们的模块或者布局在特殊的状态下应该呈现怎样的效果。它可能定义模块、布局在不同显示屏上应该如何显示。也可能定义一个模块在不同页面（例如主页和内页）中可能呈现怎么样的效果。"]],["$","p",{},[["$","strong",{},["主题（Theme）"]]," 规则和状态规则类似，定义模块或者布局的外观。很多网站的「深色模式」「换肤」等等功能就是这样实现的。"]],["$","h4",{"id":"命名规则"},["命名规则"]],["$","p",{},["将规则分成五类之后，还需要命名规范。命名规范能够使得我们立刻了解到某个样式属于哪一类，以及它在整个页面中起到的作用。在一个大型项目中，我们可能会将一个样式分割成几个文件，这个时候命名约定能够使得我们更容易知道这个样式属于哪个文件。"]],["$","p",{},["推荐使用前缀来区分布局、模块和状态等等规则。比如对布局规则使用 ",["$","code",{},["layout-"]]," 前缀，对状态规则使用 ",["$","code",{},["is-"]]," 前缀就说一个不错的选择。"]],["$","h4",{"id":"最小化适配深度"},["最小化适配深度"]],["$","p",{},["尽量不要依赖文档树的结构来编写样式。这样可以让我们的样式更加灵活，并且容易维护。"]],["$","h3",{"id":"bem"},["BEM"]],["$","p",{},[["$","a",{"href":"http://getbem.com","rel":"external nofollow noreferrer"},["BEM"]],"（ Block Element Modifier）是由 Yandex 团队提出的一种前端 CSS 命名方法论。它是一个简单又非常有用的命名约定。让前端代码更容易阅读和理解，更容易协作，更容易控制，更加健壮和明确，而且更加严密。"]],["$","p",{},["BEM 命名约定的模式是："]],["$","pre",{},[["$","code",{"class":"hljs css"},[["$","span",{"class":"hljs-selector-class"},[".block"]]," {\n}\n\n",["$","span",{"class":"hljs-selector-class"},[".block__element"]]," {\n}\n\n",["$","span",{"class":"hljs-selector-class"},[".block--modifier"]]," {\n}"]]]],["$","ul",{},[["$","li",{},[["$","code",{},["block"]]," 代表了「块」，用于组件本体。"]],["$","li",{},[["$","code",{},["element"]]," 代表了「块」中的某个「元素」（也可以叫做「子组件」），是块构成的主要成员。"]],["$","li",{},[["$","code",{},["modifier"]]," 代表了「块」的修饰符，表示不同的状态和版本。使用 ",["$","code",{},["--"]]," 做区分，适用于「块」和「元素」，分别称之为「块修饰符」和「元素修饰符」。"]]]],["$","p",{},["命名的不同部分之间之所以使用 ",["$","code",{},["__"]]," 和 ",["$","code",{},["--"]]," 分割，是因为如果某部分中如果出现了多个单词需要使用 ",["$","code",{},["-"]]," 分隔，这样可以避免造成混淆。"]],["$","h3",{"id":"css-modules"},["CSS Modules"]],["$","p",{},["随着时代的发展，一个大型前端工程中的 CSS 类名越来越多，此时难免会出现类名冲突的情况，此时 CSS Modules 应运而生 —— 它通过为 CSS 类名添加 Hash 等方式来产生唯一的名称来防止冲突的产生。"]],["$","p",{},[["$","a",{"href":"https://github.com/css-modules/css-modules","rel":"external nofollow noreferrer"},["CSS Modules"]]," 并不是 CSS 官方的标准，也不是浏览器的特性，而是使用一些构建工具，比如 Webpack，对 CSS 类名和选择器限定作用域的一种方式。"]],["$","h3",{"id":"utility-first-css"},["Utility-First CSS"]],["$","p",{},["当传统大型项目使用的 CSS 方法论还都大多是上方提到的 OOCSS、SMACSS、BEM 等等主要聚焦在「关注点分离」的「语义化 CSS」方案的时候，Utility-First 的 CSS 概念脱颖而出、逐渐受到社区的关注。而这之中最为被人熟知的、也最典型的就是 ",["$","a",{"href":"https://tailwindcss.com","rel":"external nofollow noreferrer"},["Tailwind CSS"]]," 了。"]],["$","p",{},["Utility-First CSS 不像 Semantic CSS 那样将组件样式放在一个类中，而是为我们提供一个由不同功能类组成的工具箱，我们可以将它们混合在一起应用在页面元素上。这样有几个好处："]],["$","ul",{},[["$","li",{},["不用纠结于类名的命名；"]],["$","li",{},["功能越简单的类，复用率越高，可以减小最终的打包大小；"]],["$","li",{},["不存在全局样式污染问题；"]],["$","li",{},["等等。"]]]],["$","p",{},["但也存在一些不足："]],["$","ul",{},[["$","li",{},[["$","code",{},["class"]]," 属性的内容过长；"]],["$","li",{},["存在 CSS 规则插入顺序相关的问题；"]],["$","li",{},["不能通过语义化类名得知组件的作用；"]],["$","li",{},["不压缩的话构建产物体积过大。"]]]],["$","h2",{"id":"新时代，来临了-——-atomic-css-in-js"},["新时代，来临了 —— Atomic CSS-in-JS"]],["$","p",{},["在前文介绍的 Utility-First CSS 的基础之上更进一步，Atomic CSS 便映入了人们的眼帘。"]],["$","p",{},["Atomic CSS 背后的思想与以往的「关注点分离」的思想可以称得上是背道而驰了。使用 Atomic CSS 时实际上将结构层和样式层耦合在了一起，这样的方式在现代 CSS-in-JS 的代码库中基本上得到了广泛认可，下文将会进行进一步的介绍。"]],["$","p",{},["Atomic CSS 可以看作是 Utility-First CSS 的极致抽象版本，每一个 CSS 类都对应一条单一的 CSS 规则。可面对如此繁复的 CSS 规则，手写 Atomic CSS 的类名并不是一个好的办法。于是 Atomic CSS-in-JS 应运而生，它可以看作是「自动化的 Atomic CSS」："]],["$","ul",{},[["$","li",{},["无需手动设计 CSS 类名；"]],["$","li",{},["能够提取页面的关键 CSS，并进行代码拆分；"]],["$","li",{},["可以解决经典的 CSS 规则插入顺序的问题。"]]]],["$","h3",{"id":"传统-css-编写方式的缺点"},["传统 CSS 编写方式的缺点"]],["$","p",{},["Christopher Chedeau 一直致力于推广 React 生态系统中 CSS-in-JS 理念。在很多次演讲中，他都解释了 CSS 的几大问题："]],["$","p",{},[["$","img",{"src":"https://s1.baoshuo.ren/2022/07/23/5PTlQWfhkVZObpJ.png","alt":"","loading":"lazy"},[]]]],["$","ol",{},[["$","li",{},["全局命名空间"]],["$","li",{},["依赖"]],["$","li",{},["无用代码消除"]],["$","li",{},["代码压缩"]],["$","li",{},["共享常量"]],["$","li",{},["非确定性（Non-Deterministic）解析"]],["$","li",{},["隔离"]]]],["$","p",{},["虽然 Utility-First CSS 和 Atomic CSS 也解决了其中的一些问题，但它们无法解决所有问题（特别是样式的非确定性解析）。"]],["$","h3",{"id":"更小的构建产物"},["更小的构建产物"]],["$","p",{},["传统的 CSS 编写方法无法复用组件间重复的 CSS 规则，比如下图中高亮的几条规则各自躺在它们对应的 CSS 类中："]],["$","p",{},[["$","img",{"src":"https://arina.loli.net/2022/07/23/TKvwu6PpgxalrsG.png","alt":"","loading":"lazy"},[]]]],["$","p",{},["这样会导致 CSS 产物大小与项目的复杂程度和组件数量线性正相关。"]],["$","p",{},["但使用 Atomic CSS 之后，这些规则被提取出来进行复用："]],["$","p",{},[["$","img",{"src":"https://arina.loli.net/2022/07/23/xKRoETDVqQBgFcf.png","alt":"","loading":"lazy"},[]]]],["$","p",{},["随着后期组件数量逐渐增加、能复用的 CSS 规则越来越多、最终 CSS 产物大小与项目复杂程度呈对数关系："]],["$","p",{},[["$","img",{"src":"https://s1.baoshuo.ren/2022/07/16/Uq6nbJXidShyzH8.png","alt":"","loading":"lazy"},[]]]],["$","p",{},["Facebook 分享了他们的数据：在旧网站上，仅登录页就需要加载 413 KiB 的样式文件，而在使用 Atomic CSS-in-JS 重写后，整个站点只有 74 KiB 的样式文件，还包括了深色模式。"]],["$","p",{},["虽然在使用 Atomic CSS 之后，HTML 的体积会显著增大，不过由于这些类名的高冗余度，可以利用 gzip 来压缩掉很大一部分体积。"]],["$","h3",{"id":"处理-css-规则的插入顺序"},["处理 CSS 规则的插入顺序"]],["$","p",{},["让我们再来回顾一遍这个经典的 CSS 规则插入顺序的问题："]],["$","p",{},[["$","img",{"src":"https://s1.baoshuo.ren/2022/07/23/dfu1NqZ7i3pmOrM.png","alt":"","loading":"lazy"},[]]]],["$","p",{},["我们都知道，最后生效的样式不是最后一个类名对应的规则，而是样式表中最后插入的规则。"]],["$","p",{},["那么，如何在 CSS-in-JS 中处理这个问题呢？通用的做法是在生成阶段就将冲突的规则过滤掉，以避免产生冲突。比如下面这个组件："]],["$","pre",{},[["$","code",{"class":"hljs js"},[["$","span",{"class":"hljs-keyword"},["const"]]," styles = style9.",["$","span",{"class":"hljs-title function_"},["create"]],"({\n  ",["$","span",{"class":"hljs-attr"},["card"]],": {\n    ",["$","span",{"class":"hljs-attr"},["marginTop"]],": ",["$","span",{"class":"hljs-string"},["'10px'"]],",\n    ",["$","span",{"class":"hljs-attr"},["marginBottom"]],": ",["$","span",{"class":"hljs-string"},["'10px'"]],",\n  },\n  ",["$","span",{"class":"hljs-attr"},["profileCard"]],": {\n    ",["$","span",{"class":"hljs-attr"},["marginBottom"]],": ",["$","span",{"class":"hljs-string"},["'20px'"]],",\n  },\n});\n\n",["$","span",{"class":"hljs-keyword"},["const"]]," ",["$","span",{"class":"hljs-title function_"},["Component"]]," = (",["$","span",{"class":"hljs-params"},[]],") => (\n  ",["$","span",{"class":"language-xml"},[["$","span",{"class":"hljs-tag"},["<",["$","span",{"class":"hljs-name"},["div"]]," ",["$","span",{"class":"hljs-attr"},["className"]],"=",["$","span",{"class":"hljs-string"},["{style9(styles.card,"]]," ",["$","span",{"class":"hljs-attr"},["styles.profileCard"]],")} />"]]]],"\n);"]]]],["$","p",{},["过滤后组件的实际样式如下："]],["$","pre",{},[["$","code",{"class":"hljs css"},[["$","span",{"class":"hljs-attribute"},["margin-top"]],": ",["$","span",{"class":"hljs-number"},["10px"]],";\n",["$","span",{"class":"hljs-attribute"},["margin-bottom"]],": ",["$","span",{"class":"hljs-number"},["20px"]],";"]]]],["$","p",{},["但 CSS 中有一些简写规则，如果只按照规则名称来处理显然是不行的。有的库强制开发者们不使用简写规则来避免这个问题，而另外的一些库则将这些简写规则展开成多条规则后再进行过滤，比如 ",["$","code",{},["margin: 10px"]]," 可以被拆成 ",["$","code",{},["margin-top: 10px"]],"、",["$","code",{},["margin-right: 10px"]],"、",["$","code",{},["margin-bottom: 10px"]],"、",["$","code",{},["margin-left: 10px"]]," 四条独立的规则。"]],["$","h3",{"id":"经典实现"},["经典实现"]],["$","p",{},["Atomic CSS-in-JS 实现有运行时（Runtime）和预编译（Pre-Compile）两种。"]],["$","h4",{"id":"运行时（runtime）"},["运行时（Runtime）"]],["$","p",{},[["$","a",{"href":"https://styletron.org","rel":"external nofollow noreferrer"},["Styletron"]]," 是 Uber 公司开发的一个较为典型的运行时 Atomic CSS-in-JS 库，驱动了 Uber 的官网和 H5 页面。其优点在于可以动态生成样式，相比于下文中采用预编译方法的库来说灵活度高了不止一点半点。其缺点则在于 Vendor Prefix 等操作需要在 Runtime 执行，因此 Bundle 中必须携带相关依赖导致体积增大。与其相类似的还有沃尔沃汽车前技术主管的 ",["$","a",{"href":"https://fela.js.org/","rel":"external nofollow noreferrer"},["Fela"]],"（驱动了沃尔沃汽车官网，Cloudflare Dashboard 和 Medium 等众多网站），在此不做过多叙述，感兴趣的读者可以自行了解。"]],["$","h4",{"id":"预编译（pre-compile）"},["预编译（Pre-Compile）"]],["$","p",{},[["$","a",{"href":"https://www.youtube.com/watch?v=9JZHodNR184","rel":"external nofollow noreferrer"},["Stylex"]]," 是 Meta（原 Facebook）的一个尚未开源的预编译 Atomic CSS-in-JS 库。其优点在于无需将相关依赖打包发送给客户端，改善了性能。而缺点则是预编译的过程高度依赖静态代码分析，所以难以实现动态样式生成与组合。不过由于 Meta 迟迟不开源 stylex，社区中已经涌现出了数个基于其思想的开源实现，以 ",["$","a",{"href":"https://github.com/johanholmerin/style9","rel":"external nofollow noreferrer"},["style9"]]," 最为知名。"]],["$","p",{},["此外，Atlassian 还编写了一个名为 ",["$","a",{"href":"https://compiledcssinjs.com/","rel":"external nofollow noreferrer"},["compiled"]]," 的预编译 Atomic CSS-in-JS 库，但在笔者的实际使用过程中坑点较多，可能会导致样式的重复生成，并且其对 TypeScript 的支持也不尽人意，遂弃之。"]],["$","h2",{"id":"后记"},["后记"]],["$","p",{},["以上就是本文要介绍关于 Atomic CSS 的全部内容了。"]],["$","p",{},["虽然 Atomic CSS-in-JS 是 React 生态系统中新涌起的一股潮流，但在使用前一定要三思 —— 这个方案到底符不符合项目的需求，而不是盲目地「为了使用而使用」，给将来的维护工作埋雷，但如果使用它能带来显而易见的好处，那么何乐而不为呢？"]],["$","p",{},["笔者才疏学浅，只是在前人的基础之上做了一些微小的工作而已，文章中如有错误欢迎在评论区指正。"]],["$","h2",{"id":"参考资料-2"},["参考资料"]],["$","ol",{},[["$","li",{},[["$","a",{"href":"https://sebastienlorber.com/atomic-css-in-js","rel":"external nofollow noreferrer"},["Atomic CSS-in-JS"]],"，Sébastien Lorber，2020 年 4 月 27 日。"]],["$","li",{},[["$","a",{"href":"https://mongkii.com/blog/2021-07-26-talk-about-atomic-css","rel":"external nofollow noreferrer"},["聊聊原子类（Atomic CSS）"]],"，Mongkii，2021 年 7 月 26 日。"]],["$","li",{},[["$","a",{"href":"http://acgtofe.com/posts/2014/09/valuable-theories-of-css","rel":"external nofollow noreferrer"},["值得参考的 CSS 理论：OOCSS、SMACSS 与 BEM"]],"，ACGTOFE，2014 年 9 月 30 日。"]],["$","li",{},[["$","a",{"href":"https://tailwindcss.com/docs/utility-first","rel":"external nofollow noreferrer"},["Utility-First Fundamentals"]],"，Tailwind CSS。"]]]]],"thumb":"https://s1.baoshuo.ren/2022/07/23/R2LQrmhBxc3PEFy.webp","date":"2022-07-23","updated":"2022-07-23","isoDate":"2022-07-23T09:30:29.000Z","isoUpdate":"2022-07-23T09:30:53.000Z","categories":[{"name":"技术向","url":"/categories/%E6%8A%80%E6%9C%AF%E5%90%91/"}],"tags":[{"name":"前端","url":"/tags/%E5%89%8D%E7%AB%AF/"},{"name":"CSS","url":"/tags/CSS/"},{"name":"Atomic CSS","url":"/tags/Atomic-CSS/"},{"name":"Tailwind","url":"/tags/Tailwind/"}],"license":null,"permalink":"https://blog.baoshuo.ren/post/atomic-css-in-js/","url":"/post/atomic-css-in-js/","prev":null,"next":{"title":"使用 GitHub Actions 自动申请与部署 SSL 证书","url":"/post/actions-ssl-cert/"},"toc":{"0":{"0":{"text":"OOCSS","id":"oocss"},"1":{"0":{"text":"规则分类","id":"规则分类"},"1":{"text":"命名规则","id":"命名规则"},"2":{"text":"最小化适配深度","id":"最小化适配深度"},"text":"SMACSS","id":"smacss"},"2":{"text":"BEM","id":"bem"},"3":{"text":"CSS Modules","id":"css-modules"},"4":{"text":"Utility-First CSS","id":"utility-first-css"},"text":"CSS 编写方法的发展历程","id":"css-编写方法的发展历程"},"1":{"0":{"text":"传统 CSS 编写方式的缺点","id":"传统-css-编写方式的缺点"},"1":{"text":"更小的构建产物","id":"更小的构建产物"},"2":{"text":"处理 CSS 规则的插入顺序","id":"处理-css-规则的插入顺序"},"3":{"text":"经典实现","id":"经典实现"},"text":"新时代，来临了 —— Atomic CSS-in-JS","id":"新时代，来临了-——-atomic-css-in-js"},"2":{"text":"后记","id":"后记"},"3":{"text":"参考资料","id":"参考资料-2"}},"hasToc":true,"comments":true,"wordCount":"约 3 千字"}},"__N_SSG":true}