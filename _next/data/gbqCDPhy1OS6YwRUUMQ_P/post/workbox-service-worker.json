{"pageProps":{"title":"初识 Service Worker —— 使用 Workbox 快速开发 Service Worker - 宝硕博客","post":{"title":"初识 Service Worker —— 使用 Workbox 快速开发 Service Worker","date":"2021-02-28T00:02:04.000Z","updated":"2021-02-28T00:02:04.000Z","type":"post","excerpt":"对于优化前端加载性能这个问题，许多人以 http-cache、异步加载、304 状态码、文件压缩、CDN 等方法来解决。\n其实除了这些方法，还有一个比它们都强大的，那就是 Service Worker 。\n","thumb":"https://s1.baoshuo.ren/2021/02/28/kdnvD8ACWBa1tbI.png","tags":["Web","ServiceWorker","JavaScript"],"categories":["技术向"],"content":"<p>对于优化前端加载性能这个问题，许多人以 http-cache、异步加载、304 状态码、文件压缩、CDN 等方法来解决。<br>\n其实除了这些方法，还有一个比它们都强大的，那就是 Service Worker 。</p>\n\n<p>我们可以使用 Google Chrome 团队的 <a href=https://github.com/GoogleChrome/workbox target=_blank>Workbox</a> 来实现 Service Worker 的快速开发。</p>\n<h2 id=注册-service-worker><a class=anchor href=#注册-service-worker target=_blank></a>注册 Service Worker</h2>\n<p>在页面中添加以下内容以注册一个 Service Worker 。</p>\n<pre><code class=\"hljs language-html\"><span class=hljs-tag>&lt;<span class=hljs-name>script</span>&gt;</span><span class=language-javascript>\n  <span class=hljs-comment>// 检测是否支持 Service Worker</span>\n  <span class=hljs-comment>// 也可使用 navigator.serviceWorker 判断</span>\n  <span class=hljs-keyword>if</span> (<span class=hljs-string>&#x27;serviceWorker&#x27;</span> <span class=hljs-keyword>in</span> navigator) {\n    <span class=hljs-comment>// 为了保证首屏渲染性能，在页面 onload 完之后注册 Service Worker</span>\n    <span class=hljs-comment>// 不使用 window.onload 以免冲突</span>\n    <span class=\"hljs-variable language_\">window</span>.<span class=\"hljs-title function_\">addEventListener</span>(<span class=hljs-string>&#x27;load&#x27;</span>, <span class=hljs-function>() =&gt;</span> {\n      navigator.<span class=hljs-property>serviceWorker</span>.<span class=\"hljs-title function_\">register</span>(<span class=hljs-string>&#x27;/sw.js&#x27;</span>);\n    });\n  }\n</span><span class=hljs-tag>&lt;/<span class=hljs-name>script</span>&gt;</span>\n</code></pre>\n<p>当然，在这之前你需要先有一个 Service Worker 的代码 <code>/sw.js</code> 。</p>\n<p>你可以在这个文件中写入以下代码来检测是否成功地注册了 Service Worker 。</p>\n<pre><code class=\"hljs language-javascript\"><span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">clear</span>();\n<span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=hljs-string>&#x27;Successful registered service worker.&#x27;</span>);\n</code></pre>\n<p><img src=https://s1.baoshuo.ren/2021/02/28/Eu4mVIC2kNrUgiL.png alt=\"\"></p>\n<h2 id=引入-workbox><a class=anchor href=#引入-workbox target=_blank></a>引入 Workbox</h2>\n<p>你可以使用 Google 提供的 CDN 来引入 Workbox 。<br>\n只需在 <code>sw.js</code> 的开头写入以下内容即可：</p>\n<pre><code class=\"hljs language-javascript\"><span class=\"hljs-title function_\">importScripts</span>(\n  <span class=hljs-string>&#x27;https://storage.googleapis.com/workbox-cdn/releases/6.1.1/workbox-sw.js&#x27;</span>\n);\n</code></pre>\n<p>如果你觉得 Google 的 CDN 不太靠谱的话，可以使用 <code>workbox-cli</code> 将资源存在本地：</p>\n<pre><code class=\"hljs language-bash\">npm i workbox-cli -g\nworkbox copyLibraries {path/to/workbox/}\n</code></pre>\n<p>这时需要在 <code>sw.js</code> 的开头将上方写入的内容替换为以下内容即可：</p>\n<pre><code class=\"hljs language-javascript\"><span class=\"hljs-title function_\">importScripts</span>(<span class=hljs-string>&#x27;{path/to}/workbox/workbox-sw.js&#x27;</span>);\nworkbox.<span class=\"hljs-title function_\">setConfig</span>({\n  <span class=hljs-attr>modulePathPrefix</span>: <span class=hljs-string>&#x27;{path/to}/workbox/&#x27;</span>,\n});\n</code></pre>\n<h2 id=workbox-策略><a class=anchor href=#workbox-策略 target=_blank></a>Workbox 策略</h2>\n<h3 id=stale-while-revalidate（重新验证时过期）><a class=anchor href=#stale-while-revalidate（重新验证时过期） target=_blank></a>Stale While Revalidate（重新验证时过期）</h3>\n<p><img src=https://s1.baoshuo.ren/2021/02/28/rx8zafbqPe1JnkX.png alt=\"\"></p>\n<p>此策略将对网络请求使用缓存来响应（如果有），并在后台更新缓存。如果未缓存，它将等待网络响应并使用它。<br>\n这是一个相当安全的策略，因为这意味着用户会定期更新其缓存。这种策略的缺点是：它总是从网络上请求资源，较为浪费用户的带宽。</p>\n<pre><code class=\"hljs language-javascript\"><span class=\"hljs-title function_\">registerRoute</span>(\n  <span class=hljs-keyword>new</span> <span class=\"hljs-title class_\">RegExp</span>(matchString),\n  <span class=hljs-keyword>new</span> workbox.<span class=hljs-property>strategies</span>.<span class=\"hljs-title class_\">StaleWhileRevalidate</span>()\n);\n</code></pre>\n<h3 id=network-first（网络优先）><a class=anchor href=#network-first（网络优先） target=_blank></a>Network First（网络优先）</h3>\n<p><img src=https://s1.baoshuo.ren/2021/02/28/9ViWk1ZyU4CuDxE.png alt=\"\"></p>\n<p>此策略将尝试首先从网络获得响应。如果收到响应，它将把它传递给浏览器，并将其保存到缓存中。如果网络请求失败，将使用最后一个缓存的响应。</p>\n<pre><code class=\"hljs language-javascript\"><span class=\"hljs-title function_\">registerRoute</span>(<span class=hljs-keyword>new</span> <span class=\"hljs-title class_\">RegExp</span>(matchString), <span class=hljs-keyword>new</span> workbox.<span class=hljs-property>strategies</span>.<span class=\"hljs-title class_\">NetworkFirst</span>());\n</code></pre>\n<h3 id=cache-first（缓存优先）><a class=anchor href=#cache-first（缓存优先） target=_blank></a>Cache First（缓存优先）</h3>\n<p><img src=https://s1.baoshuo.ren/2021/02/28/jkn4Y3mNCRZrSdX.png alt=\"\"></p>\n<p>此策略将首先检查缓存中是否有响应，如果有响应，则使用该策略。如果请求不在缓存中，则将使用网络，并将任何有效响应添加到缓存中，然后再传递给浏览器。</p>\n<pre><code class=\"hljs language-javascript\"><span class=\"hljs-title function_\">registerRoute</span>(<span class=hljs-keyword>new</span> <span class=\"hljs-title class_\">RegExp</span>(matchString), <span class=hljs-keyword>new</span> workbox.<span class=hljs-property>strategies</span>.<span class=\"hljs-title class_\">CacheFirst</span>());\n</code></pre>\n<h3 id=network-only（仅网络）><a class=anchor href=#network-only（仅网络） target=_blank></a>Network Only（仅网络）</h3>\n<p><img src=https://s1.baoshuo.ren/2021/02/28/cQYTlvie1dX8hOF.png alt=\"\"></p>\n<p>强制响应来自网络。</p>\n<pre><code class=\"hljs language-javascript\"><span class=\"hljs-title function_\">registerRoute</span>(<span class=hljs-keyword>new</span> <span class=\"hljs-title class_\">RegExp</span>(matchString), <span class=hljs-keyword>new</span> workbox.<span class=hljs-property>strategies</span>.<span class=\"hljs-title class_\">NetworkOnly</span>());\n</code></pre>\n<h3 id=cache-only（仅缓存）><a class=anchor href=#cache-only（仅缓存） target=_blank></a>Cache Only（仅缓存）</h3>\n<p><img src=https://s1.baoshuo.ren/2021/02/28/71Sw5tTaBQKl8ri.png alt=\"\"></p>\n<p>强制响应来自缓存。</p>\n<pre><code class=\"hljs language-javascript\"><span class=\"hljs-title function_\">registerRoute</span>(<span class=hljs-keyword>new</span> <span class=\"hljs-title class_\">RegExp</span>(matchString), <span class=hljs-keyword>new</span> workbox.<span class=hljs-property>strategies</span>.<span class=\"hljs-title class_\">CacheOnly</span>());\n</code></pre>\n<h3 id=策略配置><a class=anchor href=#策略配置 target=_blank></a>策略配置</h3>\n<p>可以通过定义要使用的插件来自定义路由的行为。</p>\n<pre><code class=\"hljs language-javascript\"><span class=hljs-keyword>new</span> workbox.<span class=hljs-property>strategies</span>.<span class=\"hljs-title class_\">StaleWhileRevalidate</span>({\n    <span class=hljs-comment>// Use a custom cache for this route.</span>\n    <span class=hljs-attr>cacheName</span>: <span class=hljs-string>&#x27;my-cache-name&#x27;</span>,\n\n    <span class=hljs-comment>// Add an array of custom plugins (e.g. `ExpirationPlugin`).</span>\n    <span class=hljs-attr>plugins</span>: [\n        ...\n    ]\n});\n</code></pre>\n<h2 id=workbox-中的自定义策略><a class=anchor href=#workbox-中的自定义策略 target=_blank></a>Workbox 中的自定义策略</h2>\n<p>在某些情况下，您可能希望使用自己的其他策略来响应请求，或者只是通过模板在 Service Worker 中生成请求。<br>\n为此可以提供一个异步返回 <code>Response</code> 对象的函数 <code>handler</code> 。</p>\n<pre><code class=\"hljs language-javascript\"><span class=hljs-keyword>const</span> <span class=\"hljs-title function_\">handler</span> = <span class=hljs-keyword>async</span> (<span class=hljs-params>{ url, event }</span>) =&gt; {\n  <span class=hljs-keyword>return</span> <span class=hljs-keyword>new</span> <span class=\"hljs-title class_\">Response</span>(<span class=hljs-string>`Custom handler response.`</span>);\n};\n\nworkbox.<span class=hljs-property>routing</span>.<span class=\"hljs-title function_\">registerRoute</span>(<span class=hljs-keyword>new</span> <span class=\"hljs-title class_\">RegExp</span>(matchString), handler);\n</code></pre>\n<p>需要注意的是，如果在 <code>match</code> 回调中返回一个值，它将 <code>handler</code> 作为 <code>params</code> 参数传递到回调中。</p>\n<pre><code class=\"hljs language-javascript\"><span class=hljs-keyword>const</span> <span class=\"hljs-title function_\">match</span> = (<span class=hljs-params>{ url, event }</span>) =&gt; {\n  <span class=hljs-keyword>if</span> (url.<span class=hljs-property>pathname</span> === <span class=hljs-string>&#x27;/example&#x27;</span>) {\n    <span class=hljs-keyword>return</span> {\n      <span class=hljs-attr>name</span>: <span class=hljs-string>&#x27;Workbox&#x27;</span>,\n      <span class=hljs-attr>type</span>: <span class=hljs-string>&#x27;guide&#x27;</span>,\n    };\n  }\n};\n\n<span class=hljs-keyword>const</span> <span class=\"hljs-title function_\">handler</span> = <span class=hljs-keyword>async</span> (<span class=hljs-params>{ url, event, params }</span>) =&gt; {\n  <span class=hljs-comment>// Response will be &quot;A guide to Workbox&quot;</span>\n  <span class=hljs-keyword>return</span> <span class=hljs-keyword>new</span> <span class=\"hljs-title class_\">Response</span>(<span class=hljs-string>`A <span class=hljs-subst>${params.type}</span> to <span class=hljs-subst>${params.name}</span>`</span>);\n};\n\nworkbox.<span class=hljs-property>routing</span>.<span class=\"hljs-title function_\">registerRoute</span>(match, handler);\n</code></pre>\n<p>如果 URL 中的某些信息可以在 match 回调中解析一次并在中使用，则这可能会对 <code>handler</code> 有所帮助。</p>\n<h2 id=workbox-实践><a class=anchor href=#workbox-实践 target=_blank></a>Workbox 实践</h2>\n<p>通常对于大部分项目使用 Workbox 时一般会引入相应的 gulp 或者 webpack 插件，在构建流程中完成对 Service Worker 的注册、将指定 URL 进行 Precache、完成 sw.js 的生成，等等。<br>\n但是对于 Hexo、Jekyll 这些静态站点生成器或者 WordPress、Typecho 这些 CMS，如果不安装相应的插件，就需要自己从头编写一个 <code>sw.js</code>。</p>\n<p>先写一下总的配置：</p>\n<pre><code class=\"hljs language-javascript\"><span class=hljs-keyword>let</span> cacheSuffixVersion = <span class=hljs-string>&#x27;-210227&#x27;</span>; <span class=hljs-comment>// 缓存版本号</span>\n<span class=hljs-keyword>const</span> maxEntries = <span class=hljs-number>100</span>; <span class=hljs-comment>// 最大条目数</span>\n\ncore.<span class=\"hljs-title function_\">setCacheNameDetails</span>({\n  <span class=hljs-attr>prefix</span>: <span class=hljs-string>&#x27;baoshuo-blog&#x27;</span>, <span class=hljs-comment>// 前缀</span>\n  <span class=hljs-attr>suffix</span>: cacheSuffixVersion, <span class=hljs-comment>// 后缀</span>\n});\n</code></pre>\n<h3 id=google-fonts><a class=anchor href=#google-fonts target=_blank></a>Google Fonts</h3>\n<p>Google Fonts 主要使用两个域名：<code>fonts.googleapis.com</code> 和 <code>fonts.gstatic.com</code> ，因此只需在匹配到这两个域名时进行缓存。</p>\n<pre><code class=\"hljs language-javascript\">workbox.<span class=hljs-property>routing</span>.<span class=\"hljs-title function_\">registerRoute</span>(\n  <span class=hljs-comment>// 匹配 fonts.googleapis.com 和 fonts.gstatic.com 两个域名</span>\n  <span class=hljs-keyword>new</span> <span class=\"hljs-title class_\">RegExp</span>(<span class=hljs-string>&#x27;^https://(?:fonts\\\\.googleapis\\\\.com|fonts\\\\.gstatic\\\\.com)&#x27;</span>),\n  <span class=hljs-keyword>new</span> workbox.<span class=hljs-property>strategies</span>.<span class=\"hljs-title class_\">StaleWhileRevalidate</span>({\n    <span class=hljs-comment>// cache storage 名称和版本号</span>\n    <span class=hljs-attr>cacheName</span>: <span class=hljs-string>&#x27;font-cache&#x27;</span> + cacheSuffixVersion,\n    <span class=hljs-attr>plugins</span>: [\n      <span class=hljs-comment>// 使用 expiration 插件实现缓存条目数目和时间控制</span>\n      <span class=hljs-keyword>new</span> workbox.<span class=hljs-property>expiration</span>.<span class=\"hljs-title class_\">ExpirationPlugin</span>({\n        <span class=hljs-comment>// 最大保存项目</span>\n        maxEntries,\n        <span class=hljs-comment>// 缓存 30 天</span>\n        <span class=hljs-attr>maxAgeSeconds</span>: <span class=hljs-number>30</span> * <span class=hljs-number>24</span> * <span class=hljs-number>60</span> * <span class=hljs-number>60</span>,\n      }),\n      <span class=hljs-comment>// 使用 cacheableResponse 插件缓存状态码为 0 的请求</span>\n      <span class=hljs-keyword>new</span> workbox.<span class=hljs-property>cacheableResponse</span>.<span class=\"hljs-title class_\">CacheableResponsePlugin</span>({\n        <span class=hljs-attr>statuses</span>: [<span class=hljs-number>0</span>, <span class=hljs-number>200</span>],\n      }),\n    ],\n  })\n);\n</code></pre>\n<h3 id=jsdelivr-cdn><a class=anchor href=#jsdelivr-cdn target=_blank></a>jsDelivr CDN</h3>\n<p>使用 jsDelivr CDN 时如果指定了库的版本，对应的文件可以称得上是永久不会改变的，所以使用 <code>CacheFirst</code> 来进行缓存。</p>\n<pre><code class=\"hljs language-javascript\">workbox.<span class=hljs-property>routing</span>.<span class=\"hljs-title function_\">registerRoute</span>(\n  <span class=hljs-keyword>new</span> <span class=\"hljs-title class_\">RegExp</span>(<span class=hljs-string>&#x27;^https://cdn\\\\.jsdelivr\\\\.net&#x27;</span>),\n  <span class=hljs-keyword>new</span> workbox.<span class=hljs-property>strategies</span>.<span class=\"hljs-title class_\">CacheFirst</span>({\n    <span class=hljs-attr>cacheName</span>: <span class=hljs-string>&#x27;static-immutable&#x27;</span> + cacheSuffixVersion,\n    <span class=hljs-attr>fetchOptions</span>: {\n      <span class=hljs-attr>mode</span>: <span class=hljs-string>&#x27;cors&#x27;</span>,\n      <span class=hljs-attr>credentials</span>: <span class=hljs-string>&#x27;omit&#x27;</span>,\n    },\n    <span class=hljs-attr>plugins</span>: [\n      <span class=hljs-keyword>new</span> workbox.<span class=hljs-property>expiration</span>.<span class=\"hljs-title class_\">ExpirationPlugin</span>({\n        <span class=hljs-attr>maxAgeSeconds</span>: <span class=hljs-number>30</span> * <span class=hljs-number>24</span> * <span class=hljs-number>60</span> * <span class=hljs-number>60</span>,\n        <span class=hljs-attr>purgeOnQuotaError</span>: <span class=hljs-literal>true</span>,\n      }),\n    ],\n  })\n);\n</code></pre>\n<h3 id=google-analytics><a class=anchor href=#google-analytics target=_blank></a>Google Analytics</h3>\n<p>Workbox 有一个 <a href=https://developers.google.com/web/tools/workbox/guides/enable-offline-analytics target=_blank>Google Analytics 离线统计插件</a>，可惜我用的是 Sukka 大佬编写的<a href=https://github.com/SukkaW/cloudflare-workers-async-google-analytics target=_blank>非官方 Google Analytics 实现</a>，所以只能添加一个 <code>NetworkOnly</code> 来放弃离线统计。</p>\n<pre><code class=\"hljs language-javascript\">workbox.<span class=hljs-property>routing</span>.<span class=\"hljs-title function_\">registerRoute</span>(\n  <span class=hljs-keyword>new</span> <span class=\"hljs-title class_\">RegExp</span>(<span class=hljs-string>&#x27;^https://api\\\\.baoshuo\\\\.ren/cfga/(.*)&#x27;</span>),\n  <span class=hljs-keyword>new</span> workbox.<span class=hljs-property>strategies</span>.<span class=\"hljs-title class_\">NetworkOnly</span>({\n    <span class=hljs-attr>plugins</span>: [\n      <span class=hljs-keyword>new</span> workbox.<span class=hljs-property>backgroundSync</span>.<span class=\"hljs-title class_\">BackgroundSyncPlugin</span>(<span class=hljs-string>&#x27;Optical_Collect&#x27;</span>, {\n        <span class=hljs-attr>maxRetentionTime</span>: <span class=hljs-number>12</span> * <span class=hljs-number>60</span>, <span class=hljs-comment>// Retry for max of 12 Hours (specified in minutes)</span>\n      }),\n    ],\n  })\n);\n</code></pre>\n<h3 id=图片><a class=anchor href=#图片 target=_blank></a>图片</h3>\n<p>由于我开通了 <a href=http://SM.MS target=_blank>SM.MS</a> 的 LifeTime Premium VIP ，所以图片当然是要存到这里啦~</p>\n<p><a href=http://SM.MS target=_blank>SM.MS</a> 的图片域名有这几个：<code>i.loli.net</code>、<code>vip1.loli.net</code>、<code>vip2.loli.net</code>、<code>s1.baoshuo.ren</code>、<code>s1.baoshuo.ren</code>，只需要写一个正则匹配下就好了。</p>\n<p>由于图片链接对应的文件像 jsDelivr 一样也是几乎永久都不会改变的，所以使用 <code>CacheFirst</code> 来进行缓存。</p>\n<pre><code class=\"hljs language-javascript\">workbox.<span class=hljs-property>routing</span>.<span class=\"hljs-title function_\">registerRoute</span>(\n  <span class=hljs-keyword>new</span> <span class=\"hljs-title class_\">RegExp</span>(<span class=hljs-string>&#x27;^https://(?:i|vip[0-9])\\\\.loli\\\\.(?:io|net)&#x27;</span>),\n  <span class=hljs-keyword>new</span> workbox.<span class=hljs-property>strategies</span>.<span class=\"hljs-title class_\">CacheFirst</span>({\n    <span class=hljs-attr>cacheName</span>: <span class=hljs-string>&#x27;img-cache&#x27;</span> + cacheSuffixVersion,\n    <span class=hljs-attr>plugins</span>: [\n      <span class=hljs-comment>// 使用 expiration 插件实现缓存条目数目和时间控制</span>\n      <span class=hljs-keyword>new</span> workbox.<span class=hljs-property>expiration</span>.<span class=\"hljs-title class_\">ExpirationPlugin</span>({\n        maxEntries, <span class=hljs-comment>// 最大保存项目</span>\n        <span class=hljs-attr>maxAgeSeconds</span>: <span class=hljs-number>30</span> * <span class=hljs-number>24</span> * <span class=hljs-number>60</span> * <span class=hljs-number>60</span>, <span class=hljs-comment>// 缓存 30 天</span>\n      }),\n      <span class=hljs-comment>// 使用 cacheableResponse 插件缓存状态码为 0 的请求</span>\n      <span class=hljs-keyword>new</span> workbox.<span class=hljs-property>cacheableResponse</span>.<span class=\"hljs-title class_\">CacheableResponsePlugin</span>({\n        <span class=hljs-attr>statuses</span>: [<span class=hljs-number>0</span>, <span class=hljs-number>200</span>],\n      }),\n    ],\n  })\n);\n</code></pre>\n<h3 id=友情链接><a class=anchor href=#友情链接 target=_blank></a>友情链接</h3>\n<p>这些文件只是偶尔更新，使用 <code>StaleWhileRevalidate</code> ，可以兼顾速度与版本更新。</p>\n<pre><code class=\"hljs language-javascript\">workbox.<span class=hljs-property>routing</span>.<span class=\"hljs-title function_\">registerRoute</span>(\n  <span class=hljs-keyword>new</span> <span class=\"hljs-title class_\">RegExp</span>(<span class=hljs-string>&#x27;^https://friends\\\\.baoshuo\\\\.ren(.*)(png|jpg|jpeg|svg|gif)&#x27;</span>),\n  <span class=hljs-keyword>new</span> workbox.<span class=hljs-property>strategies</span>.<span class=\"hljs-title class_\">StaleWhileRevalidate</span>({\n    <span class=hljs-attr>cacheName</span>: <span class=hljs-string>&#x27;img-cache&#x27;</span> + cacheSuffixVersion,\n    <span class=hljs-attr>fetchOptions</span>: {\n      <span class=hljs-attr>mode</span>: <span class=hljs-string>&#x27;cors&#x27;</span>,\n      <span class=hljs-attr>credentials</span>: <span class=hljs-string>&#x27;omit&#x27;</span>,\n    },\n  })\n);\nworkbox.<span class=hljs-property>routing</span>.<span class=\"hljs-title function_\">registerRoute</span>(\n  <span class=hljs-keyword>new</span> <span class=\"hljs-title class_\">RegExp</span>(<span class=hljs-string>&#x27;https://friends\\\\.baoshuo\\\\.ren/links.json&#x27;</span>),\n  <span class=hljs-keyword>new</span> workbox.<span class=hljs-property>strategies</span>.<span class=\"hljs-title class_\">StaleWhileRevalidate</span>()\n);\n</code></pre>\n<h3 id=disqus-评论><a class=anchor href=#disqus-评论 target=_blank></a>Disqus 评论</h3>\n<p>DisqusJS 判断访客的 Disqus 可用性是通过检查 <code>shortname.disqus.com/favicon.ico</code> 和 <code>disqus.com/favicon.ico</code> ，显然是不能被缓存的。<br>\nAPI 可以在无网络时使用 <code>NetworkFirst</code> 来达到无网络时也能查看评论的效果。<br>\n另外 Disqus 本身也没有缓存的必要，所以对 <code>*.disqus.com</code> 使用 <code>NetworkOnly</code> 即可。<br>\n但是 <code>*.disquscdn.com</code> 下的头像、JS、CSS 是可以缓存一段时间的，所以使用 <code>CacheFirst</code> 缓存 10 天。</p>\n<pre><code class=\"hljs language-javascript\"><span class=hljs-comment>// API</span>\nworkbox.<span class=hljs-property>routing</span>.<span class=\"hljs-title function_\">registerRoute</span>(\n  <span class=hljs-keyword>new</span> <span class=\"hljs-title class_\">RegExp</span>(<span class=hljs-string>&#x27;^https://api\\\\.baoshuo\\\\.ren/disqus/(.*)&#x27;</span>),\n  <span class=hljs-keyword>new</span> workbox.<span class=hljs-property>strategies</span>.<span class=\"hljs-title class_\">NetworkFirst</span>({\n    <span class=hljs-attr>cacheName</span>: <span class=hljs-string>&#x27;dsqjs-api&#x27;</span> + cacheSuffixVersion,\n    <span class=hljs-attr>fetchOptions</span>: {\n      <span class=hljs-attr>mode</span>: <span class=hljs-string>&#x27;cors&#x27;</span>,\n      <span class=hljs-attr>credentials</span>: <span class=hljs-string>&#x27;omit&#x27;</span>,\n    },\n    <span class=hljs-attr>networkTimeoutSeconds</span>: <span class=hljs-number>3</span>,\n  })\n);\n<span class=hljs-comment>// Disqus</span>\nworkbox.<span class=hljs-property>routing</span>.<span class=\"hljs-title function_\">registerRoute</span>(\n  <span class=hljs-keyword>new</span> <span class=\"hljs-title class_\">RegExp</span>(<span class=hljs-string>&#x27;^https://(.*)disqus\\\\.com&#x27;</span>),\n  <span class=hljs-keyword>new</span> workbox.<span class=hljs-property>strategies</span>.<span class=\"hljs-title class_\">NetworkOnly</span>()\n);\nworkbox.<span class=hljs-property>routing</span>.<span class=\"hljs-title function_\">registerRoute</span>(\n  <span class=hljs-keyword>new</span> <span class=\"hljs-title class_\">RegExp</span>(<span class=hljs-string>&#x27;^https://(.*)disquscdn\\\\.com(.*)&#x27;</span>),\n  <span class=hljs-keyword>new</span> workbox.<span class=hljs-property>strategies</span>.<span class=\"hljs-title class_\">CacheFirst</span>({\n    <span class=hljs-attr>cacheName</span>: <span class=hljs-string>&#x27;disqus-cdn-cache&#x27;</span> + cacheSuffixVersion,\n    <span class=hljs-attr>plugins</span>: [\n      <span class=hljs-keyword>new</span> workbox.<span class=hljs-property>expiration</span>.<span class=\"hljs-title class_\">ExpirationPlugin</span>({\n        <span class=hljs-attr>maxAgeSeconds</span>: <span class=hljs-number>10</span> * <span class=hljs-number>24</span> * <span class=hljs-number>60</span> * <span class=hljs-number>60</span>,\n      }),\n      <span class=hljs-keyword>new</span> workbox.<span class=hljs-property>cacheableResponse</span>.<span class=\"hljs-title class_\">CacheableResponsePlugin</span>({\n        <span class=hljs-attr>statuses</span>: [<span class=hljs-number>0</span>, <span class=hljs-number>200</span>],\n      }),\n    ],\n  })\n);\n</code></pre>\n<h3 id=后缀匹配><a class=anchor href=#后缀匹配 target=_blank></a>后缀匹配</h3>\n<p>针对其余没有被域名匹配到的静态文件，通过文件后缀进行匹配并使用 <code>StaleWhileRevalidate</code> ，可以兼顾速度与版本更新。</p>\n<pre><code class=\"hljs language-javascript\">workbox.<span class=hljs-property>routing</span>.<span class=\"hljs-title function_\">registerRoute</span>(\n  <span class=hljs-keyword>new</span> <span class=\"hljs-title class_\">RegExp</span>(<span class=hljs-string>&#x27;.*.(?:png|jpg|jpeg|svg|gif|webp)&#x27;</span>),\n  <span class=hljs-keyword>new</span> workbox.<span class=hljs-property>strategies</span>.<span class=\"hljs-title class_\">StaleWhileRevalidate</span>()\n);\nworkbox.<span class=hljs-property>routing</span>.<span class=\"hljs-title function_\">registerRoute</span>(\n  <span class=hljs-keyword>new</span> <span class=\"hljs-title class_\">RegExp</span>(<span class=hljs-string>&#x27;.*.(css|js)&#x27;</span>),\n  <span class=hljs-keyword>new</span> workbox.<span class=hljs-property>strategies</span>.<span class=\"hljs-title class_\">StaleWhileRevalidate</span>()\n);\n</code></pre>\n<h3 id=默认行为><a class=anchor href=#默认行为 target=_blank></a>默认行为</h3>\n<p>使用 Workbox 的 defaultHandler 匹配剩下的请求（包括页面自身），一律使用 <code>NetworkFirst</code> ，借助 Workbox 的 <code>runtimeCache</code> 起到加速和离线效果。</p>\n<pre><code class=\"hljs language-javascript\">workbox.<span class=hljs-property>routing</span>.<span class=\"hljs-title function_\">setDefaultHandler</span>(\n  <span class=hljs-keyword>new</span> workbox.<span class=hljs-property>strategies</span>.<span class=\"hljs-title class_\">NetworkFirst</span>({\n    <span class=hljs-attr>networkTimeoutSeconds</span>: <span class=hljs-number>3</span>,\n  })\n);\n</code></pre>\n<h2 id=参考资料><a class=anchor href=#参考资料 target=_blank></a>参考资料</h2>\n<p><em>文章头图来自：<a href=https://developers.google.com/web/tools/workbox target=_blank>https://developers.google.com/web/tools/workbox</a></em></p>\n<p><em><a href=#Workbox-%E7%AD%96%E7%95%A5 target=_blank>Workbox 策略</a> 一节中的配图来自：<a href=https://web.dev/offline-cookbook/ target=_blank>https://web.dev/offline-cookbook/</a></em></p>\n<ul>\n<li><a href=https://developers.google.com/web/tools/workbox/ target=_blank>Workbox - Google Developers</a></li>\n<li><a href=https://blog.skk.moe/post/hello-workbox/ target=_blank>Workbox, not sw-toolbox &amp; sw-precache - Sukka's Blog</a></li>\n<li><a href=https://github.com/GoogleChrome/workbox target=_blank>GoogleChrome/workbox - GitHub</a></li>\n<li><a href=https://web.dev/offline-cookbook/#serving-suggestions target=_blank>The Offline Cookbook - web.dev</a></li>\n</ul>\n","katex":false,"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E6%B3%A8%E5%86%8C-service-worker\"><span class=\"toc-text\">注册 Service Worker</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%BC%95%E5%85%A5-workbox\"><span class=\"toc-text\">引入 Workbox</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#workbox-%E7%AD%96%E7%95%A5\"><span class=\"toc-text\">Workbox 策略</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#stale-while-revalidate%EF%BC%88%E9%87%8D%E6%96%B0%E9%AA%8C%E8%AF%81%E6%97%B6%E8%BF%87%E6%9C%9F%EF%BC%89\"><span class=\"toc-text\">Stale While Revalidate（重新验证时过期）</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#network-first%EF%BC%88%E7%BD%91%E7%BB%9C%E4%BC%98%E5%85%88%EF%BC%89\"><span class=\"toc-text\">Network First（网络优先）</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#cache-first%EF%BC%88%E7%BC%93%E5%AD%98%E4%BC%98%E5%85%88%EF%BC%89\"><span class=\"toc-text\">Cache First（缓存优先）</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#network-only%EF%BC%88%E4%BB%85%E7%BD%91%E7%BB%9C%EF%BC%89\"><span class=\"toc-text\">Network Only（仅网络）</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#cache-only%EF%BC%88%E4%BB%85%E7%BC%93%E5%AD%98%EF%BC%89\"><span class=\"toc-text\">Cache Only（仅缓存）</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E7%AD%96%E7%95%A5%E9%85%8D%E7%BD%AE\"><span class=\"toc-text\">策略配置</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#workbox-%E4%B8%AD%E7%9A%84%E8%87%AA%E5%AE%9A%E4%B9%89%E7%AD%96%E7%95%A5\"><span class=\"toc-text\">Workbox 中的自定义策略</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#workbox-%E5%AE%9E%E8%B7%B5\"><span class=\"toc-text\">Workbox 实践</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#google-fonts\"><span class=\"toc-text\">Google Fonts</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#jsdelivr-cdn\"><span class=\"toc-text\">jsDelivr CDN</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#google-analytics\"><span class=\"toc-text\">Google Analytics</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%9B%BE%E7%89%87\"><span class=\"toc-text\">图片</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%8F%8B%E6%83%85%E9%93%BE%E6%8E%A5\"><span class=\"toc-text\">友情链接</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#disqus-%E8%AF%84%E8%AE%BA\"><span class=\"toc-text\">Disqus 评论</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%90%8E%E7%BC%80%E5%8C%B9%E9%85%8D\"><span class=\"toc-text\">后缀匹配</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E9%BB%98%E8%AE%A4%E8%A1%8C%E4%B8%BA\"><span class=\"toc-text\">默认行为</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99\"><span class=\"toc-text\">参考资料</span></a></li></ol>","comment":true,"path":"/post/workbox-service-worker/","url":"https://blog.baoshuo.ren/post/workbox-service-worker/"},"__post":true},"__N_SSG":true}